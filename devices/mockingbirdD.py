###################################################
#          !!! THIS CODE IS GENERATED !!!         #
#          !!!      DO NOT EDIT       !!!         #
###################################################
#!/usr/bin/env python

import sys
import devices.pmbusCommand as pmbusCommand
from devices.regMbirdRevD import *

###################################################################
## For DMA reads and writes
###################################################################
def dma(address, register, value = None):
    Cmd1 = pmbusCommand.cPMBusIntCmd(0xC7)
    Cmd2 = pmbusCommand.cPMBusLongCmd(0xC6)
    
    Cmd1.Write(address, register)
    if (value == None):
        value = Cmd2.Read(address)
    else:
        Cmd2.Write(address, value)
        
    return(value)

############################################################
#
############################################################
def pmbus_bits(PmbCmd, address, bits, shift, value):

    # Create a mask for the bits we are writing
    mask = (2**bits) - 1
    # Read the register
    reg = PmbCmd.Read(address)
    if (value == None):
        value = (reg >> shift) & mask
    else:
        # The PMBus cmd object will have the length of the
        # command in bytes.  Use that to determine how
        # many bits are in this register
        reg_bits = PmbCmd.length * 8
        # Make sure the value only uses those bits
        value = value & mask
        # Create an invert mask so we can clear these
        # bits before we write them
        inv_mask = mask << (shift)
        inv_mask = (inv_mask ^ (2 ** (reg_bits + 1) - 1)) & ((2**reg_bits)-1)
        # Modify the value
        reg = (reg & inv_mask) + ((value & mask) << shift)
        # Write the new value to the regiser
        PmbCmd.Write(address, reg)
    return(value)

############################################################
#  This function performs a register read-modify-write
#  on bit fields.  It will read the register, clear the
#  bits that are to be written then write those bits.   
#  
#  register is memory location to dma to/from
#  address  is the I2C address of the board we are talking
#           to
#  bits     is the number of bits we are writting
#  shift    is how much to left shift the value
#  value    is the value to write.
#
# example:
#    bit_write(x, y, 3, 5, 6)
#
# writes these bits to a 16 bit register
#
#    xxxxxxxx101xxxxx
############################################################
def dma_bits(register, address, bits, shift, value):
    # Assume 32 bits
    reg_bits = 32

    # Create a mask for the bits we are writing
    mask = (2**bits) - 1
    reg = dma(address, register)
    if (value == None):
        # Read the register
        value = (reg >> shift) & mask
    else:
        # Make sure the value only uses those bits
        value = value & mask
        # Create an invert mask so we can clear these
        # bits before we write them
        inv_mask = mask << (shift)
        inv_mask = (inv_mask ^ (2 ** (reg_bits + 1) - 1)) & ((2**reg_bits)-1)
        # Read the register
        # Modify the value
        reg = (reg & inv_mask) + ((value & mask) << shift)
        # Write the new value to the regiser
        dma(address, register, reg)
    return(value)

###################################################################
## Select channel for PMBus access
###################################################################
class page_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x0)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Turn channel on or off or select margin voltages
###################################################################
class oper_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x1)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class oper_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.onCmd = (self.reg_value >> 7) & 0x1
            self.offSlow = (self.reg_value >> 6) & 0x1
            self.margA = (self.reg_value >> 4) & 0x3
            self.margB = (self.reg_value >> 2) & 0x3
            self.transCtrl = (self.reg_value >> 1) & 0x1

    def read_object(self):
        return(self.oper_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.onCmd & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.offSlow & 0x1) << 6)
        reg = (reg & 0xCF) + ((register_object.margA & 0x3) << 4)
        reg = (reg & 0xF3) + ((register_object.margB & 0x3) << 2)
        reg = (reg & 0xFD) + ((register_object.transCtrl & 0x1) << 1)
        self.Cmd.Write(self.address, reg)

    ## Activate voltage regulation if 1
    def onCmd(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## On turn off, <br>   Use delay and ramp if 1, <br>   Immediate decay if 0
    def offSlow(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## Select margin: <br>   low margin (01), <br>   high margin (10), <br>   normal (00), <br>   AVS (11) voltage if ON
    def margA(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 4, value)
        return(value)
    ## When on with margin: <br>   ignore faults if 01, <br>   act on faults if 10
    def margB(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 2, value)
        return(value)
    ## When switch from AVS to pmBus control, <br>  1=copy AVS Vout to pmBus VOUTCMD, <br>   0=Slew to pmBus Vout
    def transCtrl(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, value)
        return(value)

###################################################################
## Configure what conditions turn on and off system
###################################################################
class onOff_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x2)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class onOff_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.notAlwaysOn = (self.reg_value >> 4) & 0x1
            self.reqOperCmd = (self.reg_value >> 3) & 0x1
            self.reqEnablePin = (self.reg_value >> 2) & 0x1
            self.enablPol = (self.reg_value >> 1) & 0x1
            self.immediateOff = self.reg_value & 0x1

    def read_object(self):
        return(self.onOff_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xEF) + ((register_object.notAlwaysOn & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.reqOperCmd & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.reqEnablePin & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.enablPol & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.immediateOff & 0x1)
        self.Cmd.Write(self.address, reg)

    ## Start up output always if 0, on command/enable if 1
    def notAlwaysOn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, value)
        return(value)
    ## OPERATION ON command required if 1
    def reqOperCmd(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, value)
        return(value)
    ## ENABLE pin active required if 1
    def reqEnablePin(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, value)
        return(value)
    ## ENABLE pin is active high if 1 or low if 0
    def enablPol(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, value)
        return(value)
    ## Use the programmed turn off delay if 0 or no delay if 1
    def immediateOff(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## Clear faults on write
###################################################################
class clearFault_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x3)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Select phase for PMBus access
###################################################################
class phase_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x4)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Write PAGE, address, value
###################################################################
class pagePlusWr_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 0
        self.Cmd = pmbusCommand.cPMBusNoDataCmd(0x5)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## Write PAGE, address, read value
###################################################################
class pagePlusRd_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 0
        self.Cmd = pmbusCommand.cPMBusNoDataCmd(0x6)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## Set write and read zones for each page
###################################################################
class zoneConfig_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 0
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x7)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## Set active zone number
###################################################################
class zoneActive_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class zoneActive_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.writeZone = (self.reg_value >> 8) & 0xFF
            self.readZone = self.reg_value & 0xFF

    def read_object(self):
        return(self.zoneActive_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.writeZone & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.readZone & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## Active write zone
    def writeZone(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 8, value)
        return(value)
    ## Active read zone
    def readZone(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## pmBus Write Protection: allow 80=WRTPROT 40=+OPER,CLEARFULTS,PAGE 20=+ONOFFCONFIG,VOUT 02=+intersil 0=all
###################################################################
class wrtProt_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x10)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Store User config All
###################################################################
class strUsrAll_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 1
        self.Cmd = pmbusCommand.cPMBusNoDataCmd(0x15)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## Restore User config All
###################################################################
class rstUsrAll_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 1
        self.Cmd = pmbusCommand.cPMBusNoDataCmd(0x16)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## pmBus Capability
###################################################################
class capability_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x19)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class capability_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.pec = (self.reg_value >> 7) & 0x1
            self.maxBS = (self.reg_value >> 5) & 0x3
            self.smbAlert = (self.reg_value >> 4) & 0x1
            self.numericFmt = (self.reg_value >> 3) & 0x1
            self.avsBusSupp = (self.reg_value >> 2) & 0x1

    def read_object(self):
        return(self.capability_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.pec & 0x1) << 7)
        reg = (reg & 0x9F) + ((register_object.maxBS & 0x3) << 5)
        reg = (reg & 0xEF) + ((register_object.smbAlert & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.numericFmt & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.avsBusSupp & 0x1) << 2)
        self.Cmd.Write(self.address, reg)

    ## PEC 0=none 1=supported
    def pec(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## Max bus speed 0=100KHz 1=400KHz 2=1MHz,3=reserved
    def maxBS(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 5, value)
        return(value)
    ## SMB alert support: 0=none 1=alert pin present & protocol supported
    def smbAlert(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, value)
        return(value)
    ## Numeric Data: 0=LINEAR/DIRECT (used), 1=IEEE half-prec flt pnt (not supported)
    def numericFmt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, value)
        return(value)
    ## AVS Bus: 0=not supported, 1=supported
    def avsBusSupp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, value)
        return(value)

###################################################################
## SMBALERT_MASK command
###################################################################
class smbAlrtMask_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 1
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x1b)

    def __call__(self):
        self.Cmd.Write(self.address)




###################################################################
## VOUT related command units
###################################################################
class voutMode_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x20)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class voutMode_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.unit = (self.reg_value >> 5) & 0x7
            self.param = self.reg_value & 0x1F

    def read_object(self):
        return(self.voutMode_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.unit & 0x7) << 5)
        reg = (reg & 0xE0) + (register_object.param & 0x1F)
        self.Cmd.Write(self.address, reg)

    ## Select units for Vout-related commands:  0=linear, 1=VID, 2=direct (millivolts for us)
    def unit(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 5, value)
        return(value)
    ## Either VID scale identifier for UNIT=1, or exponent for UNIT=0
    def param(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 5, 0, value)
        return(value)

###################################################################
## Commanded nominal output voltage
###################################################################
class voutCmd_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x21)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## User calibration trim voltage, signed
###################################################################
class voutTrim_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x22)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Manufacturer calibration offset voltage, signed
###################################################################
class voutCalOff_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x23)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Maximum permitted commanded output voltage
###################################################################
class voutMax_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x24)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output voltage for 'margin high' operation
###################################################################
class voutMargHi_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x25)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output voltage for 'margin low' operation
###################################################################
class voutMargLo_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x26)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output voltage ramp rate for transitions
###################################################################
class slewRate_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x27)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output voltage load line droop resistance
###################################################################
class droop_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x28)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Minimum permitted commanded output voltage
###################################################################
class voutMin_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x2b)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## PWM Switching frequency
###################################################################
class freqSw_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x33)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## PMBus Power Mode (shared with AVS)
###################################################################
class powerMode_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 3
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x34)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Input voltage turn on threshold voltage
###################################################################
class vinOn_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x35)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Input voltage turn off threshold voltage
###################################################################
class vinOff_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x36)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output overvoltage fault limit
###################################################################
class oovLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x40)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output overvoltage fault response
###################################################################
class oovResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x41)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class oovResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.oovResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Output undervoltage fault limit
###################################################################
class ouvLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x44)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output undervoltage fault response
###################################################################
class ouvResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x45)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ouvResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.ouvResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Output overcurrent fault limit
###################################################################
class oocLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x46)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Output overcurrent fault response
###################################################################
class oocResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x47)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class oocResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.oocResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 11=shutdown, 00= ignore, 10 and 01 not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Output overcurrent warning limit
###################################################################
class oocWarnLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x4a)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Overtemperature fault limit
###################################################################
class otfLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x4f)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Overtemperature fault response
###################################################################
class otfResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x50)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otfResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.otfResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Overtemperature warning limit
###################################################################
class otwLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x51)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Undertemperature fault limit register
###################################################################
class utfLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x53)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Undertemperature fault response
###################################################################
class utfResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x54)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utfResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.utfResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Input overvoltage fault limit
###################################################################
class iovLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x55)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Vin overvoltage fault response
###################################################################
class iovResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x56)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iovResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.iovResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Input undervoltage warning limit
###################################################################
class iovWarnLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x57)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Input undervoltage warning limit
###################################################################
class iuvWarnLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x58)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Input undervoltage fault limit
###################################################################
class iuvLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x59)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Vin undervoltage fault response
###################################################################
class iuvResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x5a)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iuvResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.iuvResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01=not supp, 10=shutdown, 11=not supp
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## [Deprecated] Input overcurrent fault limit
###################################################################
class iocLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x5b)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] Input overcurrent fault response
###################################################################
class iocResp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x5c)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iocResp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.iocResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01 and 10=not supp, 11=shutdown
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## [Deprecated] Input overcurrent warning limit
###################################################################
class iocWarnLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x5d)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Turn on delay time
###################################################################
class tOnDelay_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x60)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Turn on rise time
###################################################################
class tOnRise_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x61)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Turn off delay time
###################################################################
class tOffDelay_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x64)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Turn off fall time
###################################################################
class tOffFall_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x65)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus status byte
###################################################################
class statusByte_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x78)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusByte_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.busy = (self.reg_value >> 7) & 0x1
            self.off = (self.reg_value >> 6) & 0x1
            self.oovf = (self.reg_value >> 5) & 0x1
            self.oocf = (self.reg_value >> 4) & 0x1
            self.iuvf = (self.reg_value >> 3) & 0x1
            self.temp = (self.reg_value >> 2) & 0x1
            self.cml = (self.reg_value >> 1) & 0x1
            self.nov = self.reg_value & 0x1

    def read_object(self):
        return(self.statusByte_Object(self.address))


    ## Device busy and unable to respond
    def busy(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Output off for any reasons
    def off(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Output over-voltage fault occurred
    def oovf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Output over-current fault occurred
    def oocf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Input under-voltage fault occurred
    def iuvf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## A temperature fault or warning has occurred
    def temp(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## A Communication, Memory, or Logic fault occurred
    def cml(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## A fault other than those above has occurred
    def nov(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus status word
###################################################################
class statusWord_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x79)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusWord_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.vout = (self.reg_value >> 15) & 0x1
            self.pout = (self.reg_value >> 14) & 0x1
            self.inputErr = (self.reg_value >> 13) & 0x1
            self.mfr = (self.reg_value >> 12) & 0x1
            self.pwrBad = (self.reg_value >> 11) & 0x1
            self.other = (self.reg_value >> 9) & 0x1
            self.unk = (self.reg_value >> 8) & 0x1
            self.busy = (self.reg_value >> 7) & 0x1
            self.off = (self.reg_value >> 6) & 0x1
            self.oovf = (self.reg_value >> 5) & 0x1
            self.oocf = (self.reg_value >> 4) & 0x1
            self.iuvf = (self.reg_value >> 3) & 0x1
            self.temp = (self.reg_value >> 2) & 0x1
            self.cml = (self.reg_value >> 1) & 0x1
            self.nov = self.reg_value & 0x1

    def read_object(self):
        return(self.statusWord_Object(self.address))


    ## Output voltage fault or warning
    def vout(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 15, None)
        return(value)
    ## Output current or power fault or warning
    def pout(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 14, None)
        return(value)
    ## Input voltage, current, or power fault or warning
    def inputErr(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 13, None)
        return(value)
    ## A bit in STATUSMFR is set
    def mfr(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 12, None)
        return(value)
    ## The PWRGOOD signal is negated, indicating power is not good
    def pwrBad(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 11, None)
        return(value)
    ## A bit in STATUSOTHER is set
    def other(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 9, None)
        return(value)
    ## A fault other than that described in bits 15-9 has occurred
    def unk(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 8, None)
        return(value)
    ## Device busy and unable to respond
    def busy(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Output off for any reasons
    def off(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Output over-voltage fault occurred
    def oovf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Output over-current fault occurred
    def oocf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Input under-voltage fault occurred
    def iuvf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## A temperature fault or warning has occurred
    def temp(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## A Communication, Memory, or Logic fault occurred
    def cml(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## A fault other than those above has occurred
    def nov(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus output voltage status for channel
###################################################################
class statusVout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x7a)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusVout_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.oovf = (self.reg_value >> 7) & 0x1
            self.oovw = (self.reg_value >> 6) & 0x1
            self.ouvw = (self.reg_value >> 5) & 0x1
            self.ouvf = (self.reg_value >> 4) & 0x1
            self.voutMax = (self.reg_value >> 3) & 0x1
            self.tOnMax = (self.reg_value >> 2) & 0x1
            self.tOffMaxW = (self.reg_value >> 1) & 0x1
            self.voutTrk = self.reg_value & 0x1

    def read_object(self):
        return(self.statusVout_Object(self.address))


    ## Vout over-voltage fault
    def oovf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Vout over-voltage warning
    def oovw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Vout under-voltage warning
    def ouvw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Vout under-voltage fault
    def ouvf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Vout max warning
    def voutMax(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## TON max fault (not supp)
    def tOnMax(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## TOFF max warning (not supp)
    def tOffMaxW(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## Vout tracking error (not supp)
    def voutTrk(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus output current status for channel
###################################################################
class statusIout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x7b)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusIout_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.oocf = (self.reg_value >> 7) & 0x1
            self.ooclvf = (self.reg_value >> 6) & 0x1
            self.oocw = (self.reg_value >> 5) & 0x1
            self.oucf = (self.reg_value >> 4) & 0x1
            self.csf = (self.reg_value >> 3) & 0x1
            self.plMode = (self.reg_value >> 2) & 0x1
            self.oopf = (self.reg_value >> 1) & 0x1
            self.oopw = self.reg_value & 0x1

    def read_object(self):
        return(self.statusIout_Object(self.address))


    ## Iout over-current fault
    def oocf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Iout over-current and vout under-voltage fault (not supp)
    def ooclvf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Iout over-current warning
    def oocw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Iout under-current fault (not supp)
    def oucf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Current share fault
    def csf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## Power limit mode (not supp)
    def plMode(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## Pout over-power fault (not supp)
    def oopf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## Pout over-power warning (not supp)
    def oopw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus input voltage and current status
###################################################################
class statusInput_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x7c)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusInput_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.iovf = (self.reg_value >> 7) & 0x1
            self.iovw = (self.reg_value >> 6) & 0x1
            self.iuvw = (self.reg_value >> 5) & 0x1
            self.iuvf = (self.reg_value >> 4) & 0x1
            self.uoiiv = (self.reg_value >> 3) & 0x1
            self.iocf = (self.reg_value >> 2) & 0x1
            self.iocw = (self.reg_value >> 1) & 0x1
            self.iopw = self.reg_value & 0x1

    def read_object(self):
        return(self.statusInput_Object(self.address))


    ## Input over-voltage fault
    def iovf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Input over-voltage warning
    def iovw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Input under-voltage warning
    def iuvw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Input under-voltage fault
    def iuvf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Unit off for insufficient input voltage
    def uoiiv(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## Input over-current fault
    def iocf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## Input over-current warning
    def iocw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## Input over-power warning (not supp)
    def iopw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus temperature status
###################################################################
class statusTemp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x7d)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusTemp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.otf = (self.reg_value >> 7) & 0x1
            self.otw = (self.reg_value >> 6) & 0x1
            self.utw = (self.reg_value >> 5) & 0x1
            self.utf = (self.reg_value >> 4) & 0x1

    def read_object(self):
        return(self.statusTemp_Object(self.address))


    ## Over-temperature fault
    def otf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Over-temperature warning
    def otw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Under-temperature warning
    def utw(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Under-temperature fault
    def utf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)

###################################################################
## pmBus Comm, memory, logic status
###################################################################
class statusCml_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x7e)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusCml_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.iucf = (self.reg_value >> 7) & 0x1
            self.iudf = (self.reg_value >> 6) & 0x1
            self.pecf = (self.reg_value >> 5) & 0x1
            self.mfd = (self.reg_value >> 4) & 0x1
            self.pfd = (self.reg_value >> 3) & 0x1
            self.ocf = (self.reg_value >> 1) & 0x1
            self.omlf = self.reg_value & 0x1

    def read_object(self):
        return(self.statusCml_Object(self.address))


    ## Invalid or unsupported command received
    def iucf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Invalid or unsupported data recieved
    def iudf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## Packet error check failed
    def pecf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Memory fault detected
    def mfd(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## Processor fault detected
    def pfd(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## Other communication fault detected
    def ocf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## Other memory or logical fault detected
    def omlf(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus manufacturers status
###################################################################
class statusMfr_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x80)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusMfr_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.adcUnlock = (self.reg_value >> 7) & 0x1
            self.psysIinsen = (self.reg_value >> 6) & 0x1
            self.cfpFlt = (self.reg_value >> 5) & 0x1
            self.intTemp = (self.reg_value >> 4) & 0x1
            self.bbEvent = (self.reg_value >> 3) & 0x1
            self.lmsEvent = (self.reg_value >> 2) & 0x1
            self.spsFault = (self.reg_value >> 1) & 0x1
            self.svidError = self.reg_value & 0x1

    def read_object(self):
        return(self.statusMfr_Object(self.address))


    ## an ADC unlock event has been detected
    def adcUnlock(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, None)
        return(value)
    ## Psys Event/Iin Sense Warning
    def psysIinsen(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, None)
        return(value)
    ## CFP Fault
    def cfpFlt(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, None)
        return(value)
    ## Internal temperature fault
    def intTemp(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, None)
        return(value)
    ## A back box event occurred
    def bbEvent(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, None)
        return(value)
    ## LMS Event
    def lmsEvent(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, None)
        return(value)
    ## SPS Fault
    def spsFault(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, None)
        return(value)
    ## Error on SVID or SVI2 interface
    def svidError(self):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, None)
        return(value)

###################################################################
## pmBus input voltage telemetry for channel
###################################################################
class rdVin_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x88)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] pmBus input current telemetry for channel
###################################################################
class rdIin_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x89)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus output voltage telemetry for channel
###################################################################
class rdVout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8b)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus output current telemetry for channel
###################################################################
class rdIout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8c)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus driver temperature telemetry for channel
###################################################################
class rdDrTemp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8d)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus internal controller temperature telemetry
###################################################################
class rdCtlTemp_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8e)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] pmBus ambient temperature telemetry page 0-2
###################################################################
class rdAmbTemp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x8f)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus output power telemetry for channel
###################################################################
class rdPout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x96)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Deprecated] pmBus input power telemetry for channel
###################################################################
class rdPin_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0x97)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus supported standard revision number
###################################################################
class pmbRev_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0x98)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pmbRev_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.major = (self.reg_value >> 4) & 0xF
            self.minor = self.reg_value & 0xF

    def read_object(self):
        return(self.pmbRev_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.major & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.minor & 0xF)
        self.Cmd.Write(self.address, reg)

    ## pmBus bus standard major revision number
    def major(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 4, value)
        return(value)
    ## pmBus bus standard minor revision number
    def minor(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 0, value)
        return(value)

###################################################################
## pmBus Final product manufacturer's ID
###################################################################
class mfrID_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0x99, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Final product manufacturer's model
###################################################################
class mfrMod_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0x9a, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Final product manufacturer's revision
###################################################################
class mfrRev_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0x9b, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Final product manufacturer's date
###################################################################
class mfrDate_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0x9d, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Application profile support
###################################################################
class appProfile_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0x9f)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Controller manufacturer's IC device ID
###################################################################
class icDevId_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0xad, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Controller manufacturer's IC device revision
###################################################################
class icDevRev_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusBlockCmd(0xae, 5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class icDevRev_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.zero = (self.reg_value >> 28) & 0xF
            self.icDeviceRevRo = (self.reg_value >> 24) & 0xF
            self.icDeviceRev = self.reg_value & 0xFFFFFF

    def read_object(self):
        return(self.icDevRev_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.zero & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.icDeviceRevRo & 0xF) << 24)
        reg = (reg & 0xFF000000) + (register_object.icDeviceRev & 0xFFFFFF)
        self.Cmd.Write(self.address, reg)

    ## Zero
    def zero(self):
        value = pmbus_bits(self.Cmd, self.address, 4, 28, None)
        return(value)
    ## Major IC Revision ID
    def icDeviceRevRo(self):
        value = pmbus_bits(self.Cmd, self.address, 4, 24, None)
        return(value)
    ## Should match FwRevision [24:16] = Major revision, [15:8] = Increment, [7:0] = Build
    def icDeviceRev(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 24, 0, value)
        return(value)

###################################################################
## Dell user data
###################################################################
class userData0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xb0)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell user data
###################################################################
class userData1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xb1)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## DMA fixed address (single word) read/write data register
###################################################################
class dmaFix_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xc5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## DMA sequential (auto-increment) read/write data register
###################################################################
class dmaSeq_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xc6)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## DMA address in internal memory map
###################################################################
class dmaAddr_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xc7)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Iin Sense 0 voltage telemetry
###################################################################
class rdIinSen0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xc8)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] pmBus Iin Sense 1 voltage telemetry
###################################################################
class rdIinSen1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xc9)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] Summed input overcurrent fault response 1
###################################################################
class siocResp1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xca)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class siocResp1_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.siocResp1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01 and 10 not supp, 11=shutdown
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## [Deprecated] Summed input overcurrent fault limit 1
###################################################################
class siocLimit1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xcb)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Primary AMD bootup voltage ramp rate
###################################################################
class bootRate_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xcc)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Peak phase over current limit
###################################################################
class peakOcLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xcd)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Peak phase under current limit
###################################################################
class peakUcLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xce)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Voltage on VddMon to activate regulator (rising)
###################################################################
class vddMonOn_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd0)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Voltage on VddMon to deactivate regulator (falling)
###################################################################
class vddMonOff_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd1)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus Vin Sense 0 voltage telemetry
###################################################################
class rdVinSen0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd2)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] pmBus Vin Sense 1 voltage telemetry
###################################################################
class rdVinSen1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd3)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus output voltage telemetry for channel
###################################################################
class rdVoutTele_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd4)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell output voltage adjust
###################################################################
class voutAdj_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Password
###################################################################
class password_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xd6)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] Summed input overcurrent fault response 0
###################################################################
class siocResp0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xd7)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class siocResp0_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fltResp = (self.reg_value >> 6) & 0x3
            self.retryCnt = (self.reg_value >> 3) & 0x7
            self.retryDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.siocResp0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.fltResp & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.retryCnt & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.retryDelay & 0x7)
        self.Cmd.Write(self.address, reg)

    ## On fault detection: 00b=ignore, 01 and 10 not supp, 11=shutdown
    def fltResp(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 6, value)
        return(value)
    ## If shutdown, 000b=no retry, 111b=inf retry, 001-110b not supp
    def retryCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 3, value)
        return(value)
    ## If retry, delay time in 25ms steps
    def retryDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Dell droop adjust
###################################################################
class droopAdj_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xd8)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] Summed input overcurrent fault limit 0
###################################################################
class siocLimit0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xd9)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell IOUT Event
###################################################################
class ioutEvent_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xda)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ioutEvent_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.ioutAvgWinSize = (self.reg_value >> 12) & 0x7
            self.ioutAlertMask = (self.reg_value >> 11) & 0x1
            self.imaxEventEn = (self.reg_value >> 10) & 0x1
            self.ioutAlertThresh = self.reg_value & 0x3FF

    def read_object(self):
        return(self.ioutEvent_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x8FFF) + ((register_object.ioutAvgWinSize & 0x7) << 12)
        reg = (reg & 0xF7FF) + ((register_object.ioutAlertMask & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.imaxEventEn & 0x1) << 10)
        reg = (reg & 0xFC00) + (register_object.ioutAlertThresh & 0x3FF)
        self.Cmd.Write(self.address, reg)

    ## Dell IOUT Event averaging window size, in switch cycles
    def ioutAvgWinSize(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 12, value)
        return(value)
    ## Dell IOUT Event alert mask, 1=enable GPIO, 0=disable GPIO
    def ioutAlertMask(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 11, value)
        return(value)
    ## Dell IOUT Event enable event detection function, 1=enable, 0=disable
    def imaxEventEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 10, value)
        return(value)
    ## Dell IOUT Event alert threshold in amps
    def ioutAlertThresh(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 10, 0, value)
        return(value)

###################################################################
## [Deprecated] pmBus summed IIN0 current telemetry, amps
###################################################################
class rdSumIin0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xdb)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## [Deprecated] pmBus summed IIN1 current telemetry, amps
###################################################################
class rdSumIin1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xdc)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Proportional gain
###################################################################
class compProp_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xdd)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class compProp_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.val5ph = (self.reg_value >> 28) & 0xF
            self.shift5ph = (self.reg_value >> 25) & 0x7
            self.val2ph = (self.reg_value >> 21) & 0xF
            self.shift2ph = (self.reg_value >> 17) & 0x7
            self.val1ph = (self.reg_value >> 13) & 0xF
            self.shift1ph = (self.reg_value >> 9) & 0x7
            self.firLen = (self.reg_value >> 8) & 0x1
            self.val = (self.reg_value >> 4) & 0xF
            self.shift = self.reg_value & 0x7

    def read_object(self):
        return(self.compProp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.val5ph & 0xF) << 28)
        reg = (reg & 0xF1FFFFFF) + ((register_object.shift5ph & 0x7) << 25)
        reg = (reg & 0xFE1FFFFF) + ((register_object.val2ph & 0xF) << 21)
        reg = (reg & 0xFFF1FFFF) + ((register_object.shift2ph & 0x7) << 17)
        reg = (reg & 0xFFFE1FFF) + ((register_object.val1ph & 0xF) << 13)
        reg = (reg & 0xFFFFF1FF) + ((register_object.shift1ph & 0x7) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.firLen & 0x1) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.val & 0xF) << 4)
        reg = (reg & 0xFFFFFFF8) + (register_object.shift & 0x7)
        self.Cmd.Write(self.address, reg)

    ## Proportional gain mantissa 5-8 phase override, use normal P gain if val=0 and shift=0
    def val5ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 28, value)
        return(value)
    ## Proportional gain exponent 5-8 phase override, use normal P gain if val=0 and shift=0
    def shift5ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 25, value)
        return(value)
    ## 24:21Proportional gain mantissa 2-phase override, use normal P gain if val=0 and shift=0
    def val2ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 21, value)
        return(value)
    ## 19:17Proportional gain exponent 2-phase override, use normal P gain if val=0 and shift=0
    def shift2ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 17, value)
        return(value)
    ## 16:13-Proportional gain mantissa 1-phase override, use normal P gain if val=0 and shift=0
    def val1ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 13, value)
        return(value)
    ## 11:9-Proportional gain exponent 1-phase override, use normal P gain if val=0 and shift=0
    def shift1ph(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 9, value)
        return(value)
    ## 8-FIR filter length, 0=none or 1=ON Must be set if using D term for PID, optional if not using D term
    def firLen(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 8, value)
        return(value)
    ## 7:4-Proportional gain mantissa is (val/8), all phase counts, if val=0 gain is 0
    def val(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 4, value)
        return(value)
    ## 2:0-Proportional gain exponent is 2^(shift-3), all phase counts, if val=0 and shift=0 gain is 0
    def shift(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## Integrator gain times V*Ts after limiter
###################################################################
class compInteg_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xde)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class compInteg_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.stepTimeDcm = (self.reg_value >> 12) & 0xF
            self.shiftDcm = (self.reg_value >> 8) & 0xF
            self.shiftMax = (self.reg_value >> 4) & 0xF
            self.shift = self.reg_value & 0xF

    def read_object(self):
        return(self.compInteg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF0FFF) + ((register_object.stepTimeDcm & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.shiftDcm & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.shiftMax & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.shift & 0xF)
        self.Cmd.Write(self.address, reg)

    ## Delay time for stepping down gain towards shiftDcm when in DCM, in 16*clkTs per gain step
    def stepTimeDcm(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 12, value)
        return(value)
    ## Gain when in DCM for a while
    def shiftDcm(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 8, value)
        return(value)
    ## Max gain used when Integ movement detected Gain is 2^(-shift-1)
    def shiftMax(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 4, value)
        return(value)
    ## Gain is 2^(-shift-1)
    def shift(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 0, value)
        return(value)

###################################################################
## DEPRECATED -- Differentiator
###################################################################
class compDiff_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xdf)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## 
###################################################################
class compCFB_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe0)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class compCFB_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.filt = (self.reg_value >> 8) & 0xFF
            self.gain = self.reg_value & 0xFF

    def read_object(self):
        return(self.compCFB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.filt & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.gain & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## High-pass filter coef for current feedback
    def filt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 8, value)
        return(value)
    ## Current feedback gain, low droop cases
    def gain(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## Set PWRGD when no phases assigned to channel and it is commanded on
###################################################################
class railDebug_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xe1)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)


    ## Set PWRGD when no phases assigned to channel and it is commanded on
    def railDebug(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## Set power state when LOCKSVID selects pmBus power state for channel 0
###################################################################
class pwrMode_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe2)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrMode_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.pinAlertEn = (self.reg_value >> 15) & 0x1
            self.pinEn = (self.reg_value >> 14) & 0x1
            self.newVr14 = (self.reg_value >> 13) & 0x1
            self.HC = (self.reg_value >> 12) & 0x1
            self.exitLat = (self.reg_value >> 11) & 0x1
            self.lastRead = (self.reg_value >> 10) & 0x1
            self.pmicStat = (self.reg_value >> 9) & 0x1
            self.wpEn = (self.reg_value >> 8) & 0x1
            self.enAlwaysFast = (self.reg_value >> 7) & 0x1
            self.enEarlyDecayAlert = (self.reg_value >> 6) & 0x1
            self.vidDacHi = (self.reg_value >> 5) & 0x1
            self.vidDecayRej = (self.reg_value >> 4) & 0x1
            self.earlyPgd = (self.reg_value >> 3) & 0x1
            self.pmbPwrSt = self.reg_value & 0x7

    def read_object(self):
        return(self.pwrMode_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.pinAlertEn & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.pinEn & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.newVr14 & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.HC & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.exitLat & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.lastRead & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.pmicStat & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.wpEn & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.enAlwaysFast & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.enEarlyDecayAlert & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.vidDacHi & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.vidDecayRej & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.earlyPgd & 0x1) << 3)
        reg = (reg & 0xFFF8) + (register_object.pmbPwrSt & 0x7)
        self.Cmd.Write(self.address, reg)

    ## Enable PinAlertThresh register 0x2F
    def pinAlertEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 15, value)
        return(value)
    ## Enable PinMax register 0x2E
    def pinEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 14, value)
        return(value)
    ## Enable new VR14 features if 1
    def newVr14(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 13, value)
        return(value)
    ## Enable VR13.HC features if 1
    def HC(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 12, value)
        return(value)
    ## Enable PS3 and PS4 exit latency if 1
    def exitLat(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 11, value)
        return(value)
    ## Enable Last Read register if 1
    def lastRead(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 10, value)
        return(value)
    ## Enable PMIC Status register if 1
    def pmicStat(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 9, value)
        return(value)
    ## Enable work point registers if 1
    def wpEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 8, value)
        return(value)
    ## DVID up are always done at fast rate if 1 (Intel only)
    def enAlwaysFast(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## Use decays on all DVID down if 1 (Intel only)
    def enEarlyDecayAlert(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## Enable Status1 VID DAC High bit
    def vidDacHi(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, value)
        return(value)
    ## Reject SetVidDecay if greater than tracking VID
    def vidDecayRej(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, value)
        return(value)
    ## Causes PWRGD to assert true when loop goes to run state if 1
    def earlyPgd(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, value)
        return(value)
    ## Power state setting 0-4 for AMD and SVID rails when LOCKSVID is 2 or 3
    def pmbPwrSt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 0, value)
        return(value)

###################################################################
## HS Bus Current Scaling, just checking..
###################################################################
class hsBusCurScale_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe3)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus phase current telemetry
###################################################################
class phCurr_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe4)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus phase temperature telemetry
###################################################################
class phTemp_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe5)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## MFR Commands
###################################################################
class mcuCmd0_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe6)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuCmd0_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.data = (self.reg_value >> 8) & 0xFF
            self.cmd = self.reg_value & 0xFF

    def read_object(self):
        return(self.mcuCmd0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.data & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.cmd & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## Command Data
    def data(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 8, value)
        return(value)
    ## 01: Break <br> 02: Sleep <br> 03: Wake <br> 04: Disable Interrupt <br> 05: Enable Interrupt <br> 06: Run Vector <br> 07: Restart <br> 08: Rom CRC Check <br> 09: OTP Emptry Check <br> 0A: Reserved <br> 0B: Reserved <br> 0C: Reserved <br> 0D: RAM BIST <br> 0E: Write Factory Config <br> 0F: Write Patch <br> 10: Reload Patch <br> 11: Reserved <br> 12: Restore Factory Config <br> 13: Restore Function Pointers <br> 14: Store pinstrap table
    def cmd(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## User Reconfig Commands
###################################################################
class mcuCmd1_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe7)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Peak per-phase OC/UC count
###################################################################
class peakOcUcCount_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xe9)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class peakOcUcCount_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.ucCount = (self.reg_value >> 8) & 0xFF
            self.ocCount = self.reg_value & 0xFF

    def read_object(self):
        return(self.peakOcUcCount_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.ucCount & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.ocCount & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## Number of consecutive switch cycles with UC before fault (0 means disable fault)
    def ucCount(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 8, value)
        return(value)
    ## Number of consecutive switch cycles with OC before fault (0 means disable fault)
    def ocCount(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## Slow OC limit
###################################################################
class slowOcLimit_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xea)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Fast OC filters and count
###################################################################
class fastOcFiltCount_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xeb)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class fastOcFiltCount_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.fastFilt = (self.reg_value >> 8) & 0xF
            self.fastDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.fastOcFiltCount_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF0FF) + ((register_object.fastFilt & 0xF) << 8)
        reg = (reg & 0xFF00) + (register_object.fastDelay & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## Filter setting for fast response: 0 bypass, 1 fastest (340ns), 15 slowest (5.46ms)
    def fastFilt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 8, value)
        return(value)
    ## Delay clkTs*8 count before generating fault (0=no delay)
    def fastDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## Slow OC filters and count
###################################################################
class slowOcFiltCount_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xec)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class slowOcFiltCount_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.slowFilt = (self.reg_value >> 8) & 0xF
            self.slowDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.slowOcFiltCount_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF0FF) + ((register_object.slowFilt & 0xF) << 8)
        reg = (reg & 0xFF00) + (register_object.slowDelay & 0xFF)
        self.Cmd.Write(self.address, reg)

    ## Filter setting for slow response: 0 bypass, 1 fastest (340ns), 15 slowest (5.46ms)
    def slowFilt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 8, value)
        return(value)
    ## Delay clkTs*2048 count before generating fault (0=no delay)
    def slowDelay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 8, 0, value)
        return(value)

###################################################################
## LMS Configuration
###################################################################
class lmsCfg_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xed)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmsCfg_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.cmlOnClkLowTO = (self.reg_value >> 7) & 0x1
            self.cmlOnClkHighTO = (self.reg_value >> 6) & 0x1
            self.clkHighToutCtrl = (self.reg_value >> 4) & 0x3
            self.clrPhFltOnEn2 = (self.reg_value >> 3) & 0x1
            self.clrPhFltOnEn1 = (self.reg_value >> 2) & 0x1
            self.clrPhFltOnEn0 = (self.reg_value >> 1) & 0x1
            self.lmsEn = self.reg_value & 0x1

    def read_object(self):
        return(self.lmsCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF7F) + ((register_object.cmlOnClkLowTO & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.cmlOnClkHighTO & 0x1) << 6)
        reg = (reg & 0xFFCF) + ((register_object.clkHighToutCtrl & 0x3) << 4)
        reg = (reg & 0xFFF7) + ((register_object.clrPhFltOnEn2 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.clrPhFltOnEn1 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.clrPhFltOnEn0 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.lmsEn & 0x1)
        self.Cmd.Write(self.address, reg)

    ## Assert STATUS_CML[7] on PMBus clock low timeout
    def cmlOnClkLowTO(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## Assert STATUS_CML[7] on PMBus clock high timeout
    def cmlOnClkHighTO(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## PMbus clock high timeout control: 0 - disable, 1 - 50us, 2 - 100us, 3 - 200us
    def clkHighToutCtrl(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 4, value)
        return(value)
    ## Clear shutdown phases on enable toggle for channel 2
    def clrPhFltOnEn2(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, value)
        return(value)
    ## Clear shutdown phases on enable toggle for channel 1
    def clrPhFltOnEn1(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 2, value)
        return(value)
    ## Clear shutdown phases on enable toggle for channel 0
    def clrPhFltOnEn0(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, value)
        return(value)
    ## Enable phase faulting without channel faulting
    def lmsEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID interface addressing register and SVID interface options
###################################################################
class svidAddr_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xee)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidAddr_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.vccinAuxEn = (self.reg_value >> 15) & 0x1
            self.iccLimitEn = (self.reg_value >> 14) & 0x1
            self.slowSlewDef = (self.reg_value >> 13) & 0x1
            self.trkVidEn = (self.reg_value >> 12) & 0x1
            self.imonEn = (self.reg_value >> 11) & 0x1
            self.digOutStatEn = (self.reg_value >> 10) & 0x1
            self.ividEn = (self.reg_value >> 9) & 0x1
            self.expAccEn = (self.reg_value >> 8) & 0x1
            self.customVid = (self.reg_value >> 7) & 0x1
            self.vidRange = (self.reg_value >> 6) & 0x1
            self.useBootRate = (self.reg_value >> 5) & 0x1
            self.altVidOffset = (self.reg_value >> 4) & 0x1
            self.svidAddr = self.reg_value & 0xF

    def read_object(self):
        return(self.svidAddr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.vccinAuxEn & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.iccLimitEn & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.slowSlewDef & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.trkVidEn & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.imonEn & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.digOutStatEn & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.ividEn & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.expAccEn & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.customVid & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.vidRange & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.useBootRate & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.altVidOffset & 0x1) << 4)
        reg = (reg & 0xFFF0) + (register_object.svidAddr & 0xF)
        self.Cmd.Write(self.address, reg)

    ## Enable the VCCINAUX function
    def vccinAuxEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 15, value)
        return(value)
    ## Enable the cycle-to-cycle current limit and SVID register 0x1f and 0x5C
    def iccLimitEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 14, value)
        return(value)
    ## Slow Slew Select default: 0 - Default 2, 1 - Default 1
    def slowSlewDef(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 13, value)
        return(value)
    ## Enable Tracking VID register at 0x37
    def trkVidEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 12, value)
        return(value)
    ## Enable IMON calibration function
    def imonEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 11, value)
        return(value)
    ## Enable Digital Out Status if 1
    def digOutStatEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 10, value)
        return(value)
    ## Enable IVID registers if 1
    def ividEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 9, value)
        return(value)
    ## Expanded Accuracy Enable if 1
    def expAccEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 8, value)
        return(value)
    ## Use custom VID table if 1
    def customVid(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## VID table channel 0:  0=5mv 1=10mv (Must change SVID protocolID to match)
    def vidRange(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## Use BOOTRATE for Intel boot
    def useBootRate(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, value)
        return(value)
    ## SVID alternate offset: 0=245/490mV, 1=95/190mV
    def altVidOffset(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 4, value)
        return(value)
    ## SVID Address for channel -- 0-D, E-F use hardware default
    def svidAddr(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 4, 0, value)
        return(value)

###################################################################
## SVID boot voltage VID code register alias in PMBus space, stored/cfg in SVID space
###################################################################
class pmbSvidVboot_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xef)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Regulation loop configuration
###################################################################
class loopCfg_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xf0)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopCfg_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.imvp9p1En = (self.reg_value >> 31) & 0x1
            self.spsPs4Entry = (self.reg_value >> 30) & 0x1
            self.spsPs4Exit = (self.reg_value >> 29) & 0x1
            self.demPs01En = (self.reg_value >> 28) & 0x1
            self.alwaysDecay = (self.reg_value >> 27) & 0x1
            self.ocpSlowOr = (self.reg_value >> 25) & 0x1
            self.ocpFastOr = (self.reg_value >> 24) & 0x1
            self.inOffDecay = (self.reg_value >> 23) & 0x1
            self.ps1pc = (self.reg_value >> 22) & 0x1
            self.fastAddEn = (self.reg_value >> 21) & 0x1
            self.vinSel = (self.reg_value >> 18) & 0x7
            self.vddMonSel = (self.reg_value >> 16) & 0x3
            self.ps4OnVidZero = (self.reg_value >> 15) & 0x1
            self.usePmbLim = (self.reg_value >> 14) & 0x1
            self.lppa = (self.reg_value >> 13) & 0x1
            self.minPhCnt = (self.reg_value >> 8) & 0x1F
            self.svidDisable = (self.reg_value >> 7) & 0x1
            self.demEn = (self.reg_value >> 6) & 0x1
            self.lockSvid = (self.reg_value >> 4) & 0x3
            self.decay = (self.reg_value >> 2) & 0x3
            self.vidOnOff = (self.reg_value >> 1) & 0x1
            self.apdEn = self.reg_value & 0x1

    def read_object(self):
        return(self.loopCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.imvp9p1En & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.spsPs4Entry & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.spsPs4Exit & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.demPs01En & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.alwaysDecay & 0x1) << 27)
        reg = (reg & 0xFDFFFFFF) + ((register_object.ocpSlowOr & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.ocpFastOr & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.inOffDecay & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.ps1pc & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.fastAddEn & 0x1) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.vinSel & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.vddMonSel & 0x3) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.ps4OnVidZero & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.usePmbLim & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.lppa & 0x1) << 13)
        reg = (reg & 0xFFFFE0FF) + ((register_object.minPhCnt & 0x1F) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.svidDisable & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.demEn & 0x1) << 6)
        reg = (reg & 0xFFFFFFCF) + ((register_object.lockSvid & 0x3) << 4)
        reg = (reg & 0xFFFFFFF3) + ((register_object.decay & 0x3) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vidOnOff & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.apdEn & 0x1)
        self.Cmd.Write(self.address, reg)

    ## Enable IMVP9p1 protocol features if 1
    def imvp9p1En(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 31, value)
        return(value)
    ## Use SPS PS4 Entry wake-up pulses on disable or PS4 shutdown
    def spsPs4Entry(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 30, value)
        return(value)
    ## Use SPS PS4 Exit wake-up pulses
    def spsPs4Exit(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 29, value)
        return(value)
    ## Diode emulation mode enable for PS 0 and 1 if 1.
    def demPs01En(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 28, value)
        return(value)
    ## Always use decay during down ramps
    def alwaysDecay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 27, value)
        return(value)
    ## Use slowSumOcDetect OR with VRHOT
    def ocpSlowOr(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 25, value)
        return(value)
    ## Use fastSumOcDetect OR with VRHOT
    def ocpFastOr(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 24, value)
        return(value)
    ## Input Turn Off Decay if 1
    def inOffDecay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 23, value)
        return(value)
    ## In power state PS1 use: 0=1phase 1=upto 2 phases
    def ps1pc(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 22, value)
        return(value)
    ## Add all phases on output voltage change if 1
    def fastAddEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 21, value)
        return(value)
    ## (CHAN 0 SETS ALL) Loop Vin data source:  0=VINSEN0, 1=IINSEN0, 2=TEMP0, 3=TEMP1, 4=TEMP2, 5=CONFIG, 6,7=use vsysSrc
    def vinSel(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 3, 18, value)
        return(value)
    ## Loop VddMon data source:  3=TEMP1, 2=IINSEN0 1=VINSEN0, 0=none -- ignore check
    def vddMonSel(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 16, value)
        return(value)
    ## During VID=0 shutdowns enter PS4 with exit latency
    def ps4OnVidZero(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 15, value)
        return(value)
    ## Use pmBus OOV/OUV limits if 1, or VID tracking if 0
    def usePmbLim(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 14, value)
        return(value)
    ## Allow adding of phases in low-power state
    def lppa(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 13, value)
        return(value)
    ## Minimum phase count
    def minPhCnt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 5, 8, value)
        return(value)
    ## Reject any SVID commands to this channel if 1
    def svidDisable(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## Diode emulation mode enable if 1.
    def demEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## pmBus overrides of SVID: 0=reject 1=offset 2=+ps 3=+voltage
    def lockSvid(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 4, value)
        return(value)
    ## Decay downramp: 0=none 1=PSI0 2=PSI0&1 3=none
    def decay(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 2, value)
        return(value)
    ## Shutdown loop when commanded to 0.0v if set to 1
    def vidOnOff(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, value)
        return(value)
    ## Enable auto phase add/drop if 1.
    def apdEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## Store register settings in OTP bank 0-7
###################################################################
class storeCfg_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xf1)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Load OTP bank 0-7 into active registers
###################################################################
class restoreCfg_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xf2)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## pmBus slave 7-bit address 0=0x60 nonzero=SLAVEADDR[7:1]
###################################################################
class slaveAddr_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xf3)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class slaveAddr_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.slaveAddr = (self.reg_value >> 1) & 0x7F
            self.smbus2 = self.reg_value & 0x1

    def read_object(self):
        return(self.slaveAddr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1) + ((register_object.slaveAddr & 0x7F) << 1)
        reg = (reg & 0xFE) + (register_object.smbus2 & 0x1)
        self.Cmd.Write(self.address, reg)

    ## pmBus slave 7-bit address 0=0x60 nonzero=SLAVEADDR[7:1]
    def slaveAddr(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 7, 1, value)
        return(value)
    ## Enable SMBus 2.0 Compatibility Mode - all PMBus commands greater than 2 bytes will be BLOCK transferred
    def smbus2(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## Basic configuration data
###################################################################
class baseCfg_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 23
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xf4)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class baseCfg_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.dmaAddrWr = (self.reg_value >> 22) & 0x1
            self.iInSenAmpPolarity = (self.reg_value >> 21) & 0x1
            self.smbusLevelSel = (self.reg_value >> 20) & 0x1
            self.vttSel = (self.reg_value >> 19) & 0x1
            self.vttEn = (self.reg_value >> 18) & 0x1
            self.enSel = (self.reg_value >> 16) & 0x3
            self.pgOff = (self.reg_value >> 15) & 0x1
            self.vttFltEn = (self.reg_value >> 10) & 0x1
            self.autoVout = (self.reg_value >> 9) & 0x1
            self.lockEn = (self.reg_value >> 8) & 0x1
            self.cfpRestart = (self.reg_value >> 7) & 0x1
            self.numEn = (self.reg_value >> 6) & 0x1
            self.hss1 = (self.reg_value >> 5) & 0x1
            self.disCmlAlt = (self.reg_value >> 3) & 0x1
            self.hss0 = (self.reg_value >> 1) & 0x1
            self.hss2 = self.reg_value & 0x1

    def read_object(self):
        return(self.baseCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.dmaAddrWr & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iInSenAmpPolarity & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.smbusLevelSel & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.vttSel & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.vttEn & 0x1) << 18)
        reg = (reg & 0x7CFFFF) + ((register_object.enSel & 0x3) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.pgOff & 0x1) << 15)
        reg = (reg & 0x7FFBFF) + ((register_object.vttFltEn & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.autoVout & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.lockEn & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.cfpRestart & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.numEn & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.hss1 & 0x1) << 5)
        reg = (reg & 0x7FFFF7) + ((register_object.disCmlAlt & 0x1) << 3)
        reg = (reg & 0x7FFFFD) + ((register_object.hss0 & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.hss2 & 0x1)
        self.Cmd.Write(self.address, reg)

    ## DMAADDR register write control: 1 - always writeable, 0 - WPL2 legacy
    def dmaAddrWr(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 22, value)
        return(value)
    ## 1=invert the polarity of the amplifier in anaIinSense
    def iInSenAmpPolarity(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 21, value)
        return(value)
    ## Select bus-voltage for PMBus pads: 0=1.2V, 1=3.3V(standard)
    def smbusLevelSel(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 20, value)
        return(value)
    ## Select VTT rail: 0=loop 0, 1=loop 2
    def vttSel(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 19, value)
        return(value)
    ## Enable VTT mode on loop 2
    def vttEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 18, value)
        return(value)
    ## Select enable for 0x0D slave: 00=EN0, 01=EN1, 10=EN2
    def enSel(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 2, 16, value)
        return(value)
    ## Power Good turn off control: 0 - turn off after TOFF_DELAY, 1 - Turn off when no on command
    def pgOff(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 15, value)
        return(value)
    ## VTT fault enable
    def vttFltEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 10, value)
        return(value)
    ## Telemetry automatic Vout switchover to Vsen data
    def autoVout(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 9, value)
        return(value)
    ## Write protect lock enable
    def lockEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 8, value)
        return(value)
    ## CFP restart control
    def cfpRestart(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 7, value)
        return(value)
    ## ENABLE pin usage:  0=seperate per rail 1=ENABLE1 controls both rails
    def numEn(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 6, value)
        return(value)
    ## High-speed select msb -- serial interface: 000=AMD, 001=SVID, 010=AVS, 011=none, 100=SVI3
    def hss1(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 5, value)
        return(value)
    ## Disable CML alert: 0=CML enabled 1=CML alerts not reported
    def disCmlAlt(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 3, value)
        return(value)
    ## High-speed select lsb -- serial interface: 000=AMD, 001=SVID, 010=AVS, 011=none, 100=SVI3
    def hss0(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 1, value)
        return(value)
    ## HSS bit 2, SVI3
    def hss2(self, value = None):
        value = pmbus_bits(self.Cmd, self.address, 1, 0, value)
        return(value)

###################################################################
## Vout peak
###################################################################
class voutPeak_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xf6)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Vout Low
###################################################################
class voutLow_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xf7)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Iout peak
###################################################################
class ioutPeak_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 16
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xf8)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell Iout Offset
###################################################################
class ioutOffset_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusIntCmd(0xf9)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell Input Power Offset
###################################################################
class inPwrOffset_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusByteCmd(0xfa)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Dell power stage vendor ID
###################################################################
class psvid_class(object):
    def __init__(self, address):
        self.interface = 'pmbGl'
        self.address = address
        self.bits = 8
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xfb)

    def __call__(self, value = None):
        if (value == None):
            value = self.Cmd.Read(self.address)
        else:
            self.Cmd.Write(self.address, value)

        return(value)



###################################################################
## Iout peak with Vout
###################################################################
class ioutPkVout_class(object):
    def __init__(self, address):
        self.interface = 'pmbCh'
        self.address = address
        self.bits = 32
        self.Cmd = pmbusCommand.cPMBusLongCmd(0xfc)

    def __call__(self):
        value = self.Cmd.Read(self.address)

        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ioutPkVout_Object:
        def __init__(self, address):
            self.reg_value = self.Cmd.Read(address)
            self.voutAtPeak = (self.reg_value >> 16) & 0xFFFF
            self.ioutPeak = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.ioutPkVout_Object(self.address))


    ## Vout At Peak
    def voutAtPeak(self):
        value = pmbus_bits(self.Cmd, self.address, 16, 16, None)
        return(value)
    ## Iout Peak
    def ioutPeak(self):
        value = pmbus_bits(self.Cmd, self.address, 16, 0, None)
        return(value)

###################################################################
## AVS Target Rail Voltage
###################################################################
class avsVout_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE300, value)
        return(value)


###################################################################
## AVS Target Rail Vout Transition
###################################################################
class avsVoutTrans_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE301, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class avsVoutTrans_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE301, None)
            self.rise = (self.reg_value >> 8) & 0xFF
            self.fall = self.reg_value & 0xFF

    def read_object(self):
        return(self.avsVoutTrans_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.rise & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.fall & 0xFF)
        dma(self.address, 0xE301, reg)
    def rise(self, value = None):
        value = dma_bits(0xE301, self.address, 8, 8, value)
        return(value)
    ## AVS voltage transition slew rate
    def fall(self, value = None):
        value = dma_bits(0xE301, self.address, 8, 0, value)
        return(value)

###################################################################
## AVS Rail current
###################################################################
class avsTelIoutMcu_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE302, value)
        return(value)


###################################################################
## AVS Rail Temperature
###################################################################
class avsTempDrMcu_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE303, value)
        return(value)


###################################################################
## AVS Reset Rail Voltage
###################################################################
class avsRstRailVolt_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE304, value)
        return(value)


###################################################################
## AVS Rail Power Mode
###################################################################
class avsPowerMode_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 3

    def __call__(self, value = None):
        value = dma(self.address, 0xE305, value)
        return(value)


###################################################################
## AVS Reserved6
###################################################################
class avs6hx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE306, value)
        return(value)


###################################################################
## AVS Reserved7
###################################################################
class avs7hx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE307, value)
        return(value)


###################################################################
## AVS Reserved8
###################################################################
class avs8hx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE308, value)
        return(value)


###################################################################
## AVS Reserved9
###################################################################
class avs9hx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE309, value)
        return(value)


###################################################################
## AVS Reserved10
###################################################################
class avsAhx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30A, value)
        return(value)


###################################################################
## AVS Reserved11
###################################################################
class avsBhx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30B, value)
        return(value)


###################################################################
## AVS Reserved12
###################################################################
class avsChx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30C, value)
        return(value)


###################################################################
## AVS Reserved13
###################################################################
class avsDhx_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30D, value)
        return(value)


###################################################################
## AVS status register
###################################################################
class avsBusStatus_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class avsBusStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE30E, None)
            self.vdone = (self.reg_value >> 15) & 0x1
            self.ocw = (self.reg_value >> 14) & 0x1
            self.uvw = (self.reg_value >> 13) & 0x1
            self.otw = (self.reg_value >> 12) & 0x1
            self.opw = (self.reg_value >> 11) & 0x1
            self.mfrSpcfcSettingAvs92 = self.reg_value & 0xFF

    def read_object(self):
        return(self.avsBusStatus_Object(self.address))

    ## Loop settled
    def vdone(self):
        value = dma_bits(0xE30E, self.address, 1, 15, None)
        return(value)
    ## Output overcurrent warning
    def ocw(self):
        value = dma_bits(0xE30E, self.address, 1, 14, None)
        return(value)
    ## Output undervolt warning
    def uvw(self):
        value = dma_bits(0xE30E, self.address, 1, 13, None)
        return(value)
    ## Driver overtemp warning
    def otw(self):
        value = dma_bits(0xE30E, self.address, 1, 12, None)
        return(value)
    ## Output overpower warning
    def opw(self):
        value = dma_bits(0xE30E, self.address, 1, 11, None)
        return(value)
    ## see mfrSpcfcSetting
    def mfrSpcfcSettingAvs92(self):
        value = dma_bits(0xE30E, self.address, 8, 0, None)
        return(value)

###################################################################
## AVS Bus Version
###################################################################
class avsBusVersion_class(object):
    def __init__(self, address):
        self.interface = 'avsCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE30F, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE380, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE381, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE382, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp3_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE383, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp4_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE384, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp5_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE385, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp6_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE386, value)
        return(value)


###################################################################
## 
###################################################################
class phTemp7_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE387, value)
        return(value)


###################################################################
## Vout Adjust buffer 0
###################################################################
class voutAdjBuf0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE398, value)
        return(value)


###################################################################
## Vout Adjust buffer 1
###################################################################
class voutAdjBuf1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE399, value)
        return(value)


###################################################################
## Vout Adjust buffer 2
###################################################################
class voutAdjBuf2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39A, value)
        return(value)


###################################################################
## Droop Adjust buffer 0
###################################################################
class droopAdjBuf0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39B, value)
        return(value)


###################################################################
## Droop Adjust buffer 1
###################################################################
class droopAdjBuf1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39C, value)
        return(value)


###################################################################
## Droop Adjust buffer 2
###################################################################
class droopAdjBuf2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39D, value)
        return(value)


###################################################################
## SVID register 5B buffer 0
###################################################################
class svidSlewTtBuf0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39E, value)
        return(value)


###################################################################
## SVID register 5B buffer 1
###################################################################
class svidSlewTtBuf1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE39F, value)
        return(value)


###################################################################
## SVID register 5B buffer 2
###################################################################
class svidSlewTtBuf2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A0, value)
        return(value)


###################################################################
## SVI3 NVM OCP Threshold 0
###################################################################
class nvmOcpThresh0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A1, value)
        return(value)


###################################################################
## SVI3 NVM OCP Threshold 1
###################################################################
class nvmOcpThresh1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A2, value)
        return(value)


###################################################################
## SVI3 NVM OCP Threshold 2
###################################################################
class nvmOcpThresh2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A3, value)
        return(value)


###################################################################
## SVI3 NVM OCP Warning Threshold 0
###################################################################
class nvmOcpWarnThresh0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A4, value)
        return(value)


###################################################################
## SVI3 NVM OCP Warning Threshold 1
###################################################################
class nvmOcpWarnThresh1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A5, value)
        return(value)


###################################################################
## SVI3 NVM OCP Warning Threshold 2
###################################################################
class nvmOcpWarnThresh2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A6, value)
        return(value)


###################################################################
## SVI3 NVM OCP Min Pulse and Fault Delay 0
###################################################################
class nvmOcpWnMnPlsFtDl0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A7, value)
        return(value)


###################################################################
## SVI3 NVM OCP Min Pulse and Fault Delay 1
###################################################################
class nvmOcpWnMnPlsFtDl1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A8, value)
        return(value)


###################################################################
## SVI3 NVM OCP Min Pulse and Fault Delay 2
###################################################################
class nvmOcpWnMnPlsFtDl2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3A9, value)
        return(value)


###################################################################
## SVID register 0F buffer 0
###################################################################
class svidReg0FBuf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AA, value)
        return(value)


###################################################################
## SVID VR Ready 0V buffer 0
###################################################################
class vrReady0vBuf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AB, value)
        return(value)


###################################################################
## SVID register 30 buffer 0
###################################################################
class svidReg30Buf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AC, value)
        return(value)


###################################################################
## SVID Ext Phase Shed Control buffer 0
###################################################################
class extPhShedCtrlBuf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AD, value)
        return(value)


###################################################################
## SVID Ext Neg Vr Enable Response buffer 0
###################################################################
class extNegVrEnRespBuf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AE, value)
        return(value)


###################################################################
## SVID register 0F buffer 1
###################################################################
class svidReg0FBuf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3AF, value)
        return(value)


###################################################################
## SVID VR Ready 0V buffer 1
###################################################################
class vrReady0vBuf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B0, value)
        return(value)


###################################################################
## SVID register 30 buffer 1
###################################################################
class svidReg30Buf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B1, value)
        return(value)


###################################################################
## SVID Ext Phase Shed Control buffer 1
###################################################################
class extPhShedCtrlBuf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B2, value)
        return(value)


###################################################################
## SVID Ext Neg Vr Enable Response buffer 1
###################################################################
class extNegVrEnRespBuf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B3, value)
        return(value)


###################################################################
## SVID register 0F buffer 2
###################################################################
class svidReg0FBuf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B4, value)
        return(value)


###################################################################
## SVID VR Ready 0V buffer 2
###################################################################
class vrReady0vBuf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B5, value)
        return(value)


###################################################################
## SVID register 30 buffer 2
###################################################################
class svidReg30Buf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B6, value)
        return(value)


###################################################################
## SVID Ext Phase Shed Control buffer 2
###################################################################
class extPhShedCtrlBuf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B7, value)
        return(value)


###################################################################
## SVID Ext Neg Vr Enable Response buffer 2
###################################################################
class extNegVrEnRespBuf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B8, value)
        return(value)


###################################################################
## SVID register 0F buffer 3
###################################################################
class svidReg0FBuf3_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3B9, value)
        return(value)


###################################################################
## SVID VR Ready 0V buffer 3
###################################################################
class vrReady0vBuf3_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3BA, value)
        return(value)


###################################################################
## SVID register 0x2a buffer 0
###################################################################
class svidReg2aBuf0_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE3BB, value)
        return(value)


###################################################################
## SVID register 0x2a buffer 1
###################################################################
class svidReg2aBuf1_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE3BC, value)
        return(value)


###################################################################
## SVID register 0x2a buffer 2
###################################################################
class svidReg2aBuf2_class(object):
    def __init__(self, address):
        self.interface = 'svidMisc'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE3BD, value)
        return(value)


###################################################################
## 
###################################################################
class watchCnt_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class watchCnt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C0, None)
            self.watchLoad = (self.reg_value >> 16) & 0xFFFF
            self.watchCount = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.watchCnt_Object(self.address))

    def watchLoad(self, value = None):
        value = dma_bits(0xE3C0, self.address, 16, 16, value)
        return(value)
    def watchCount(self):
        value = dma_bits(0xE3C0, self.address, 16, 0, None)
        return(value)

###################################################################
## 
###################################################################
class watchCtrl_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class watchCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C1, None)
            self.watchKey = (self.reg_value >> 4) & 0xFFF
            self.watchRst = (self.reg_value >> 1) & 0x1
            self.watchEn = self.reg_value & 0x1

    def read_object(self):
        return(self.watchCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.watchKey & 0xFFF) << 4)
        reg = (reg & 0xFFFD) + ((register_object.watchRst & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.watchEn & 0x1)
        dma(self.address, 0xE3C1, reg)
    def watchKey(self, value = None):
        value = dma_bits(0xE3C1, self.address, 12, 4, value)
        return(value)
    def watchRst(self, value = None):
        value = dma_bits(0xE3C1, self.address, 1, 1, value)
        return(value)
    def watchEn(self, value = None):
        value = dma_bits(0xE3C1, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class irqTest_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C2, value)
        return(value)


###################################################################
## 
###################################################################
class irqTestTrig_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C3, value)
        return(value)


###################################################################
## Last PMBus write command for IRQ-enabled commands (FIFO)
###################################################################
class pmbLastCmd_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pmbLastCmd_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C4, None)
            self.page = (self.reg_value >> 8) & 0xF
            self.cmd = self.reg_value & 0xFF

    def read_object(self):
        return(self.pmbLastCmd_Object(self.address))

    ## Last PMBus write command page mask 1=page0, 2=page1, 4=page3, F=pageFF, 0=FIFO empty
    def page(self):
        value = dma_bits(0xE3C4, self.address, 4, 8, None)
        return(value)
    ## Last PMBus write command
    def cmd(self):
        value = dma_bits(0xE3C4, self.address, 8, 0, None)
        return(value)

###################################################################
## GPIO interrupt acknowledge
###################################################################
class gpioAck_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C6, value)
        return(value)


###################################################################
## GPIO interrupt control
###################################################################
class gpioIntCtrl_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gpioIntCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C7, None)
            self.gpioIntLev = (self.reg_value >> 24) & 0xFF
            self.gpioIntReq = (self.reg_value >> 16) & 0xFF
            self.gpioIntPol = (self.reg_value >> 8) & 0xFF
            self.gpioIntEn = self.reg_value & 0xFF

    def read_object(self):
        return(self.gpioIntCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.gpioIntLev & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.gpioIntReq & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.gpioIntPol & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.gpioIntEn & 0xFF)
        dma(self.address, 0xE3C7, reg)
    def gpioIntLev(self, value = None):
        value = dma_bits(0xE3C7, self.address, 8, 24, value)
        return(value)
    def gpioIntReq(self):
        value = dma_bits(0xE3C7, self.address, 8, 16, None)
        return(value)
    def gpioIntPol(self, value = None):
        value = dma_bits(0xE3C7, self.address, 8, 8, value)
        return(value)
    def gpioIntEn(self, value = None):
        value = dma_bits(0xE3C7, self.address, 8, 0, value)
        return(value)

###################################################################
## GPIO pin control
###################################################################
class gpioCtrl_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gpioCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C8, None)
            self.gpioCtrl3 = (self.reg_value >> 24) & 0xFF
            self.gpioIn = (self.reg_value >> 16) & 0xFF
            self.gpioCtrl1 = (self.reg_value >> 8) & 0xFF
            self.gpioCtrl0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.gpioCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.gpioCtrl3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.gpioIn & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.gpioCtrl1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.gpioCtrl0 & 0xFF)
        dma(self.address, 0xE3C8, reg)
    ## Gpio input source
    def gpioCtrl3(self, value = None):
        value = dma_bits(0xE3C8, self.address, 8, 24, value)
        return(value)
    ## Gpio data ([7]cfp,[6]nvrhot,[5]npmalert,[4]pg2,[3]en2,[2]en1,[1]gpio1,[0]gpio0)
    def gpioIn(self):
        value = dma_bits(0xE3C8, self.address, 8, 16, None)
        return(value)
    ## Gpio direction, 1 output
    def gpioCtrl1(self, value = None):
        value = dma_bits(0xE3C8, self.address, 8, 8, value)
        return(value)
    ## Gpio enable
    def gpioCtrl0(self, value = None):
        value = dma_bits(0xE3C8, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class ringCtrl_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3C9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ringCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3C9, None)
            self.ringstart = (self.reg_value >> 7) & 0x1
            self.ringlength = (self.reg_value >> 4) & 0x7
            self.ringstopl = (self.reg_value >> 3) & 0x1
            self.ringtest = (self.reg_value >> 2) & 0x1
            self.ringloop = (self.reg_value >> 1) & 0x1
            self.ringen = self.reg_value & 0x1

    def read_object(self):
        return(self.ringCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ringstart & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.ringlength & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.ringstopl & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ringtest & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ringloop & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ringen & 0x1)
        dma(self.address, 0xE3C9, reg)
    ## Start the ring counter, clears upon completion
    def ringstart(self, value = None):
        value = dma_bits(0xE3C9, self.address, 1, 7, value)
        return(value)
    ## Length of ring 0=8, 1=14, 2=22, 3=30, 4=38, 5=46, 6=54, 7=64
    def ringlength(self, value = None):
        value = dma_bits(0xE3C9, self.address, 3, 4, value)
        return(value)
    ## 0=count 9 times, 1=count 256 times
    def ringstopl(self, value = None):
        value = dma_bits(0xE3C9, self.address, 1, 3, value)
        return(value)
    ## 0=Complete Ring, 1=Disconnect Ring
    def ringtest(self, value = None):
        value = dma_bits(0xE3C9, self.address, 1, 2, value)
        return(value)
    ## 0=Stop on Count done, 1=Run indefinitely
    def ringloop(self, value = None):
        value = dma_bits(0xE3C9, self.address, 1, 1, value)
        return(value)
    ## 0=Ring Disabled, 1=Ring Enabled
    def ringen(self, value = None):
        value = dma_bits(0xE3C9, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class tunnelCmd_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3CA, value)
        return(value)


###################################################################
## 
###################################################################
class tunnelData_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3CB, value)
        return(value)


###################################################################
## GPIO-B pin control
###################################################################
class gpioCtrlB_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3CC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gpioCtrlB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3CC, None)
            self.gpioCtrl3 = (self.reg_value >> 12) & 0xF
            self.gpioIn = (self.reg_value >> 8) & 0xF
            self.gpioCtrl1 = (self.reg_value >> 4) & 0xF
            self.gpioCtrl0 = self.reg_value & 0xF

    def read_object(self):
        return(self.gpioCtrlB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.gpioCtrl3 & 0xF) << 12)
        reg = (reg & 0xF0FF) + ((register_object.gpioIn & 0xF) << 8)
        reg = (reg & 0xFF0F) + ((register_object.gpioCtrl1 & 0xF) << 4)
        reg = (reg & 0xFFF0) + (register_object.gpioCtrl0 & 0xF)
        dma(self.address, 0xE3CC, reg)
    ## Gpio input source
    def gpioCtrl3(self, value = None):
        value = dma_bits(0xE3CC, self.address, 4, 12, value)
        return(value)
    ## Gpio data ([3]rsvd,[2]enable0,[1]pg1,[0]pg0)
    def gpioIn(self):
        value = dma_bits(0xE3CC, self.address, 4, 8, None)
        return(value)
    ## Gpio direction, 1 output
    def gpioCtrl1(self, value = None):
        value = dma_bits(0xE3CC, self.address, 4, 4, value)
        return(value)
    ## Gpio enable
    def gpioCtrl0(self, value = None):
        value = dma_bits(0xE3CC, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class svi3CrcEn_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3CE, value)
        return(value)


###################################################################
## 
###################################################################
class nvmSvi3CrcEn_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3CF, value)
        return(value)


###################################################################
## 
###################################################################
class statusTest0_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D0, value)
        return(value)


###################################################################
## 
###################################################################
class statusTest1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D1, value)
        return(value)


###################################################################
## 
###################################################################
class statusTest2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D2, value)
        return(value)


###################################################################
## 
###################################################################
class statusTestCom_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D3, value)
        return(value)


###################################################################
## Memory interrupt access address status
###################################################################
class AccessAddrStatus_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D4, value)
        return(value)


###################################################################
## Test select register
###################################################################
class tmSel_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tmSel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3D8, None)
            self.adcComp = (self.reg_value >> 10) & 0x1
            self.clkDiv = (self.reg_value >> 9) & 0x1
            self.vAdcDirect = (self.reg_value >> 8) & 0x1
            self.porBod = (self.reg_value >> 7) & 0x1
            self.clock = (self.reg_value >> 6) & 0x1
            self.otp = (self.reg_value >> 5) & 0x1
            self.scan = (self.reg_value >> 4) & 0x1
            self.xorTree = (self.reg_value >> 3) & 0x1
            self.dpb = (self.reg_value >> 2) & 0x1
            self.drvFlt = (self.reg_value >> 1) & 0x1
            self.drvLH = self.reg_value & 0x1

    def read_object(self):
        return(self.tmSel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.adcComp & 0x1) << 10)
        reg = (reg & 0x5FF) + ((register_object.clkDiv & 0x1) << 9)
        reg = (reg & 0x6FF) + ((register_object.vAdcDirect & 0x1) << 8)
        reg = (reg & 0x77F) + ((register_object.porBod & 0x1) << 7)
        reg = (reg & 0x7BF) + ((register_object.clock & 0x1) << 6)
        reg = (reg & 0x7DF) + ((register_object.otp & 0x1) << 5)
        reg = (reg & 0x7EF) + ((register_object.scan & 0x1) << 4)
        reg = (reg & 0x7F7) + ((register_object.xorTree & 0x1) << 3)
        reg = (reg & 0x7FB) + ((register_object.dpb & 0x1) << 2)
        reg = (reg & 0x7FD) + ((register_object.drvFlt & 0x1) << 1)
        reg = (reg & 0x7FE) + (register_object.drvLH & 0x1)
        dma(self.address, 0xE3D8, reg)
    ## Enable mode to route the adc comparator outputs to top level ports
    def adcComp(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 10, value)
        return(value)
    ## Enable mode to pass 2x clocks from clock divider to clkSys and clkTs
    def clkDiv(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 9, value)
        return(value)
    ## vSenAdc0 only TM
    def vAdcDirect(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 8, value)
        return(value)
    ## Power-On-Reset and Brown Out Detect test mode
    def porBod(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 7, value)
        return(value)
    ## Clock test mode
    def clock(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 6, value)
        return(value)
    ## Route OTP pins to ports
    def otp(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 5, value)
        return(value)
    ## ATE scan mode
    def scan(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 4, value)
        return(value)
    ## XOR input tree test mode
    def xorTree(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 3, value)
        return(value)
    ## Digital Parallel bus
    def dpb(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 2, value)
        return(value)
    ## Drive float test mode
    def drvFlt(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 1, value)
        return(value)
    ## Drive low/high test mode
    def drvLH(self, value = None):
        value = dma_bits(0xE3D8, self.address, 1, 0, value)
        return(value)

###################################################################
## Test configuration register 1
###################################################################
class tmCfg1_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3D9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tmCfg1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3D9, None)
            self.clkDivSel = (self.reg_value >> 15) & 0x1
            self.tmAdcDataSel = (self.reg_value >> 14) & 0x1
            self.fltStsTest = (self.reg_value >> 13) & 0x1
            self.svidRdVidSet = (self.reg_value >> 12) & 0x1
            self.pmbTestEn = (self.reg_value >> 11) & 0x1
            self.clkTestSel = (self.reg_value >> 9) & 0x3
            self.clkTest = (self.reg_value >> 8) & 0x1
            self.trigOut = (self.reg_value >> 7) & 0x1
            self.debug = (self.reg_value >> 6) & 0x1
            self.useDllClocks = (self.reg_value >> 5) & 0x1
            self.faultTest = (self.reg_value >> 4) & 0x1
            self.scanTm1 = (self.reg_value >> 3) & 0x1
            self.scanTm0 = (self.reg_value >> 2) & 0x1
            self.refHot = (self.reg_value >> 1) & 0x1
            self.unUsed1 = self.reg_value & 0x1

    def read_object(self):
        return(self.tmCfg1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.clkDivSel & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.tmAdcDataSel & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.fltStsTest & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.svidRdVidSet & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.pmbTestEn & 0x1) << 11)
        reg = (reg & 0xF9FF) + ((register_object.clkTestSel & 0x3) << 9)
        reg = (reg & 0xFEFF) + ((register_object.clkTest & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.trigOut & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.debug & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.useDllClocks & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.faultTest & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.scanTm1 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.scanTm0 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.refHot & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.unUsed1 & 0x1)
        dma(self.address, 0xE3D9, reg)
    ## 0 = clkDiv mode 0 m0Div2 to clkSys, m0Div4 to clkTs<br>1 = clkDiv mode 1 clkM0 routed to clkSys, m0Div2 to clkTs
    def clkDivSel(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 15, value)
        return(value)
    ## 0: vSen 1:iSen
    def tmAdcDataSel(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 14, value)
        return(value)
    ## Fault and status test enable
    def fltStsTest(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 13, value)
        return(value)
    ## SVID read from VID setting returns setting instead of tracking VID
    def svidRdVidSet(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 12, value)
        return(value)
    ## PMBus and SVID interface testEn control bit. Alters the limit on the time out timers to make them assert early.
    def pmbTestEn(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 11, value)
        return(value)
    ## Clock Test Select. Two bit selector chooses which clock is selected for the embedded clock test mode.
    def clkTestSel(self, value = None):
        value = dma_bits(0xE3D9, self.address, 2, 9, value)
        return(value)
    ## Clock Test Mode. 1 activates the embedded clock test mode, which also activates the ring oscillator test capability
    def clkTest(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 8, value)
        return(value)
    ## Activate event trigger output
    def trigOut(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 7, value)
        return(value)
    ## Activate MCU debug interface
    def debug(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 6, value)
        return(value)
    ## 0 - Use base clocks selected by clkTestDel, 1 - Use DLL clocks for embedded test mode.
    def useDllClocks(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 5, value)
        return(value)
    ## Fault Test mode. Routes shutdown signals to PWRGD1/2 pins
    def faultTest(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 4, value)
        return(value)
    ## Test mode select for scan engine, bit 1
    def scanTm1(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 3, value)
        return(value)
    ## Test mode select for scan engine, bit 0
    def scanTm0(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 2, value)
        return(value)
    ## Force internal reference voltage to run as if at 80C
    def refHot(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 1, value)
        return(value)
    ## Unused
    def unUsed1(self, value = None):
        value = dma_bits(0xE3D9, self.address, 1, 0, value)
        return(value)

###################################################################
## Test configuration register 2 (firmware) - Not used
###################################################################
class tmCfg2_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3DA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tmCfg2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3DA, None)
            self.otpWriteRam = (self.reg_value >> 7) & 0x1
            self.ramBist = (self.reg_value >> 6) & 0x1
            self.restart = (self.reg_value >> 5) & 0x1
            self.runRam = (self.reg_value >> 4) & 0x1
            self.otpWrite = (self.reg_value >> 3) & 0x1
            self.otpEmpty = (self.reg_value >> 2) & 0x1
            self.romCrc = (self.reg_value >> 1) & 0x1
            self.mcuLoop = self.reg_value & 0x1

    def read_object(self):
        return(self.tmCfg2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.otpWriteRam & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ramBist & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.restart & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.runRam & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.otpWrite & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.otpEmpty & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.romCrc & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.mcuLoop & 0x1)
        dma(self.address, 0xE3DA, reg)
    ## Write RAM data block to OTP
    def otpWriteRam(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 7, value)
        return(value)
    ## Run a RAM test using program in ROM
    def ramBist(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 6, value)
        return(value)
    ## Restart as if there was a POR cold start
    def restart(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 5, value)
        return(value)
    ## Run program loaded into RAM
    def runRam(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 4, value)
        return(value)
    ## Run OTP self test write test function
    def otpWrite(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 3, value)
        return(value)
    ## Run OTP self test empty check
    def otpEmpty(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 2, value)
        return(value)
    ## Run ROM CRC check
    def romCrc(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 1, value)
        return(value)
    ## Put MCU into a tight loop
    def mcuLoop(self, value = None):
        value = dma_bits(0xE3DA, self.address, 1, 0, value)
        return(value)

###################################################################
## Test enable register
###################################################################
class tmEna_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3DD, value)
        return(value)


###################################################################
## Memory access interrupt trigger address
###################################################################
class addressTrigger_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3DE, value)
        return(value)


###################################################################
## Stored Password from OTP
###################################################################
class storedPw_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3DF, value)
        return(value)


###################################################################
## Serial log data A
###################################################################
class serialLogA_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F0, value)
        return(value)


###################################################################
## Serial log data B
###################################################################
class serialLogB_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F1, value)
        return(value)


###################################################################
## Serial log data C
###################################################################
class serialLogC_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F2, value)
        return(value)


###################################################################
## PMBus data log read port A
###################################################################
class pmbLogA_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F3, value)
        return(value)


###################################################################
## PMBus data log read port B
###################################################################
class pmbLogB_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F4, value)
        return(value)


###################################################################
## Encrypted Password from Firmware
###################################################################
class encryptedPw_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F6, value)
        return(value)


###################################################################
## Password Lockout Status Register
###################################################################
class pwLockStatus_class(object):
    def __init__(self, address):
        self.interface = 'miscBus'
        self.address = address
        self.bits = 2

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwLockStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3F7, None)
            self.pwLockout = (self.reg_value >> 1) & 0x1
            self.NotenWrtProtWr = self.reg_value & 0x1

    def read_object(self):
        return(self.pwLockStatus_Object(self.address))

    ## 0 = password function is unlocked, 1 = password function is locked
    def pwLockout(self):
        value = dma_bits(0xE3F7, self.address, 1, 1, None)
        return(value)
    ## 0 = WRITE_PROTECT is unlocked, 1 = WRITE_PROTECT is locked
    def NotenWrtProtWr(self):
        value = dma_bits(0xE3F7, self.address, 1, 0, None)
        return(value)

###################################################################
## Manufacturer Specific setting register for AVS - not implemented
###################################################################
class avsMfrSpcfcSetting_class(object):
    def __init__(self, address):
        self.interface = 'avsMfr'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE3E2, value)
        return(value)


###################################################################
## Manufacturer Specific register for AVS - not implemented
###################################################################
class avsMfrSpcfcReg_class(object):
    def __init__(self, address):
        self.interface = 'avsMfr'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3E6, value)
        return(value)


###################################################################
## AMD SVID2 command register 0
###################################################################
class svi2Reg0_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi2Reg0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3F8, None)
            self.offTrim = (self.reg_value >> 13) & 0x3
            self.llSlope = (self.reg_value >> 10) & 0x7
            self.psi = (self.reg_value >> 8) & 0x3
            self.vid = self.reg_value & 0xFF

    def read_object(self):
        return(self.svi2Reg0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x9FFF) + ((register_object.offTrim & 0x3) << 13)
        reg = (reg & 0xE3FF) + ((register_object.llSlope & 0x7) << 10)
        reg = (reg & 0xFCFF) + ((register_object.psi & 0x3) << 8)
        reg = (reg & 0xFF00) + (register_object.vid & 0xFF)
        dma(self.address, 0xE3F8, reg)
    ## offset trim 0=0v 1=-25mv 2=initial offset 3=+25mv
    def offTrim(self, value = None):
        value = dma_bits(0xE3F8, self.address, 2, 13, value)
        return(value)
    ## load-line slope trim  0=none, 1=-40%, 2=-20%, 3=nominal, 4=+20% 5=+40% 6=+60% 7=+80%
    def llSlope(self, value = None):
        value = dma_bits(0xE3F8, self.address, 3, 10, value)
        return(value)
    ## PSI 00=lowest 10=reduced 01,11=full
    def psi(self, value = None):
        value = dma_bits(0xE3F8, self.address, 2, 8, value)
        return(value)
    ## SVI2 VID code
    def vid(self, value = None):
        value = dma_bits(0xE3F8, self.address, 8, 0, value)
        return(value)

###################################################################
## AMD SVID2 command register 1
###################################################################
class svi2Reg1_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3F9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi2Reg1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3F9, None)
            self.offTrim = (self.reg_value >> 13) & 0x3
            self.llSlope = (self.reg_value >> 10) & 0x7
            self.psi = (self.reg_value >> 8) & 0x3
            self.vid = self.reg_value & 0xFF

    def read_object(self):
        return(self.svi2Reg1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x9FFF) + ((register_object.offTrim & 0x3) << 13)
        reg = (reg & 0xE3FF) + ((register_object.llSlope & 0x7) << 10)
        reg = (reg & 0xFCFF) + ((register_object.psi & 0x3) << 8)
        reg = (reg & 0xFF00) + (register_object.vid & 0xFF)
        dma(self.address, 0xE3F9, reg)
    ## offset trim 0=0v 1=-25mv 2=initial offset 3=+25mv
    def offTrim(self, value = None):
        value = dma_bits(0xE3F9, self.address, 2, 13, value)
        return(value)
    ## load-line slope trim  0=none, 1=-40%, 2=-20%, 3=nominal, 4=+20% 5=+40% 6=+60% 7=+80%
    def llSlope(self, value = None):
        value = dma_bits(0xE3F9, self.address, 3, 10, value)
        return(value)
    ## PSI 00=lowest 10=reduced 01,11=full
    def psi(self, value = None):
        value = dma_bits(0xE3F9, self.address, 2, 8, value)
        return(value)
    ## SVI2 VID code
    def vid(self, value = None):
        value = dma_bits(0xE3F9, self.address, 8, 0, value)
        return(value)

###################################################################
## SVI2 Configuration Register
###################################################################
class svi2Cfg_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE3FB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi2Cfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3FB, None)
            self.votfcDelay = (self.reg_value >> 8) & 0x3
            self.svtTimeOut = self.reg_value & 0xFF

    def read_object(self):
        return(self.svi2Cfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFCFF) + ((register_object.votfcDelay & 0x3) << 8)
        reg = (reg & 0xFF00) + (register_object.svtTimeOut & 0xFF)
        dma(self.address, 0xE3FB, reg)
    ## VOTFC delay selection
    def votfcDelay(self, value = None):
        value = dma_bits(0xE3FB, self.address, 2, 8, value)
        return(value)
    ## SVI2 transmitter timeout
    def svtTimeOut(self, value = None):
        value = dma_bits(0xE3FB, self.address, 8, 0, value)
        return(value)

###################################################################
## AMD SVI2 Telemetry Output Voltage channel 0
###################################################################
class svi2CV_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xE3FC, value)
        return(value)


###################################################################
## AMD SVI2 Telemetry Output Current channel 0
###################################################################
class svi2CI_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3FD, value)
        return(value)


###################################################################
## AMD SVI2 Telemetry Output Voltage channel 1
###################################################################
class svi2GV_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xE3FE, value)
        return(value)


###################################################################
## AMD SVI2 Telemetry Output Current channel 0
###################################################################
class svi2GI_class(object):
    def __init__(self, address):
        self.interface = 'svi2Bus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE3FF, value)
        return(value)


###################################################################
## SVID vendor ID register
###################################################################
class vendorId_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE400, value)
        return(value)


###################################################################
## SVID product ID register
###################################################################
class prodId_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE401, value)
        return(value)


###################################################################
## SVID product revision register
###################################################################
class prodRev_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE402, value)
        return(value)


###################################################################
## SVID production date register
###################################################################
class prodDate_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE403, value)
        return(value)


###################################################################
## SVID production lot register
###################################################################
class prodLot_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE404, value)
        return(value)


###################################################################
## SVID protocol ID register
###################################################################
class protocolId_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE405, value)
        return(value)


###################################################################
## SVID VR capability register 0
###################################################################
class vrCapability_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE406, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vrCapability_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE406, None)
            self.iout = (self.reg_value >> 7) & 0x1
            self.temp = (self.reg_value >> 6) & 0x1
            self.pin = (self.reg_value >> 5) & 0x1
            self.vin = (self.reg_value >> 4) & 0x1
            self.iin = (self.reg_value >> 3) & 0x1
            self.pout = (self.reg_value >> 2) & 0x1
            self.vout = (self.reg_value >> 1) & 0x1
            self.ioutNotJout = self.reg_value & 0x1

    def read_object(self):
        return(self.vrCapability_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.iout & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.temp & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.pin & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.vin & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.iin & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.pout & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.vout & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ioutNotJout & 0x1)
        dma(self.address, 0xE406, reg)
    ## There is output curr telem in 15h
    def iout(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 7, value)
        return(value)
    ## There is temp telem in 17h
    def temp(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 6, value)
        return(value)
    ## There is input power telem in 1Bh
    def pin(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 5, value)
        return(value)
    ## There is input volt telem in 1Ah
    def vin(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 4, value)
        return(value)
    ## There is input curr telem in 19h
    def iin(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 3, value)
        return(value)
    ## There is output power telem in 18h
    def pout(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 2, value)
        return(value)
    ## There is output volt telem in 16h
    def vout(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 1, value)
        return(value)
    ## Reg 15h is Iout if 1, Jout if 0
    def ioutNotJout(self, value = None):
        value = dma_bits(0xE406, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID Step Size
###################################################################
class svidStepSize_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE407, value)
        return(value)


###################################################################
## SVID Offset VID
###################################################################
class svidOffsetVID_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE408, value)
        return(value)


###################################################################
## SVID VIDO_MAX_H
###################################################################
class svidVIDOMAXH_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE409, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidVIDOMAXH_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE409, None)
            self.psys20Sup = (self.reg_value >> 7) & 0x1
            self.imonCalSupp = (self.reg_value >> 6) & 0x1
            self.svidDbgLog = (self.reg_value >> 5) & 0x1
            self.svidDbgEvent = (self.reg_value >> 4) & 0x1
            self.hiPrecTelem = (self.reg_value >> 3) & 0x1
            self.iccInMaxUsed = (self.reg_value >> 2) & 0x1
            self.vidoMax8 = self.reg_value & 0x1

    def read_object(self):
        return(self.svidVIDOMAXH_Object(self.address))

    ## PSys 2.0 Support
    def psys20Sup(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 7, value)
        return(value)
    ## IMON Calibration
    def imonCalSupp(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 6, value)
        return(value)
    ## Design for Debug SVID Logs
    def svidDbgLog(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 5, value)
        return(value)
    ## Design for Debug VR event log
    def svidDbgEvent(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 4, value)
        return(value)
    ## High Precision Telemetry
    def hiPrecTelem(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 3, value)
        return(value)
    ## Use SVID IinMax to scale SVIDIIN value if 1, or in amps with shift if 0
    def iccInMaxUsed(self, value = None):
        value = dma_bits(0xE409, self.address, 1, 2, value)
        return(value)
    ## VIDo_Max[8]
    def vidoMax8(self):
        value = dma_bits(0xE409, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID VIDO_MAX_L
###################################################################
class svidVIDOMAXL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40A, value)
        return(value)


###################################################################
## SVID VinFF_H
###################################################################
class svidVinFFH_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40B, value)
        return(value)


###################################################################
## svidVinFFL
###################################################################
class svidVinFFL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40C, value)
        return(value)


###################################################################
## SVID VoutFF_H
###################################################################
class svidVoutFFH_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40D, value)
        return(value)


###################################################################
## SVID VoutFF_L
###################################################################
class svidVoutFFL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40E, value)
        return(value)


###################################################################
## SVID All Call Resp
###################################################################
class svidAllCallResp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE40F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidAllCallResp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE40F, None)
            self.allCallE = (self.reg_value >> 1) & 0x1
            self.allCallF = self.reg_value & 0x1

    def read_object(self):
        return(self.svidAllCallResp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFD) + ((register_object.allCallE & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.allCallF & 0x1)
        dma(self.address, 0xE40F, reg)
    ## SVID All Call enable for address E
    def allCallE(self, value = None):
        value = dma_bits(0xE40F, self.address, 1, 1, value)
        return(value)
    ## SVID All Call enable for address F
    def allCallF(self, value = None):
        value = dma_bits(0xE40F, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID status 1 register
###################################################################
class svidStatus1Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE410, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidStatus1Lp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE410, None)
            self.svalert = (self.reg_value >> 10) & 0x1
            self.alert = (self.reg_value >> 9) & 0x1
            self.stlAlert = (self.reg_value >> 8) & 0x1
            self.readStatus2 = (self.reg_value >> 7) & 0x1
            self.vidDacHigh = (self.reg_value >> 3) & 0x1
            self.iccMaxAlert = (self.reg_value >> 2) & 0x1
            self.thermAlert = (self.reg_value >> 1) & 0x1
            self.vrSettled = self.reg_value & 0x1

    def read_object(self):
        return(self.svidStatus1Lp_Object(self.address))

    ## SVID alert pin status, active high
    def svalert(self):
        value = dma_bits(0xE410, self.address, 1, 10, None)
        return(value)
    ## Alert status for any alerting condition, active high
    def alert(self):
        value = dma_bits(0xE410, self.address, 1, 9, None)
        return(value)
    ## Settle alert status, active high
    def stlAlert(self):
        value = dma_bits(0xE410, self.address, 1, 8, None)
        return(value)
    ## Go read status 2
    def readStatus2(self):
        value = dma_bits(0xE410, self.address, 1, 7, None)
        return(value)
    ## Dac > 30mv above target
    def vidDacHigh(self):
        value = dma_bits(0xE410, self.address, 1, 3, None)
        return(value)
    ## Over current
    def iccMaxAlert(self):
        value = dma_bits(0xE410, self.address, 1, 2, None)
        return(value)
    ## Over temp
    def thermAlert(self):
        value = dma_bits(0xE410, self.address, 1, 1, None)
        return(value)
    ## Settled at target volt
    def vrSettled(self):
        value = dma_bits(0xE410, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID status 2 register
###################################################################
class svidStatus2Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE411, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidStatus2Lp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE411, None)
            self.svidC2CError = (self.reg_value >> 2) & 0x1
            self.svidDataFrameError = (self.reg_value >> 1) & 0x1
            self.svidParityError = self.reg_value & 0x1

    def read_object(self):
        return(self.svidStatus2Lp_Object(self.address))

    ## SVID cycle to cycle OC error
    def svidC2CError(self):
        value = dma_bits(0xE411, self.address, 1, 2, None)
        return(value)
    ## SVID data frame error
    def svidDataFrameError(self):
        value = dma_bits(0xE411, self.address, 1, 1, None)
        return(value)
    ## SVID parity error
    def svidParityError(self):
        value = dma_bits(0xE411, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID temperature zone register 0
###################################################################
class svidTempZone_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE412, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidTempZone_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE412, None)
            self.tempMax = (self.reg_value >> 7) & 0x1
            self.thermAlert = (self.reg_value >> 6) & 0x1
            self.zone5 = (self.reg_value >> 5) & 0x1
            self.zone4 = (self.reg_value >> 4) & 0x1
            self.zone3 = (self.reg_value >> 3) & 0x1
            self.zone2 = (self.reg_value >> 2) & 0x1
            self.zone1 = (self.reg_value >> 1) & 0x1
            self.zone0 = self.reg_value & 0x1

    def read_object(self):
        return(self.svidTempZone_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.tempMax & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.thermAlert & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.zone5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.zone4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.zone3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.zone2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.zone1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.zone0 & 0x1)
        dma(self.address, 0xE412, reg)
    ## Temp above max -- VR_HOT
    def tempMax(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 7, value)
        return(value)
    ## Above Therm Alert point
    def thermAlert(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 6, value)
        return(value)
    ## Temp 94%
    def zone5(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 5, value)
        return(value)
    ## Temp 91%
    def zone4(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 4, value)
        return(value)
    ## Temp 88%
    def zone3(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 3, value)
        return(value)
    ## Temp 85%
    def zone2(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 2, value)
        return(value)
    ## Temp 82%
    def zone1(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 1, value)
        return(value)
    ## Temp 75%
    def zone0(self, value = None):
        value = dma_bits(0xE412, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID PMIC global status
###################################################################
class pmicGblStatus_class(object):
    def __init__(self, address):
        self.interface = 'svidGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE413, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pmicGblStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE413, None)
            self.vrSettled07h = (self.reg_value >> 7) & 0x1
            self.vrSettled06h = (self.reg_value >> 6) & 0x1
            self.vrSettled05h = (self.reg_value >> 5) & 0x1
            self.vrSettled04h = (self.reg_value >> 4) & 0x1
            self.vrSettled03h = (self.reg_value >> 3) & 0x1
            self.vrSettled02h = (self.reg_value >> 2) & 0x1
            self.vrSettled01h = (self.reg_value >> 1) & 0x1
            self.vrSettled00h = self.reg_value & 0x1

    def read_object(self):
        return(self.pmicGblStatus_Object(self.address))

    ## force 1
    def vrSettled07h(self):
        value = dma_bits(0xE413, self.address, 1, 7, None)
        return(value)
    ## force 1
    def vrSettled06h(self):
        value = dma_bits(0xE413, self.address, 1, 6, None)
        return(value)
    ## force 1
    def vrSettled05h(self):
        value = dma_bits(0xE413, self.address, 1, 5, None)
        return(value)
    ## force 1
    def vrSettled04h(self):
        value = dma_bits(0xE413, self.address, 1, 4, None)
        return(value)
    ## force 1
    def vrSettled03h(self):
        value = dma_bits(0xE413, self.address, 1, 3, None)
        return(value)
    ## VrSettled on Addr 02h
    def vrSettled02h(self):
        value = dma_bits(0xE413, self.address, 1, 2, None)
        return(value)
    ## VrSettled on Addr 01h
    def vrSettled01h(self):
        value = dma_bits(0xE413, self.address, 1, 1, None)
        return(value)
    ## VrSettled on Addr 00h
    def vrSettled00h(self):
        value = dma_bits(0xE413, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID Last Read register
###################################################################
class lastReadLp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE414, value)
        return(value)


###################################################################
## SVID output current telemetry register
###################################################################
class svidIout_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE415, value)
        return(value)


###################################################################
## SVID output voltage telemetry register
###################################################################
class svidVout_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE416, value)
        return(value)


###################################################################
## SVID temperature telemetry register
###################################################################
class svidVrTemp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE417, value)
        return(value)


###################################################################
## SVID output power telemetry register
###################################################################
class svidPout_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE418, value)
        return(value)


###################################################################
## SVID input current telemetry register
###################################################################
class svidIin_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE419, value)
        return(value)


###################################################################
## SVID input voltage telemetry register
###################################################################
class svidVin_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE41A, value)
        return(value)


###################################################################
## SVID input power telemetry register
###################################################################
class svidPin_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE41B, value)
        return(value)


###################################################################
## SVID Status 2 last read register
###################################################################
class svidStatus2Last_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE41C, value)
        return(value)

    ## SVID status2 LSBs registered from last read attempt
    def svidStatus2Last(self):
        value = dma_bits(0xE41C, self.address, 2, 0, None)
        return(value)

###################################################################
## SVID Configuration File Version Identifier
###################################################################
class cfgFileId_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE41E, value)
        return(value)


###################################################################
## 
###################################################################
class cycToCycLimit_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE41F, value)
        return(value)


###################################################################
## Maximum Icc (Iin) for capability and telemetry register
###################################################################
class svidIccInMax_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE420, value)
        return(value)


###################################################################
## Maximum Icc (Iout) for capability and telemetry register
###################################################################
class svidIccMax_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE421, value)
        return(value)


###################################################################
## Temperature at which VR_hot asserts register
###################################################################
class svidTempMax_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE422, value)
        return(value)


###################################################################
## Load-line (droop)  register
###################################################################
class svidDcLl_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE423, value)
        return(value)


###################################################################
## SVID voltage fast slew rate register
###################################################################
class svidSrFast_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE424, value)
        return(value)


###################################################################
## SVID voltage slow slew rate register
###################################################################
class svidSrSlow_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE425, value)
        return(value)


###################################################################
## SVID boot voltage VID code register
###################################################################
class svidVboot_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE426, value)
        return(value)


###################################################################
## Voltage tolerance register
###################################################################
class svidVrTol_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE427, value)
        return(value)


###################################################################
## 
###################################################################
class svidSlSlSel_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidSlSlSel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE42A, None)
            self.hcSupport = (self.reg_value >> 7) & 0x1
            self.hcActive = (self.reg_value >> 6) & 0x1
            self.svidSlSlSel = self.reg_value & 0xF

    def read_object(self):
        return(self.svidSlSlSel_Object(self.address))

    ## Support VR13.HC telemetry scaling -- driven by pwrMode.HC bit
    def hcSupport(self):
        value = dma_bits(0xE42A, self.address, 1, 7, None)
        return(value)
    ## Processor activates VR13.HC scaling
    def hcActive(self):
        value = dma_bits(0xE42A, self.address, 1, 6, None)
        return(value)
    ## Slow slew rate is 1=fast/2 2=fast/4 4=fast/8 8=fast/16 <br> Reset to 2 on enable
    def svidSlSlSel(self):
        value = dma_bits(0xE42A, self.address, 4, 0, None)
        return(value)

###################################################################
## 
###################################################################
class svidPs4ExLat_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidPs4ExLat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE42B, None)
            self.ps4ExLatY = (self.reg_value >> 4) & 0xF
            self.ps4ExLatX = self.reg_value & 0xF

    def read_object(self):
        return(self.svidPs4ExLat_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.ps4ExLatY & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.ps4ExLatX & 0xF)
        dma(self.address, 0xE42B, reg)
    def ps4ExLatY(self, value = None):
        value = dma_bits(0xE42B, self.address, 4, 4, value)
        return(value)
    ## PS4 exit latency ([3:0]/16)*(2^[7:4]) microseconds
    def ps4ExLatX(self, value = None):
        value = dma_bits(0xE42B, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class svidPs3ExLat_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidPs3ExLat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE42C, None)
            self.ps3ExLatY = (self.reg_value >> 4) & 0xF
            self.ps3ExLatX = self.reg_value & 0xF

    def read_object(self):
        return(self.svidPs3ExLat_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.ps3ExLatY & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.ps3ExLatX & 0xF)
        dma(self.address, 0xE42C, reg)
    def ps3ExLatY(self, value = None):
        value = dma_bits(0xE42C, self.address, 4, 4, value)
        return(value)
    ## PS3 exit latency ([3:0]/16)*(2^[7:4]) microseconds
    def ps3ExLatX(self, value = None):
        value = dma_bits(0xE42C, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class svidEnToSvid_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidEnToSvid_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE42D, None)
            self.enToSvidX = (self.reg_value >> 4) & 0xF
            self.enToSvidY = self.reg_value & 0xF

    def read_object(self):
        return(self.svidEnToSvid_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.enToSvidX & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.enToSvidY & 0xF)
        dma(self.address, 0xE42D, reg)
    def enToSvidX(self, value = None):
        value = dma_bits(0xE42D, self.address, 4, 4, value)
        return(value)
    ## Enable until SVID ready latency
    def enToSvidY(self, value = None):
        value = dma_bits(0xE42D, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class svidPinMax_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42E, value)
        return(value)


###################################################################
## 
###################################################################
class svidPinAlrtThrsh_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE42F, value)
        return(value)


###################################################################
## 
###################################################################
class svidVoutMax_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE430, value)
        return(value)


###################################################################
## Current VID setting register
###################################################################
class svidVidSet_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE431, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidVidSet_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE431, None)
            self.rate = (self.reg_value >> 8) & 0x7
            self.vid = self.reg_value & 0xFF

    def read_object(self):
        return(self.svidVidSet_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.rate & 0x7) << 8)
        reg = (reg & 0x700) + (register_object.vid & 0xFF)
        dma(self.address, 0xE431, reg)
    ## SetVID rate: 00=fast,01=slow,11=decay. MSB is not used
    def rate(self, value = None):
        value = dma_bits(0xE431, self.address, 3, 8, value)
        return(value)
    ## Current VID code
    def vid(self, value = None):
        value = dma_bits(0xE431, self.address, 8, 0, value)
        return(value)

###################################################################
## Current power state register
###################################################################
class svidPsLp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE432, value)
        return(value)


###################################################################
## Set Vout offset register
###################################################################
class svidOffset_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE433, value)
        return(value)


###################################################################
## Multi-VR configuration register
###################################################################
class svidMultiVR_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE434, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidMultiVR_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE434, None)
            self.lockVidPs = (self.reg_value >> 1) & 0x1
            self.vrReady0v = self.reg_value & 0x1

    def read_object(self):
        return(self.svidMultiVR_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFD) + ((register_object.lockVidPs & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.vrReady0v & 0x1)
        dma(self.address, 0xE434, reg)
    ## Lock VID and PS if 1 (reset to 0 on enable)
    def lockVidPs(self, value = None):
        value = dma_bits(0xE434, self.address, 1, 1, value)
        return(value)
    ## Do not deassert VR_READY at VID=0/PS4 (reset to OTP value on enable)
    def vrReady0v(self, value = None):
        value = dma_bits(0xE434, self.address, 1, 0, value)
        return(value)

###################################################################
## scratchpad register
###################################################################
class svidScratch_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE435, value)
        return(value)


###################################################################
## DC Load Line Fine
###################################################################
class dcLlFine_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE436, value)
        return(value)


###################################################################
## SVID Tracking VID RO
###################################################################
class trkVid_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE437, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP0Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43A, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP1Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43B, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP2Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43C, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP3Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43D, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP4Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43E, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP5Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE43F, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP6Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE440, value)
        return(value)


###################################################################
## 
###################################################################
class svidWP7Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE441, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID1V_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE442, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID1I_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE443, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID2V_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE444, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID2I_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE445, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID3V_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE446, value)
        return(value)


###################################################################
## 
###################################################################
class svidIVID3I_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE447, value)
        return(value)


###################################################################
## Extended capability 1 register, or VR13.HC ICCMAXADD (amps/2)
###################################################################
class extCapability1Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE450, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extCapability1Lp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE450, None)
            self.ampPerBitIn = (self.reg_value >> 5) & 0x7
            self.wattPerBit = (self.reg_value >> 2) & 0x7
            self.ampPerBit = self.reg_value & 0x3

    def read_object(self):
        return(self.extCapability1Lp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.ampPerBitIn & 0x7) << 5)
        reg = (reg & 0xE3) + ((register_object.wattPerBit & 0x7) << 2)
        reg = (reg & 0xFC) + (register_object.ampPerBit & 0x3)
        dma(self.address, 0xE450, reg)
    ## Curr In LSB WEIRD 0-7 = 1,2,4, 1/2,1/4,1/8,1/16,1/32 Amps
    def ampPerBitIn(self, value = None):
        value = dma_bits(0xE450, self.address, 3, 5, value)
        return(value)
    ## Pow Out 1,2,4,8,16,32,64,128; In 2,4,8,16,32,64,128,256 Watts
    def wattPerBit(self, value = None):
        value = dma_bits(0xE450, self.address, 3, 2, value)
        return(value)
    ## Curr Out 1,2,4,8 Amps
    def ampPerBit(self, value = None):
        value = dma_bits(0xE450, self.address, 2, 0, value)
        return(value)

###################################################################
## Power State Supported, or VR13.HC PINMAXADD (watts/4)
###################################################################
class extCapability2Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE451, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extCapability2Lp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE451, None)
            self.maxPs = (self.reg_value >> 4) & 0xF
            self.ps4Supp = (self.reg_value >> 3) & 0x1
            self.ps3Supp = (self.reg_value >> 2) & 0x1
            self.ps2Supp = (self.reg_value >> 1) & 0x1
            self.ps1Supp = self.reg_value & 0x1

    def read_object(self):
        return(self.extCapability2Lp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.maxPs & 0xF) << 4)
        reg = (reg & 0xF7) + ((register_object.ps4Supp & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ps3Supp & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ps2Supp & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ps1Supp & 0x1)
        dma(self.address, 0xE451, reg)
    ## Max supported power state
    def maxPs(self, value = None):
        value = dma_bits(0xE451, self.address, 4, 4, value)
        return(value)
    ## PS4 supported (near off)
    def ps4Supp(self, value = None):
        value = dma_bits(0xE451, self.address, 1, 3, value)
        return(value)
    ## PS3 supported (ultra low pow)
    def ps3Supp(self, value = None):
        value = dma_bits(0xE451, self.address, 1, 2, value)
        return(value)
    ## PS2 supported (very low pow)
    def ps2Supp(self, value = None):
        value = dma_bits(0xE451, self.address, 1, 1, value)
        return(value)
    ## PS1 supported (low pow)
    def ps1Supp(self, value = None):
        value = dma_bits(0xE451, self.address, 1, 0, value)
        return(value)

###################################################################
## Phase Shed Method Support, or VR13.HC PINALERTADD
###################################################################
class extCapability3Lp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE452, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extCapability3Lp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE452, None)
            self.pmbus = (self.reg_value >> 3) & 0x1
            self.disablePhSh = (self.reg_value >> 2) & 0x1
            self.manualPhSh = (self.reg_value >> 1) & 0x1
            self.automaticPhSh = self.reg_value & 0x1

    def read_object(self):
        return(self.extCapability3Lp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7) + ((register_object.pmbus & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.disablePhSh & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.manualPhSh & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.automaticPhSh & 0x1)
        dma(self.address, 0xE452, reg)
    ## PMBus defined phase shedding
    def pmbus(self, value = None):
        value = dma_bits(0xE452, self.address, 1, 3, value)
        return(value)
    ## Disable phase shedding
    def disablePhSh(self, value = None):
        value = dma_bits(0xE452, self.address, 1, 2, value)
        return(value)
    ## Manual phase shedding
    def manualPhSh(self, value = None):
        value = dma_bits(0xE452, self.address, 1, 1, value)
        return(value)
    ## Automatic phase shedding
    def automaticPhSh(self, value = None):
        value = dma_bits(0xE452, self.address, 1, 0, value)
        return(value)

###################################################################
## Phase shedding method
###################################################################
class extPhShedCtrl_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE453, value)
        return(value)


###################################################################
## Neg edge Vr_En support register
###################################################################
class extNegVrEnCtrl_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE454, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extNegVrEnCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE454, None)
            self.subReported = (self.reg_value >> 7) & 0x1
            self.vid00hDecay = (self.reg_value >> 6) & 0x1
            self.replaceFastDown = (self.reg_value >> 5) & 0x1
            self.pmbusSupp = (self.reg_value >> 4) & 0x1
            self.softSupp = (self.reg_value >> 3) & 0x1
            self.fastSupp = (self.reg_value >> 2) & 0x1
            self.slowSupp = (self.reg_value >> 1) & 0x1
            self.decaySupp = self.reg_value & 0x1

    def read_object(self):
        return(self.extNegVrEnCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.subReported & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.vid00hDecay & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.replaceFastDown & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.pmbusSupp & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.softSupp & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.fastSupp & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.slowSupp & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.decaySupp & 0x1)
        dma(self.address, 0xE454, reg)
    def subReported(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 7, value)
        return(value)
    def vid00hDecay(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 6, value)
        return(value)
    def replaceFastDown(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 5, value)
        return(value)
    ## Support PMBus defined ramp turn off
    def pmbusSupp(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 4, value)
        return(value)
    ## Support other ramp turn off
    def softSupp(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 3, value)
        return(value)
    ## Support fast ramp turn off
    def fastSupp(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 2, value)
        return(value)
    ## Support slow ramp turn off
    def slowSupp(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 1, value)
        return(value)
    ## Support decay turn off
    def decaySupp(self, value = None):
        value = dma_bits(0xE454, self.address, 1, 0, value)
        return(value)

###################################################################
## Neg edge Vr_En control register
###################################################################
class extNegVrEnResp_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE455, value)
        return(value)

    ## On disable, use selected method 0=decay, 1=slow, 2=fast, 3=other, 4-PMBus
    def negVrEnMode(self, value = None):
        value = dma_bits(0xE455, self.address, 3, 0, value)
        return(value)

###################################################################
## Digital output status
###################################################################
class digOutStatus_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE456, value)
        return(value)


###################################################################
## Work Point Slew 0
###################################################################
class wpSlew0_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE457, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class wpSlew0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE457, None)
            self.wp0Vrsa = (self.reg_value >> 7) & 0x1
            self.wp0Slew = (self.reg_value >> 4) & 0x7
            self.wp1Vrsa = (self.reg_value >> 3) & 0x1
            self.wp1Slew = self.reg_value & 0x7

    def read_object(self):
        return(self.wpSlew0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.wp0Vrsa & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.wp0Slew & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.wp1Vrsa & 0x1) << 3)
        reg = (reg & 0xF8) + (register_object.wp1Slew & 0x7)
        dma(self.address, 0xE457, reg)
    ## WP0 VR Settled Alert enable
    def wp0Vrsa(self, value = None):
        value = dma_bits(0xE457, self.address, 1, 7, value)
        return(value)
    ## WP0 Slew Rate selector
    def wp0Slew(self, value = None):
        value = dma_bits(0xE457, self.address, 3, 4, value)
        return(value)
    ## WP1 VR Settled Alert enable
    def wp1Vrsa(self, value = None):
        value = dma_bits(0xE457, self.address, 1, 3, value)
        return(value)
    ## WP1 Slew Rate selector
    def wp1Slew(self, value = None):
        value = dma_bits(0xE457, self.address, 3, 0, value)
        return(value)

###################################################################
## Work Point Slew 1
###################################################################
class wpSlew1_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE458, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class wpSlew1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE458, None)
            self.wp2Vrsa = (self.reg_value >> 7) & 0x1
            self.wp2Slew = (self.reg_value >> 4) & 0x7
            self.wp3Vrsa = (self.reg_value >> 3) & 0x1
            self.wp3Slew = self.reg_value & 0x7

    def read_object(self):
        return(self.wpSlew1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.wp2Vrsa & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.wp2Slew & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.wp3Vrsa & 0x1) << 3)
        reg = (reg & 0xF8) + (register_object.wp3Slew & 0x7)
        dma(self.address, 0xE458, reg)
    ## WP2 VR Settled Alert enable
    def wp2Vrsa(self, value = None):
        value = dma_bits(0xE458, self.address, 1, 7, value)
        return(value)
    ## WP2 Slew Rate selector
    def wp2Slew(self, value = None):
        value = dma_bits(0xE458, self.address, 3, 4, value)
        return(value)
    ## WP3 VR Settled Alert enable
    def wp3Vrsa(self, value = None):
        value = dma_bits(0xE458, self.address, 1, 3, value)
        return(value)
    ## WP3 Slew Rate selector
    def wp3Slew(self, value = None):
        value = dma_bits(0xE458, self.address, 3, 0, value)
        return(value)

###################################################################
## Work Point Slew 2
###################################################################
class wpSlew2_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE459, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class wpSlew2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE459, None)
            self.wp4Vrsa = (self.reg_value >> 7) & 0x1
            self.wp4Slew = (self.reg_value >> 4) & 0x7
            self.wp5Vrsa = (self.reg_value >> 3) & 0x1
            self.wp5Slew = self.reg_value & 0x7

    def read_object(self):
        return(self.wpSlew2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.wp4Vrsa & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.wp4Slew & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.wp5Vrsa & 0x1) << 3)
        reg = (reg & 0xF8) + (register_object.wp5Slew & 0x7)
        dma(self.address, 0xE459, reg)
    ## WP4 VR Settled Alert enable
    def wp4Vrsa(self, value = None):
        value = dma_bits(0xE459, self.address, 1, 7, value)
        return(value)
    ## WP4 Slew Rate selector
    def wp4Slew(self, value = None):
        value = dma_bits(0xE459, self.address, 3, 4, value)
        return(value)
    ## WP5 VR Settled Alert enable
    def wp5Vrsa(self, value = None):
        value = dma_bits(0xE459, self.address, 1, 3, value)
        return(value)
    ## WP5 Slew Rate selector
    def wp5Slew(self, value = None):
        value = dma_bits(0xE459, self.address, 3, 0, value)
        return(value)

###################################################################
## Work Point Slew 3
###################################################################
class wpSlew3_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE45A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class wpSlew3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE45A, None)
            self.wp6Vrsa = (self.reg_value >> 7) & 0x1
            self.wp6Slew = (self.reg_value >> 4) & 0x7
            self.wp7Vrsa = (self.reg_value >> 3) & 0x1
            self.wp7Slew = self.reg_value & 0x7

    def read_object(self):
        return(self.wpSlew3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.wp6Vrsa & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.wp6Slew & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.wp7Vrsa & 0x1) << 3)
        reg = (reg & 0xF8) + (register_object.wp7Slew & 0x7)
        dma(self.address, 0xE45A, reg)
    ## WP6 VR Settled Alert enable
    def wp6Vrsa(self, value = None):
        value = dma_bits(0xE45A, self.address, 1, 7, value)
        return(value)
    ## WP6 Slew Rate selector
    def wp6Slew(self, value = None):
        value = dma_bits(0xE45A, self.address, 3, 4, value)
        return(value)
    ## WP7 VR Settled Alert enable
    def wp7Vrsa(self, value = None):
        value = dma_bits(0xE45A, self.address, 1, 3, value)
        return(value)
    ## WP7 Slew Rate selector
    def wp7Slew(self, value = None):
        value = dma_bits(0xE45A, self.address, 3, 0, value)
        return(value)

###################################################################
## Work Point Slew Rate Translation Table
###################################################################
class wpSlewTt_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE45B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class wpSlewTt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE45B, None)
            self.wpTtFast = (self.reg_value >> 6) & 0x3
            self.wpTtSlow = (self.reg_value >> 4) & 0x3
            self.wpTtDecay = (self.reg_value >> 2) & 0x3
            self.wpTtTable = self.reg_value & 0x3

    def read_object(self):
        return(self.wpSlewTt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.wpTtFast & 0x3) << 6)
        reg = (reg & 0xCF) + ((register_object.wpTtSlow & 0x3) << 4)
        reg = (reg & 0xF3) + ((register_object.wpTtDecay & 0x3) << 2)
        reg = (reg & 0xFC) + (register_object.wpTtTable & 0x3)
        dma(self.address, 0xE45B, reg)
    ## SetWp(Fast) translation
    def wpTtFast(self, value = None):
        value = dma_bits(0xE45B, self.address, 2, 6, value)
        return(value)
    ## SetWP(Slow) translation
    def wpTtSlow(self, value = None):
        value = dma_bits(0xE45B, self.address, 2, 4, value)
        return(value)
    ## SetWP(Decay) translation
    def wpTtDecay(self, value = None):
        value = dma_bits(0xE45B, self.address, 2, 2, value)
        return(value)
    ## SetWP(Table) translation
    def wpTtTable(self, value = None):
        value = dma_bits(0xE45B, self.address, 2, 0, value)
        return(value)

###################################################################
## Cycle-to-cycle current limit event count
###################################################################
class cycToCycEvntCnt_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE45C, value)
        return(value)


###################################################################
## IMON Calibration Capability - read only
###################################################################
class imonCapability_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE460, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class imonCapability_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE460, None)
            self.calProduction = (self.reg_value >> 7) & 0x1
            self.calSupReqCalcD = (self.reg_value >> 4) & 0x1
            self.calSupReqCalcI = (self.reg_value >> 2) & 0x1
            self.calSupReqB = (self.reg_value >> 1) & 0x1
            self.calSupReqA = self.reg_value & 0x1

    def read_object(self):
        return(self.imonCapability_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.calProduction & 0x1) << 7)
        reg = (reg & 0xEF) + ((register_object.calSupReqCalcD & 0x1) << 4)
        reg = (reg & 0xFB) + ((register_object.calSupReqCalcI & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.calSupReqB & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.calSupReqA & 0x1)
        dma(self.address, 0xE460, reg)
    ## Production calibration
    def calProduction(self, value = None):
        value = dma_bits(0xE460, self.address, 1, 7, value)
        return(value)
    ## Delta current calibration
    def calSupReqCalcD(self, value = None):
        value = dma_bits(0xE460, self.address, 1, 4, value)
        return(value)
    ## A and B current calibration
    def calSupReqCalcI(self, value = None):
        value = dma_bits(0xE460, self.address, 1, 2, value)
        return(value)
    ## B current measure
    def calSupReqB(self, value = None):
        value = dma_bits(0xE460, self.address, 1, 1, value)
        return(value)
    ## A current measure
    def calSupReqA(self, value = None):
        value = dma_bits(0xE460, self.address, 1, 0, value)
        return(value)

###################################################################
## IMON Calibration Request - write through, no storage
###################################################################
class imonRequest_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE461, value)
        return(value)


###################################################################
## IMON Calibration Current A
###################################################################
class imonCurrentA_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE462, value)
        return(value)


###################################################################
## IMON Calibration Current B
###################################################################
class imonCurrentB_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE463, value)
        return(value)


###################################################################
## IMON Calibration Status
###################################################################
class imonCalStatus_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE464, value)
        return(value)


###################################################################
## Expected Accuracy
###################################################################
class expAccuracy_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE470, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class expAccuracy_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE470, None)
            self.psysThrBits = (self.reg_value >> 4) & 0xF
            self.telemBits = self.reg_value & 0xF

    def read_object(self):
        return(self.expAccuracy_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.psysThrBits & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.telemBits & 0xF)
        dma(self.address, 0xE470, reg)
    ## Expected accuracy of Psys threshold
    def psysThrBits(self, value = None):
        value = dma_bits(0xE470, self.address, 4, 4, value)
        return(value)
    ## Expected accuracy of telemetry results
    def telemBits(self, value = None):
        value = dma_bits(0xE470, self.address, 4, 0, value)
        return(value)

###################################################################
## SVID output current telemetry low byte register
###################################################################
class svidIoutL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE471, value)
        return(value)


###################################################################
## SVID output voltage telemetry low byte register
###################################################################
class svidVoutL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE472, value)
        return(value)


###################################################################
## SVID output power telemetry register
###################################################################
class svidPoutL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE473, value)
        return(value)


###################################################################
## SVID input current telemetry low byte register
###################################################################
class svidIinL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE474, value)
        return(value)


###################################################################
## SVID input voltage telemetry low byte register
###################################################################
class svidVinL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE475, value)
        return(value)


###################################################################
## SVID input power telemetry low byte register
###################################################################
class svidPinL_class(object):
    def __init__(self, address):
        self.interface = 'svidCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE476, value)
        return(value)


###################################################################
## SVID Vendor ID
###################################################################
class vendorId3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE580, value)
        return(value)


###################################################################
## SVID Product ID
###################################################################
class prodId3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE581, value)
        return(value)


###################################################################
## SVID Product Revision
###################################################################
class prodRev3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE582, value)
        return(value)


###################################################################
## SVID production date register
###################################################################
class prodDate3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE583, value)
        return(value)


###################################################################
## SVID production lot register
###################################################################
class prodLot3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE584, value)
        return(value)


###################################################################
## SVID protocol ID channel 3 (input power)
###################################################################
class protocolId3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE585, value)
        return(value)


###################################################################
## SVID VR capability register 0
###################################################################
class vrCapabilityLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE586, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vrCapabilityLp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE586, None)
            self.pin = (self.reg_value >> 5) & 0x1
            self.vin = (self.reg_value >> 4) & 0x1
            self.iin = (self.reg_value >> 3) & 0x1

    def read_object(self):
        return(self.vrCapabilityLp3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xDF) + ((register_object.pin & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.vin & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.iin & 0x1) << 3)
        dma(self.address, 0xE586, reg)
    ## There is input power telem in 1Bh
    def pin(self, value = None):
        value = dma_bits(0xE586, self.address, 1, 5, value)
        return(value)
    ## There is input volt telem in 1Ah
    def vin(self, value = None):
        value = dma_bits(0xE586, self.address, 1, 4, value)
        return(value)
    ## There is input curr telem in 19h
    def iin(self, value = None):
        value = dma_bits(0xE586, self.address, 1, 3, value)
        return(value)

###################################################################
## SVID VIDO_MAX_H
###################################################################
class svidVIDOMAXHLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE589, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidVIDOMAXHLp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE589, None)
            self.psys20Sup = (self.reg_value >> 7) & 0x1
            self.imonCalSupp = (self.reg_value >> 6) & 0x1
            self.svidDbgLog = (self.reg_value >> 5) & 0x1
            self.svidDbgEvent = (self.reg_value >> 4) & 0x1
            self.hiPrecTelem = (self.reg_value >> 3) & 0x1
            self.iccInMaxUsed = (self.reg_value >> 2) & 0x1
            self.vidoMax8 = self.reg_value & 0x1

    def read_object(self):
        return(self.svidVIDOMAXHLp3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.psys20Sup & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.imonCalSupp & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.svidDbgLog & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.svidDbgEvent & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.hiPrecTelem & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.iccInMaxUsed & 0x1) << 2)
        reg = (reg & 0xFE) + (register_object.vidoMax8 & 0x1)
        dma(self.address, 0xE589, reg)
    ## PSys 2.0 Support
    def psys20Sup(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 7, value)
        return(value)
    ## IMON Calibration
    def imonCalSupp(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 6, value)
        return(value)
    ## Design for Debug SVID Logs
    def svidDbgLog(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 5, value)
        return(value)
    ## Design for Debug VR event log
    def svidDbgEvent(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 4, value)
        return(value)
    ## High Precision Telemetry
    def hiPrecTelem(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 3, value)
        return(value)
    ## Use SVID IinMax to scale SVIDIIN value if 1, or in amps with shift if 0
    def iccInMaxUsed(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 2, value)
        return(value)
    ## VIDo_Max[8]
    def vidoMax8(self, value = None):
        value = dma_bits(0xE589, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID VinFF_H
###################################################################
class svidVinFFHLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE58B, value)
        return(value)


###################################################################
## svidVinFFL
###################################################################
class svidVinFFLLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE58C, value)
        return(value)


###################################################################
## SVID All Call Resp
###################################################################
class svidAllCallRespLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE58F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidAllCallRespLp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE58F, None)
            self.allCallE = (self.reg_value >> 1) & 0x1
            self.allCallF = self.reg_value & 0x1

    def read_object(self):
        return(self.svidAllCallRespLp3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFD) + ((register_object.allCallE & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.allCallF & 0x1)
        dma(self.address, 0xE58F, reg)
    ## SVID All Call enable for address E
    def allCallE(self, value = None):
        value = dma_bits(0xE58F, self.address, 1, 1, value)
        return(value)
    ## SVID All Call enable for address F
    def allCallF(self, value = None):
        value = dma_bits(0xE58F, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID status 1 register ch3
###################################################################
class svidStatus1Lp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE590, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidStatus1Lp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE590, None)
            self.readStatus2 = (self.reg_value >> 7) & 0x1
            self.vidDacHigh = (self.reg_value >> 3) & 0x1
            self.iccMaxAlert = (self.reg_value >> 2) & 0x1
            self.thermAlert = (self.reg_value >> 1) & 0x1
            self.vrSettled = self.reg_value & 0x1

    def read_object(self):
        return(self.svidStatus1Lp3_Object(self.address))

    ## Go read status 2
    def readStatus2(self):
        value = dma_bits(0xE590, self.address, 1, 7, None)
        return(value)
    ## Dac > 30mv above target
    def vidDacHigh(self):
        value = dma_bits(0xE590, self.address, 1, 3, None)
        return(value)
    ## Over current
    def iccMaxAlert(self):
        value = dma_bits(0xE590, self.address, 1, 2, None)
        return(value)
    ## Over temp
    def thermAlert(self):
        value = dma_bits(0xE590, self.address, 1, 1, None)
        return(value)
    ## Settled at target volt
    def vrSettled(self):
        value = dma_bits(0xE590, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID status 2 register ch3
###################################################################
class svidStatus2Lp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 2

    def __call__(self, value = None):
        value = dma(self.address, 0xE591, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidStatus2Lp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE591, None)
            self.svidFrameErr = (self.reg_value >> 1) & 0x1
            self.svidParityErr = self.reg_value & 0x1

    def read_object(self):
        return(self.svidStatus2Lp3_Object(self.address))

    ## SVID data frame error
    def svidFrameErr(self):
        value = dma_bits(0xE591, self.address, 1, 1, None)
        return(value)
    ## SVID parity error
    def svidParityErr(self):
        value = dma_bits(0xE591, self.address, 1, 0, None)
        return(value)

###################################################################
## SVID Last Read register
###################################################################
class lastReadPsys_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE594, value)
        return(value)


###################################################################
## SVID output current telemetry register for IMVP9.1 VCC_AUX
###################################################################
class svidIout3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE595, value)
        return(value)


###################################################################
## SVID input current telemetry register
###################################################################
class svidIin3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE599, value)
        return(value)


###################################################################
## SVID input voltage telemetry register
###################################################################
class svidVin3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE59A, value)
        return(value)


###################################################################
## SVID input power telemetry ch3
###################################################################
class svidPin3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE59B, value)
        return(value)


###################################################################
## SVID Status 2 last read register
###################################################################
class svidStatus2Last0D_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE59C, value)
        return(value)

    ## SVID status2 LSBs registered from last read attempt
    def svidStatus2Last(self):
        value = dma_bits(0xE59C, self.address, 2, 0, None)
        return(value)

###################################################################
## Maximum Icc (Iin) for capability and telemetry register
###################################################################
class svidIccInMax3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5A0, value)
        return(value)


###################################################################
## Maximum Icc (Iout) for capability and telemetry register for IMVP9.1 VCC_AUX
###################################################################
class svidIccMax3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5A1, value)
        return(value)


###################################################################
## Max input power capability register 2
###################################################################
class svidPinMax3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5AE, value)
        return(value)


###################################################################
## 
###################################################################
class svidPinAlrtThrsh3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5AF, value)
        return(value)


###################################################################
## Current power state register ch3
###################################################################
class svidPsLp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5B2, value)
        return(value)


###################################################################
## Multi-VR configuration register
###################################################################
class svidMultiVR3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5B4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidMultiVR3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5B4, None)
            self.vsysModePeak = (self.reg_value >> 3) & 0x1
            self.vsysMode = (self.reg_value >> 2) & 0x1
            self.lockVidPs = (self.reg_value >> 1) & 0x1
            self.vrReady0v = self.reg_value & 0x1

    def read_object(self):
        return(self.svidMultiVR3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7) + ((register_object.vsysModePeak & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.vsysMode & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.lockVidPs & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.vrReady0v & 0x1)
        dma(self.address, 0xE5B4, reg)
    ## Fast Psys crit level uses input voltage not power in VR14 (reset to 0 on enable)
    def vsysModePeak(self, value = None):
        value = dma_bits(0xE5B4, self.address, 1, 3, value)
        return(value)
    ## Fast warnings and crit use input voltage not power in IMVP9, or warnings only use voltage not power in VR14 (reset to 0 on enable)
    def vsysMode(self, value = None):
        value = dma_bits(0xE5B4, self.address, 1, 2, value)
        return(value)
    ## Lock VID and PS if 1 (reset to 0 on enable)
    def lockVidPs(self, value = None):
        value = dma_bits(0xE5B4, self.address, 1, 1, value)
        return(value)
    ## Do not deassert VR_READY at VID=0/PS4 (reset to OTP value on enable)
    def vrReady0v(self, value = None):
        value = dma_bits(0xE5B4, self.address, 1, 0, value)
        return(value)

###################################################################
## scratchpad register
###################################################################
class svidScratch3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5B5, value)
        return(value)


###################################################################
## PSYS critical debounce deassert
###################################################################
class psysDebDeassert_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5C9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class psysDebDeassert_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5C9, None)
            self.Mantissa = (self.reg_value >> 4) & 0xF
            self.Exponent = self.reg_value & 0xF

    def read_object(self):
        return(self.psysDebDeassert_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.Mantissa & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.Exponent & 0xF)
        dma(self.address, 0xE5C9, reg)
    ## PSYS debounce deassert mantissa
    def Mantissa(self, value = None):
        value = dma_bits(0xE5C9, self.address, 4, 4, value)
        return(value)
    ## PSYS debounce deassert exponent
    def Exponent(self, value = None):
        value = dma_bits(0xE5C9, self.address, 4, 0, value)
        return(value)

###################################################################
## PSYS critical level register
###################################################################
class psysCritLvl3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CA, value)
        return(value)


###################################################################
## PSYS warn 2 level register
###################################################################
class psysWarn2lvl3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CB, value)
        return(value)


###################################################################
## PSYS warn 1 level register
###################################################################
class psysWarn1lvl3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CC, value)
        return(value)


###################################################################
## PSYS warn 2 count register
###################################################################
class psysWarn2cnt3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CD, value)
        return(value)


###################################################################
## PSYS warn 1 count register
###################################################################
class psysWarn1cnt3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CE, value)
        return(value)


###################################################################
## PSYS critical debounce assert
###################################################################
class psysDebAssert_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5CF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class psysDebAssert_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5CF, None)
            self.Mantissa = (self.reg_value >> 4) & 0xF
            self.Exponent = self.reg_value & 0xF

    def read_object(self):
        return(self.psysDebAssert_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.Mantissa & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.Exponent & 0xF)
        dma(self.address, 0xE5CF, reg)
    ## PSYS debounce assert manissa
    def Mantissa(self, value = None):
        value = dma_bits(0xE5CF, self.address, 4, 4, value)
        return(value)
    ## PSYS debounce assert exponent
    def Exponent(self, value = None):
        value = dma_bits(0xE5CF, self.address, 4, 0, value)
        return(value)

###################################################################
## Extended capability 1 register ch3 (not used in VR13.HC)
###################################################################
class svidExtCap1Lp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5D0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidExtCap1Lp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5D0, None)
            self.aPerBitIn = (self.reg_value >> 5) & 0x7
            self.wPerBit = (self.reg_value >> 2) & 0x7
            self.aPerBit = self.reg_value & 0x3

    def read_object(self):
        return(self.svidExtCap1Lp3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.aPerBitIn & 0x7) << 5)
        reg = (reg & 0xE3) + ((register_object.wPerBit & 0x7) << 2)
        reg = (reg & 0xFC) + (register_object.aPerBit & 0x3)
        dma(self.address, 0xE5D0, reg)
    ## Curr In LSB WEIRD 0-7 = 1,2,4, 1/2,1/4,1/8,1/16,1/32 Amps
    def aPerBitIn(self, value = None):
        value = dma_bits(0xE5D0, self.address, 3, 5, value)
        return(value)
    ## Pow Out 1,2,4,8; In 2,4,8,16 Watts
    def wPerBit(self, value = None):
        value = dma_bits(0xE5D0, self.address, 3, 2, value)
        return(value)
    ## Curr Out 1,2,4,8 Amps
    def aPerBit(self, value = None):
        value = dma_bits(0xE5D0, self.address, 2, 0, value)
        return(value)

###################################################################
## Extended capability 2 register (not used in VR13.HC)
###################################################################
class svidExtCap2Lp3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5D1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidExtCap2Lp3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5D1, None)
            self.maxPs = (self.reg_value >> 4) & 0xF
            self.ps4Supp = (self.reg_value >> 3) & 0x1
            self.ps3Supp = (self.reg_value >> 2) & 0x1
            self.ps2Supp = (self.reg_value >> 1) & 0x1
            self.ps1Supp = self.reg_value & 0x1

    def read_object(self):
        return(self.svidExtCap2Lp3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.maxPs & 0xF) << 4)
        reg = (reg & 0xF7) + ((register_object.ps4Supp & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ps3Supp & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ps2Supp & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ps1Supp & 0x1)
        dma(self.address, 0xE5D1, reg)
    ## Max supported power state
    def maxPs(self, value = None):
        value = dma_bits(0xE5D1, self.address, 4, 4, value)
        return(value)
    ## PS4 supported (near off)
    def ps4Supp(self, value = None):
        value = dma_bits(0xE5D1, self.address, 1, 3, value)
        return(value)
    ## PS3 supported (ultra low pow)
    def ps3Supp(self, value = None):
        value = dma_bits(0xE5D1, self.address, 1, 2, value)
        return(value)
    ## PS2 supported (very low pow)
    def ps2Supp(self, value = None):
        value = dma_bits(0xE5D1, self.address, 1, 1, value)
        return(value)
    ## PS1 supported (low pow)
    def ps1Supp(self, value = None):
        value = dma_bits(0xE5D1, self.address, 1, 0, value)
        return(value)

###################################################################
## Digital output status
###################################################################
class digOutStatus3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5D6, value)
        return(value)


###################################################################
## PSYS count config register
###################################################################
class svidExpAccuracy_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidExpAccuracy_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5F0, None)
            self.threshold = (self.reg_value >> 4) & 0xF
            self.telemetry = self.reg_value & 0xF

    def read_object(self):
        return(self.svidExpAccuracy_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.threshold & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.telemetry & 0xF)
        dma(self.address, 0xE5F0, reg)
    ## Number of bit of accuracy for Psys threshold
    def threshold(self, value = None):
        value = dma_bits(0xE5F0, self.address, 4, 4, value)
        return(value)
    ## Number of bit of accuracy for telemetry
    def telemetry(self, value = None):
        value = dma_bits(0xE5F0, self.address, 4, 0, value)
        return(value)

###################################################################
## SVID output current telemetry low byte register for IMVP9.1 VCC_AUX
###################################################################
class svidIoutL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F1, value)
        return(value)


###################################################################
## SVID input current telemetry register low byte
###################################################################
class svidIinL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F4, value)
        return(value)


###################################################################
## SVID input voltage telemetry register low byte
###################################################################
class svidVinL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F5, value)
        return(value)


###################################################################
## SVID input power telemetry low byte
###################################################################
class svidPinL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F6, value)
        return(value)


###################################################################
## PSYS critical level low byte register
###################################################################
class psysCritLvlL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F7, value)
        return(value)


###################################################################
## PSYS warn 2 level low byte register
###################################################################
class psysWarn2LvlL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F8, value)
        return(value)


###################################################################
## PSYS warn 1 level low byte register
###################################################################
class psysWarn1LvlL3_class(object):
    def __init__(self, address):
        self.interface = 'svidPsys'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE5F9, value)
        return(value)


###################################################################
## 
###################################################################
class chXCtl_class(object):
    def __init__(self, address):
        self.interface = ''
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE700, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chXCtl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE700, None)
            self.manTelPsysEnable = (self.reg_value >> 27) & 0x1
            self.manDllEnable = (self.reg_value >> 26) & 0x1
            self.manBgEnable = (self.reg_value >> 25) & 0x1
            self.manOscEnable = (self.reg_value >> 24) & 0x1
            self.telCompEnable = (self.reg_value >> 23) & 0x1
            self.isen3CompEnable = (self.reg_value >> 22) & 0x1
            self.isen2CompEnable = (self.reg_value >> 21) & 0x1
            self.isen1CompEnable = (self.reg_value >> 20) & 0x1
            self.isen0CompEnable = (self.reg_value >> 19) & 0x1
            self.vsen2CompEnable = (self.reg_value >> 18) & 0x1
            self.vsen1CompEnable = (self.reg_value >> 17) & 0x1
            self.vsen0CompEnable = (self.reg_value >> 16) & 0x1
            self.telDigEnable = (self.reg_value >> 15) & 0x1
            self.isen3DigEnable = (self.reg_value >> 14) & 0x1
            self.isen2DigEnable = (self.reg_value >> 13) & 0x1
            self.isen1DigEnable = (self.reg_value >> 12) & 0x1
            self.isen0DigEnable = (self.reg_value >> 11) & 0x1
            self.vsen2DigEnable = (self.reg_value >> 10) & 0x1
            self.vsen1DigEnable = (self.reg_value >> 9) & 0x1
            self.vsen0DigEnable = (self.reg_value >> 8) & 0x1
            self.telAdcEnable = (self.reg_value >> 7) & 0x1
            self.isen3AdcEnable = (self.reg_value >> 6) & 0x1
            self.isen2AdcEnable = (self.reg_value >> 5) & 0x1
            self.isen1AdcEnable = (self.reg_value >> 4) & 0x1
            self.isen0AdcEnable = (self.reg_value >> 3) & 0x1
            self.vsen2AdcEnable = (self.reg_value >> 2) & 0x1
            self.vsen1AdcEnable = (self.reg_value >> 1) & 0x1
            self.vsen0AdcEnable = self.reg_value & 0x1

    def read_object(self):
        return(self.chXCtl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFF) + ((register_object.manTelPsysEnable & 0x1) << 27)
        reg = (reg & 0xBFFFFFF) + ((register_object.manDllEnable & 0x1) << 26)
        reg = (reg & 0xDFFFFFF) + ((register_object.manBgEnable & 0x1) << 25)
        reg = (reg & 0xEFFFFFF) + ((register_object.manOscEnable & 0x1) << 24)
        reg = (reg & 0xF7FFFFF) + ((register_object.telCompEnable & 0x1) << 23)
        reg = (reg & 0xFBFFFFF) + ((register_object.isen3CompEnable & 0x1) << 22)
        reg = (reg & 0xFDFFFFF) + ((register_object.isen2CompEnable & 0x1) << 21)
        reg = (reg & 0xFEFFFFF) + ((register_object.isen1CompEnable & 0x1) << 20)
        reg = (reg & 0xFF7FFFF) + ((register_object.isen0CompEnable & 0x1) << 19)
        reg = (reg & 0xFFBFFFF) + ((register_object.vsen2CompEnable & 0x1) << 18)
        reg = (reg & 0xFFDFFFF) + ((register_object.vsen1CompEnable & 0x1) << 17)
        reg = (reg & 0xFFEFFFF) + ((register_object.vsen0CompEnable & 0x1) << 16)
        reg = (reg & 0xFFF7FFF) + ((register_object.telDigEnable & 0x1) << 15)
        reg = (reg & 0xFFFBFFF) + ((register_object.isen3DigEnable & 0x1) << 14)
        reg = (reg & 0xFFFDFFF) + ((register_object.isen2DigEnable & 0x1) << 13)
        reg = (reg & 0xFFFEFFF) + ((register_object.isen1DigEnable & 0x1) << 12)
        reg = (reg & 0xFFFF7FF) + ((register_object.isen0DigEnable & 0x1) << 11)
        reg = (reg & 0xFFFFBFF) + ((register_object.vsen2DigEnable & 0x1) << 10)
        reg = (reg & 0xFFFFDFF) + ((register_object.vsen1DigEnable & 0x1) << 9)
        reg = (reg & 0xFFFFEFF) + ((register_object.vsen0DigEnable & 0x1) << 8)
        reg = (reg & 0xFFFFF7F) + ((register_object.telAdcEnable & 0x1) << 7)
        reg = (reg & 0xFFFFFBF) + ((register_object.isen3AdcEnable & 0x1) << 6)
        reg = (reg & 0xFFFFFDF) + ((register_object.isen2AdcEnable & 0x1) << 5)
        reg = (reg & 0xFFFFFEF) + ((register_object.isen1AdcEnable & 0x1) << 4)
        reg = (reg & 0xFFFFFF7) + ((register_object.isen0AdcEnable & 0x1) << 3)
        reg = (reg & 0xFFFFFFB) + ((register_object.vsen2AdcEnable & 0x1) << 2)
        reg = (reg & 0xFFFFFFD) + ((register_object.vsen1AdcEnable & 0x1) << 1)
        reg = (reg & 0xFFFFFFE) + (register_object.vsen0AdcEnable & 0x1)
        dma(self.address, 0xE700, reg)
    ## Active high-speed PSYS comparators
    def manTelPsysEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 27, value)
        return(value)
    ## Active high enable for DLL
    def manDllEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 26, value)
        return(value)
    ## Active high enable for Switched cap Bandgap
    def manBgEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 25, value)
        return(value)
    ## Active high enable for Oscillator power
    def manOscEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 24, value)
        return(value)
    ## Active high enable for TEL ADC (anaTelAdc comparator)
    def telCompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 23, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen3CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 22, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen2CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 21, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen1CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 20, value)
        return(value)
    ## Active high enable for ISEN ADC0 (anaIsenAdc comparator)
    def isen0CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 19, value)
        return(value)
    ## Active high enable for VSEN ADC2 (anaVsenAdc2 comparator)
    def vsen2CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 18, value)
        return(value)
    ## Active high enable for VSEN ADC1 (anaVsenAdc1 comparator)
    def vsen1CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 17, value)
        return(value)
    ## Active high enable for VSEN ADC0 (anaVsenAdc0 comparator)
    def vsen0CompEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 16, value)
        return(value)
    ## Active high digital enable for TEL ADC (anaTelAdc controller)
    def telDigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 15, value)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen3DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 14, value)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen2DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 13, value)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen1DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 12, value)
        return(value)
    ## Active high digital enable for ISEN ADC0 (anaIsenAdc controller)
    def isen0DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 11, value)
        return(value)
    ## Active high digital enable for VSEN ADC2 (anaVsenAdc2 controller)
    def vsen2DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 10, value)
        return(value)
    ## Active high digital enable for VSEN ADC1 (anaVsenAdc1 controller)
    def vsen1DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 9, value)
        return(value)
    ## Active high digital enable for VSEN ADC0 (anaVsenAdc0 controller)
    def vsen0DigEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 8, value)
        return(value)
    ## Active high enable for TEL ADC (anaTelAdc module)
    def telAdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 7, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen3AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 6, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen2AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 5, value)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen1AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 4, value)
        return(value)
    ## Active high enable for ISEN ADC0 (anaIsenAdc module)
    def isen0AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 3, value)
        return(value)
    ## Active high enable for VSEN ADC2 (anaVsenAdc2 module)
    def vsen2AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 2, value)
        return(value)
    ## Active high enable for VSEN ADC1 (anaVsenAdc1 module)
    def vsen1AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 1, value)
        return(value)
    ## Active high enable for VSEN ADC0 (anaVsenAdc0 module)
    def vsen0AdcEnable(self, value = None):
        value = dma_bits(0xE700, self.address, 1, 0, value)
        return(value)

###################################################################
## Analog power enable register (rFACCONFIG1 used after bootup, or rSYSLOWPWR1 rSYSVLOWPWR1 in low power modes)
###################################################################
class pwrEn0_class(object):
    def __init__(self, address):
        self.interface = ''
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE701, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrEn0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE701, None)
            self.svcWakeupDisable = (self.reg_value >> 10) & 0x1
            self.vddioBufEn = (self.reg_value >> 9) & 0x1
            self.vddioUvEn = (self.reg_value >> 8) & 0x1
            self.svidBiasEn = (self.reg_value >> 7) & 0x1
            self.refBg2Pdn = (self.reg_value >> 6) & 0x1
            self.LdoPdn = (self.reg_value >> 5) & 0x1
            self.intTmp = (self.reg_value >> 4) & 0x1
            self.oscEnable = (self.reg_value >> 3) & 0x1
            self.currDistEn = (self.reg_value >> 2) & 0x1
            self.anaIinBufEn = (self.reg_value >> 1) & 0x1
            self.anaVinBufEn = self.reg_value & 0x1

    def read_object(self):
        return(self.pwrEn0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.svcWakeupDisable & 0x1) << 10)
        reg = (reg & 0x5FF) + ((register_object.vddioBufEn & 0x1) << 9)
        reg = (reg & 0x6FF) + ((register_object.vddioUvEn & 0x1) << 8)
        reg = (reg & 0x77F) + ((register_object.svidBiasEn & 0x1) << 7)
        reg = (reg & 0x7BF) + ((register_object.refBg2Pdn & 0x1) << 6)
        reg = (reg & 0x7DF) + ((register_object.LdoPdn & 0x1) << 5)
        reg = (reg & 0x7EF) + ((register_object.intTmp & 0x1) << 4)
        reg = (reg & 0x7F7) + ((register_object.oscEnable & 0x1) << 3)
        reg = (reg & 0x7FB) + ((register_object.currDistEn & 0x1) << 2)
        reg = (reg & 0x7FD) + ((register_object.anaIinBufEn & 0x1) << 1)
        reg = (reg & 0x7FE) + (register_object.anaVinBufEn & 0x1)
        dma(self.address, 0xE701, reg)
    ## 0 - Automatic SVID/SVI3 wakeup circut enabled (default) 1 - Disable the Automatic SVID/SVI3 powerdown, force svidBiasEn=1
    def svcWakeupDisable(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 10, value)
        return(value)
    ## 0 - Disable VDDIO Buffer, 1 - Enable VDDIO Buffer
    def vddioBufEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 9, value)
        return(value)
    ## 0 - Disable VDDIO UV Comparator, 1 - Enable VDDIO UV Comparator
    def vddioUvEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 8, value)
        return(value)
    ## Active high enable for bias currents and reference voltage for SVID pad cells; Set low for IDDQ testing
    def svidBiasEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 7, value)
        return(value)
    ## Active high power down (active low enable) for secondary bandgap (anaComRefBg2 module)
    def refBg2Pdn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 6, value)
        return(value)
    ## Active high power down (active low enable) for LDO regulator (anaLdo module)
    def LdoPdn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 5, value)
        return(value)
    ## Active high enable for internal temperature sensor (anaComRefTmp module)
    def intTmp(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 4, value)
        return(value)
    ## Active high enable for oscillator (anaComClkOsc module)
    def oscEnable(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 3, value)
        return(value)
    ## Enable the current distributor
    def currDistEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 2, value)
        return(value)
    ## Enable the buffer for the IIN sense
    def anaIinBufEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 1, value)
        return(value)
    ## Enable the buffer for the VIN sense
    def anaVinBufEn(self, value = None):
        value = dma_bits(0xE701, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class comRefTrim_class(object):
    def __init__(self, address):
        self.interface = ''
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xE702, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class comRefTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE702, None)
            self.ldoUse3p3Only = (self.reg_value >> 19) & 0x1
            self.ldoUse1p8OvRide = (self.reg_value >> 18) & 0x1
            self.ldoTrim = (self.reg_value >> 13) & 0x1F
            self.currDistTrim = (self.reg_value >> 7) & 0x3F
            self.refIbgTrim = (self.reg_value >> 3) & 0xF
            self.refBg2AzEn = (self.reg_value >> 2) & 0x1
            self.refBg2Bg1Z = (self.reg_value >> 1) & 0x1
            self.refBypFilt = self.reg_value & 0x1

    def read_object(self):
        return(self.comRefTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFF) + ((register_object.ldoUse3p3Only & 0x1) << 19)
        reg = (reg & 0xBFFFF) + ((register_object.ldoUse1p8OvRide & 0x1) << 18)
        reg = (reg & 0xC1FFF) + ((register_object.ldoTrim & 0x1F) << 13)
        reg = (reg & 0xFE07F) + ((register_object.currDistTrim & 0x3F) << 7)
        reg = (reg & 0xFFF87) + ((register_object.refIbgTrim & 0xF) << 3)
        reg = (reg & 0xFFFFB) + ((register_object.refBg2AzEn & 0x1) << 2)
        reg = (reg & 0xFFFFD) + ((register_object.refBg2Bg1Z & 0x1) << 1)
        reg = (reg & 0xFFFFE) + (register_object.refBypFilt & 0x1)
        dma(self.address, 0xE702, reg)
    ## 1: Force LDO for 1.2V supply to use 3.3V as source voltage.<br>0: (default} Allow 1.8V LDO mode if present
    def ldoUse3p3Only(self, value = None):
        value = dma_bits(0xE702, self.address, 1, 19, value)
        return(value)
    ## 1: Force LDO for 1.2V supply to use 1.8V source voltage.<br>0: (default) Allow automatic control of 1.8V mode
    def ldoUse1p8OvRide(self, value = None):
        value = dma_bits(0xE702, self.address, 1, 18, value)
        return(value)
    def ldoTrim(self, value = None):
        value = dma_bits(0xE702, self.address, 5, 13, value)
        return(value)
    def currDistTrim(self, value = None):
        value = dma_bits(0xE702, self.address, 6, 7, value)
        return(value)
    def refIbgTrim(self, value = None):
        value = dma_bits(0xE702, self.address, 4, 3, value)
        return(value)
    def refBg2AzEn(self, value = None):
        value = dma_bits(0xE702, self.address, 1, 2, value)
        return(value)
    def refBg2Bg1Z(self, value = None):
        value = dma_bits(0xE702, self.address, 1, 1, value)
        return(value)
    def refBypFilt(self, value = None):
        value = dma_bits(0xE702, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class otpCtrl1_class(object):
    def __init__(self, address):
        self.interface = ''
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE703, value)
        return(value)


###################################################################
## See MBIRD-112
###################################################################
class comClkTrim1_class(object):
    def __init__(self, address):
        self.interface = ''
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE704, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class comClkTrim1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE704, None)
            self.oscSpareTrim = (self.reg_value >> 14) & 0x1
            self.oscVcmTrim = (self.reg_value >> 10) & 0xF
            self.oscRTrim = (self.reg_value >> 9) & 0x1
            self.oscTrim = self.reg_value & 0x1FF

    def read_object(self):
        return(self.comClkTrim1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFF) + ((register_object.oscSpareTrim & 0x1) << 14)
        reg = (reg & 0x43FF) + ((register_object.oscVcmTrim & 0xF) << 10)
        reg = (reg & 0x7DFF) + ((register_object.oscRTrim & 0x1) << 9)
        reg = (reg & 0x7E00) + (register_object.oscTrim & 0x1FF)
        dma(self.address, 0xE704, reg)
    ## Spare Factory oscillator trim
    def oscSpareTrim(self, value = None):
        value = dma_bits(0xE704, self.address, 1, 14, value)
        return(value)
    ## Factory trim for Osc Vcm <BR>NOTE: MSB is inverted
    def oscVcmTrim(self, value = None):
        value = dma_bits(0xE704, self.address, 4, 10, value)
        return(value)
    ## Factory trim oscillator Resistor to 25 MHz
    def oscRTrim(self, value = None):
        value = dma_bits(0xE704, self.address, 1, 9, value)
        return(value)
    ## Factory trim oscillator to 25 MHz
    def oscTrim(self, value = None):
        value = dma_bits(0xE704, self.address, 9, 0, value)
        return(value)

###################################################################
## 
###################################################################
class extTmpTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xE705, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extTmpTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE705, None)
            self.dllBuf1p8Sel = (self.reg_value >> 8) & 0x1
            self.iSenBuf1p8Sel = (self.reg_value >> 7) & 0x1
            self.vSenBuf1p8Sel = (self.reg_value >> 6) & 0x1
            self.telBuf1p8Sel = (self.reg_value >> 5) & 0x1
            self.anaAddrCfgEn = (self.reg_value >> 4) & 0x1
            self.extTempTrim = self.reg_value & 0xF

    def read_object(self):
        return(self.extTmpTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.dllBuf1p8Sel & 0x1) << 8)
        reg = (reg & 0x17F) + ((register_object.iSenBuf1p8Sel & 0x1) << 7)
        reg = (reg & 0x1BF) + ((register_object.vSenBuf1p8Sel & 0x1) << 6)
        reg = (reg & 0x1DF) + ((register_object.telBuf1p8Sel & 0x1) << 5)
        reg = (reg & 0x1EF) + ((register_object.anaAddrCfgEn & 0x1) << 4)
        reg = (reg & 0x1F0) + (register_object.extTempTrim & 0xF)
        dma(self.address, 0xE705, reg)
    ## Sel DLL LDO power supply, if 0=> 3.3V  if1=>1.8V
    def dllBuf1p8Sel(self, value = None):
        value = dma_bits(0xE705, self.address, 1, 8, value)
        return(value)
    ## Master enable for anaAddrCfg
    def iSenBuf1p8Sel(self, value = None):
        value = dma_bits(0xE705, self.address, 1, 7, value)
        return(value)
    ## select 1.8V as source for vSen buffer for low power if 1, otherwise use 3.3V
    def vSenBuf1p8Sel(self, value = None):
        value = dma_bits(0xE705, self.address, 1, 6, value)
        return(value)
    ## select 1.8V as source for tel buffer for low power if 1, otherwise use 3.3V
    def telBuf1p8Sel(self, value = None):
        value = dma_bits(0xE705, self.address, 1, 5, value)
        return(value)
    ## Master enable for anaAddrCfg
    def anaAddrCfgEn(self, value = None):
        value = dma_bits(0xE705, self.address, 1, 4, value)
        return(value)
    def extTempTrim(self, value = None):
        value = dma_bits(0xE705, self.address, 4, 0, value)
        return(value)

###################################################################
## Spec MBIRD-138
###################################################################
class comRefBgSwC_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE706, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class comRefBgSwC_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE706, None)
            self.forceClkLo = (self.reg_value >> 31) & 0x1
            self.forceClkHi = (self.reg_value >> 30) & 0x1
            self.selOne = (self.reg_value >> 29) & 0x1
            self.enSampClk = (self.reg_value >> 28) & 0x1
            self.swBgSel = (self.reg_value >> 27) & 0x1
            self.enVbg = (self.reg_value >> 26) & 0x1
            self.swSelLfsr = (self.reg_value >> 25) & 0x1
            self.swFstStlLen = (self.reg_value >> 22) & 0x7
            self.swZeroGainSel = (self.reg_value >> 18) & 0xF
            self.swGainAttnSel = (self.reg_value >> 14) & 0xF
            self.swpTatSel = (self.reg_value >> 12) & 0x3
            self.swiBiasSel = (self.reg_value >> 7) & 0x1F
            self.swPhSel = (self.reg_value >> 4) & 0x7
            self.swPhSelOvr = (self.reg_value >> 3) & 0x1
            self.swClkSel = (self.reg_value >> 1) & 0x3
            self.swEn = self.reg_value & 0x1

    def read_object(self):
        return(self.comRefBgSwC_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.forceClkLo & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.forceClkHi & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.selOne & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.enSampClk & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.swBgSel & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.enVbg & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.swSelLfsr & 0x1) << 25)
        reg = (reg & 0xFE3FFFFF) + ((register_object.swFstStlLen & 0x7) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.swZeroGainSel & 0xF) << 18)
        reg = (reg & 0xFFFC3FFF) + ((register_object.swGainAttnSel & 0xF) << 14)
        reg = (reg & 0xFFFFCFFF) + ((register_object.swpTatSel & 0x3) << 12)
        reg = (reg & 0xFFFFF07F) + ((register_object.swiBiasSel & 0x1F) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.swPhSel & 0x7) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.swPhSelOvr & 0x1) << 3)
        reg = (reg & 0xFFFFFFF9) + ((register_object.swClkSel & 0x3) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.swEn & 0x1)
        dma(self.address, 0xE706, reg)
    ## Force swBg clk Hi ph1, gain=1
    def forceClkLo(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 31, value)
        return(value)
    ## Force swBg clk Hi ph2, gain=9
    def forceClkHi(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 30, value)
        return(value)
    ## Force bg to select only 1 current source
    def selOne(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 29, value)
        return(value)
    ## If set, sync swBg clock with the vSen sample clock
    def enSampClk(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 28, value)
        return(value)
    ## If set, use swBg output instead of Vbg, if this is 0, enVbg should be 1
    def swBgSel(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 27, value)
        return(value)
    ## If set, current from anaComIbg directly feeds resistor to create Vbg
    def enVbg(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 26, value)
        return(value)
    ## Select LFSR as DEM source instead of counter
    def swSelLfsr(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 25, value)
        return(value)
    ## fast settle count 0-None 1-3 2-7 3-15 4:7-31
    def swFstStlLen(self, value = None):
        value = dma_bits(0xE706, self.address, 3, 22, value)
        return(value)
    ## Trim for vB gain (temp comp)
    def swZeroGainSel(self, value = None):
        value = dma_bits(0xE706, self.address, 4, 18, value)
        return(value)
    ## Trim for output voltage level
    def swGainAttnSel(self, value = None):
        value = dma_bits(0xE706, self.address, 4, 14, value)
        return(value)
    ## NOT USED ... analog spares ... pTat current selection for swBg
    def swpTatSel(self, value = None):
        value = dma_bits(0xE706, self.address, 2, 12, value)
        return(value)
    ## NOT USED ...  bits 4:1 are analog spares, bit 0 doesn't go to ana Bias current trim for swBg
    def swiBiasSel(self, value = None):
        value = dma_bits(0xE706, self.address, 5, 7, value)
        return(value)
    ## Manual phase select
    def swPhSel(self, value = None):
        value = dma_bits(0xE706, self.address, 3, 4, value)
        return(value)
    ## Manual phase select Override use swPhSel to determine phase
    def swPhSelOvr(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 3, value)
        return(value)
    ## Sel clkTs divider for swCBg<BR> 0: /2 (1.33us period)<BR> 1: /4 (2.66us period)<BR> 2: /8 (5.3us period)<BR> 3: (11.992us period--1.33us recharge--10.66us fstStl amp drive)
    def swClkSel(self, value = None):
        value = dma_bits(0xE706, self.address, 2, 1, value)
        return(value)
    ## Switched Cap Bandgap Analog Power Enable
    def swEn(self, value = None):
        value = dma_bits(0xE706, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class tmpTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xE707, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tmpTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE707, None)
            self.oscLdoDisPwrMgt = (self.reg_value >> 19) & 0x1
            self.oscLdoEn = (self.reg_value >> 18) & 0x1
            self.buff18FaultSel = (self.reg_value >> 16) & 0x3
            self.prgSpareTrim = (self.reg_value >> 12) & 0xF
            self.prgTmonTrim = (self.reg_value >> 9) & 0x7
            self.intTempOffset = (self.reg_value >> 5) & 0xF
            self.intTempTrim = (self.reg_value >> 1) & 0xF
            self.intTempEn = self.reg_value & 0x1

    def read_object(self):
        return(self.tmpTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFF) + ((register_object.oscLdoDisPwrMgt & 0x1) << 19)
        reg = (reg & 0xBFFFF) + ((register_object.oscLdoEn & 0x1) << 18)
        reg = (reg & 0xCFFFF) + ((register_object.buff18FaultSel & 0x3) << 16)
        reg = (reg & 0xF0FFF) + ((register_object.prgSpareTrim & 0xF) << 12)
        reg = (reg & 0xFF1FF) + ((register_object.prgTmonTrim & 0x7) << 9)
        reg = (reg & 0xFFE1F) + ((register_object.intTempOffset & 0xF) << 5)
        reg = (reg & 0xFFFE1) + ((register_object.intTempTrim & 0xF) << 1)
        reg = (reg & 0xFFFFE) + (register_object.intTempEn & 0x1)
        dma(self.address, 0xE707, reg)
    ## 0: Only enable LDO when telAdc is enabled 1: Enable LDO all the time
    def oscLdoDisPwrMgt(self, value = None):
        value = dma_bits(0xE707, self.address, 1, 19, value)
        return(value)
    ## Enables Osc LDO
    def oscLdoEn(self, value = None):
        value = dma_bits(0xE707, self.address, 1, 18, value)
        return(value)
    ## See MBIRD-1775 <BR> 0: extTmpTrim directly controls buf1p8Sel signals <BR> 1: Hardware latches the !AVDD18Valid signal and automatically selects 3.3V for the buf1p8Sel signals ... only when firmware sets the ana1Shot.clearAVDD18Valid can the latch be cleared and the buf1p8Sel follow the extTmpTrim register settings.  <BR> 2/3: Hardware uses the !AVDD18Valid signal directly and automatically selects 3.3V for the buf1p8Sel signals ... when AVDD18Valid=1 the buf1p8Sel follows the extTmpTrim register settings.
    def buff18FaultSel(self, value = None):
        value = dma_bits(0xE707, self.address, 2, 16, value)
        return(value)
    ## spare bits for prg pad adjustments
    def prgSpareTrim(self, value = None):
        value = dma_bits(0xE707, self.address, 4, 12, value)
        return(value)
    def prgTmonTrim(self, value = None):
        value = dma_bits(0xE707, self.address, 3, 9, value)
        return(value)
    ## bits [1:0] used to adjust the room temperature sense voltage and the gain <BR> bits[3:2] are a coarse offset and should be set to 0
    def intTempOffset(self, value = None):
        value = dma_bits(0xE707, self.address, 4, 5, value)
        return(value)
    ## used to adjust the room temperature sense voltage and the gain
    def intTempTrim(self, value = None):
        value = dma_bits(0xE707, self.address, 4, 1, value)
        return(value)
    ## Set to 1 to over-ride wakeup from telemetry adc controller
    def intTempEn(self, value = None):
        value = dma_bits(0xE707, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dllClkTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 25

    def __call__(self, value = None):
        value = dma(self.address, 0xE709, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dllClkTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE709, None)
            self.cSelTrim = (self.reg_value >> 23) & 0x3
            self.faultEn = (self.reg_value >> 22) & 0x1
            self.dataEn = (self.reg_value >> 21) & 0x1
            self.dataSel1 = (self.reg_value >> 19) & 0x3
            self.dataSel0 = (self.reg_value >> 17) & 0x3
            self.selDelOR = (self.reg_value >> 16) & 0x1
            self.selDelORval = (self.reg_value >> 8) & 0xFF
            self.loopBackEn = (self.reg_value >> 6) & 0x3
            self.findEdge = (self.reg_value >> 4) & 0x3
            self.rTrim = (self.reg_value >> 2) & 0x3
            self.ldoEn = (self.reg_value >> 1) & 0x1
            self.enable = self.reg_value & 0x1

    def read_object(self):
        return(self.dllClkTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.cSelTrim & 0x3) << 23)
        reg = (reg & 0x1BFFFFF) + ((register_object.faultEn & 0x1) << 22)
        reg = (reg & 0x1DFFFFF) + ((register_object.dataEn & 0x1) << 21)
        reg = (reg & 0x1E7FFFF) + ((register_object.dataSel1 & 0x3) << 19)
        reg = (reg & 0x1F9FFFF) + ((register_object.dataSel0 & 0x3) << 17)
        reg = (reg & 0x1FEFFFF) + ((register_object.selDelOR & 0x1) << 16)
        reg = (reg & 0x1FF00FF) + ((register_object.selDelORval & 0xFF) << 8)
        reg = (reg & 0x1FFFF3F) + ((register_object.loopBackEn & 0x3) << 6)
        reg = (reg & 0x1FFFFCF) + ((register_object.findEdge & 0x3) << 4)
        reg = (reg & 0x1FFFFF3) + ((register_object.rTrim & 0x3) << 2)
        reg = (reg & 0x1FFFFFD) + ((register_object.ldoEn & 0x1) << 1)
        reg = (reg & 0x1FFFFFE) + (register_object.enable & 0x1)
        dma(self.address, 0xE709, reg)
    ## voltCo Trim for DLL
    def cSelTrim(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 23, value)
        return(value)
    ## enable feedforward fault control to Adc's, not currently implemented
    def faultEn(self, value = None):
        value = dma_bits(0xE709, self.address, 1, 22, value)
        return(value)
    ## if set, enable debug flops/data out for debug (selDel, counts, etc)
    def dataEn(self, value = None):
        value = dma_bits(0xE709, self.address, 1, 21, value)
        return(value)
    ## for dllData[15:8] 0-selDel0  1-selDel1  2-count0/valid0/fault0  3-count1/valid1/fault1
    def dataSel1(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 19, value)
        return(value)
    ## for dllData[7:0] 0-selDel0  1-selDel1  2-count0/valid0/fault0  3-count1/valid1/fault1
    def dataSel0(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 17, value)
        return(value)
    ## use override value instead of feedback loop for DAC control
    def selDelOR(self, value = None):
        value = dma_bits(0xE709, self.address, 1, 16, value)
        return(value)
    ## DLL DAC override value 0-fastest  255-slowest
    def selDelORval(self, value = None):
        value = dma_bits(0xE709, self.address, 8, 8, value)
        return(value)
    ## force continuous loopback for clkTest mode Bit0 - Even DLL Bit1 - Odd DLL <BR> Also selects which signal is sent to DLL ATB: 0-None, 1-Even DutyCycle, 2/3-Odd DutyCycle
    def loopBackEn(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 6, value)
        return(value)
    ## 5:4  0-after lock, not toggle  1-toggle on edge 2-toggle with timer 3-toggle ever other timer
    def findEdge(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 4, value)
        return(value)
    ## 3:2 DLL freq trim - 0-Very fast  1-Typ PWM (1.95-2.5ns)   2-Typ ADC (3-4ns)  3-Fast/Typ corner ADC (very slow)
    def rTrim(self, value = None):
        value = dma_bits(0xE709, self.address, 2, 2, value)
        return(value)
    ## 1 DLL Ldo Enable
    def ldoEn(self, value = None):
        value = dma_bits(0xE709, self.address, 1, 1, value)
        return(value)
    ## 0  ADC DLL enable
    def enable(self, value = None):
        value = dma_bits(0xE709, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dllPwmTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 30

    def __call__(self, value = None):
        value = dma(self.address, 0xE70A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dllPwmTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70A, None)
            self.calRate = (self.reg_value >> 27) & 0x7
            self.cSelTrim = (self.reg_value >> 25) & 0x3
            self.pwmTrim2 = (self.reg_value >> 24) & 0x1
            self.pwmTrim = (self.reg_value >> 23) & 0x1
            self.ignoreLsb = (self.reg_value >> 22) & 0x1
            self.dataEn = (self.reg_value >> 21) & 0x1
            self.dataSel1 = (self.reg_value >> 19) & 0x3
            self.dataSel0 = (self.reg_value >> 17) & 0x3
            self.selDelOR = (self.reg_value >> 16) & 0x1
            self.selDelORval = (self.reg_value >> 8) & 0xFF
            self.pwmClkRun = (self.reg_value >> 7) & 0x1
            self.loopBackEn = (self.reg_value >> 5) & 0x3
            self.findEdge = (self.reg_value >> 3) & 0x3
            self.rTrim = (self.reg_value >> 1) & 0x3
            self.enable = self.reg_value & 0x1

    def read_object(self):
        return(self.dllPwmTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFF) + ((register_object.calRate & 0x7) << 27)
        reg = (reg & 0x39FFFFFF) + ((register_object.cSelTrim & 0x3) << 25)
        reg = (reg & 0x3EFFFFFF) + ((register_object.pwmTrim2 & 0x1) << 24)
        reg = (reg & 0x3F7FFFFF) + ((register_object.pwmTrim & 0x1) << 23)
        reg = (reg & 0x3FBFFFFF) + ((register_object.ignoreLsb & 0x1) << 22)
        reg = (reg & 0x3FDFFFFF) + ((register_object.dataEn & 0x1) << 21)
        reg = (reg & 0x3FE7FFFF) + ((register_object.dataSel1 & 0x3) << 19)
        reg = (reg & 0x3FF9FFFF) + ((register_object.dataSel0 & 0x3) << 17)
        reg = (reg & 0x3FFEFFFF) + ((register_object.selDelOR & 0x1) << 16)
        reg = (reg & 0x3FFF00FF) + ((register_object.selDelORval & 0xFF) << 8)
        reg = (reg & 0x3FFFFF7F) + ((register_object.pwmClkRun & 0x1) << 7)
        reg = (reg & 0x3FFFFF9F) + ((register_object.loopBackEn & 0x3) << 5)
        reg = (reg & 0x3FFFFFE7) + ((register_object.findEdge & 0x3) << 3)
        reg = (reg & 0x3FFFFFF9) + ((register_object.rTrim & 0x3) << 1)
        reg = (reg & 0x3FFFFFFE) + (register_object.enable & 0x1)
        dma(self.address, 0xE70A, reg)
    ## cal rate Rate to force dll check if no PWM's have come in for more than: 0:Always 1:8clkTs 2:16clkTs 3:64clkTs 4:256clkTs 5:512clkTs 6:1023clkTs 7:Never)
    def calRate(self, value = None):
        value = dma_bits(0xE70A, self.address, 3, 27, value)
        return(value)
    ## voltCo Trim for DLL
    def cSelTrim(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 25, value)
        return(value)
    ## extra bit
    def pwmTrim2(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 24, value)
        return(value)
    ## extra bit
    def pwmTrim(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 23, value)
        return(value)
    ## don't flip the clock for PWM's ... essentially 5bit instead of 6bit
    def ignoreLsb(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 22, value)
        return(value)
    ## 21-if set, enable debug flops/data out for debug (selDel, counts, etc)
    def dataEn(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 21, value)
        return(value)
    ## 20:19-for dllData[15:8] 0-selDel0  1-selDel1  2-count0/valid0/fault0  3-count1/valid1/fault1
    def dataSel1(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 19, value)
        return(value)
    ## 18:17-for dllData[7:0] 0-selDel0  1-selDel1  2-count0/valid0/fault0  3-count1/valid1/fault1
    def dataSel0(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 17, value)
        return(value)
    ## 16-use override value instead of feedback loop for DAC control
    def selDelOR(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 16, value)
        return(value)
    ## 15:8- DLL DAC override value 0-fastest  255-slowest
    def selDelORval(self, value = None):
        value = dma_bits(0xE70A, self.address, 8, 8, value)
        return(value)
    ## 7 -PWM DLL to run every cycle independent of pwmDataChange
    def pwmClkRun(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 7, value)
        return(value)
    ## 6:5 -force continuous loopback for clkTest mode Bit0 - Even DLL Bit1 - Odd DLL <BR> Also selects which signal is sent to DLL ATB: 0-None, 1-Even DutyCycle, 2/3-Odd DutyCycle
    def loopBackEn(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 5, value)
        return(value)
    ## 4:3 0-after lock, not toggle  1-toggle on edge 2-toggle with timer 3-toggle ever other timer
    def findEdge(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 3, value)
        return(value)
    ## 2:1- DLL freq trim - 0-Very fast  1-Typ PWM (1.95-2.5ns)   2-Typ ADC (3-4ns)  3-Fast/Typ corner ADC (very slow)
    def rTrim(self, value = None):
        value = dma_bits(0xE70A, self.address, 2, 1, value)
        return(value)
    ## 0- PWM DLL enable
    def enable(self, value = None):
        value = dma_bits(0xE70A, self.address, 1, 0, value)
        return(value)

###################################################################
## this register allows readback of dll Status bits
###################################################################
class dllData_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE70B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dllData_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70B, None)
            self.dllPwmData = (self.reg_value >> 16) & 0xFFFF
            self.dllClkData = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.dllData_Object(self.address))

    ## Readback Pwm Clk Dll data
    def dllPwmData(self):
        value = dma_bits(0xE70B, self.address, 16, 16, None)
        return(value)
    ## Readback ADC Clk Dll data
    def dllClkData(self):
        value = dma_bits(0xE70B, self.address, 16, 0, None)
        return(value)

###################################################################
## 
###################################################################
class vinIinFiltTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE70C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vinIinFiltTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70C, None)
            self.spare = (self.reg_value >> 15) & 0x1
            self.iinBufBypass = (self.reg_value >> 14) & 0x1
            self.iBufBypass = (self.reg_value >> 13) & 0x1
            self.vBufBypass = (self.reg_value >> 12) & 0x1
            self.vinBufBypass = (self.reg_value >> 11) & 0x1
            self.filtBufPEn = (self.reg_value >> 10) & 0x1
            self.filtBiasCnvt = (self.reg_value >> 8) & 0x3
            self.filtBiasCmp = (self.reg_value >> 6) & 0x3
            self.filtLPFvBuf = (self.reg_value >> 4) & 0x3
            self.filtLPFiBuf = (self.reg_value >> 2) & 0x3
            self.vinFiltBufEn = (self.reg_value >> 1) & 0x1
            self.iinFiltBufEn = self.reg_value & 0x1

    def read_object(self):
        return(self.vinIinFiltTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.spare & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.iinBufBypass & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.iBufBypass & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.vBufBypass & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.vinBufBypass & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.filtBufPEn & 0x1) << 10)
        reg = (reg & 0xFCFF) + ((register_object.filtBiasCnvt & 0x3) << 8)
        reg = (reg & 0xFF3F) + ((register_object.filtBiasCmp & 0x3) << 6)
        reg = (reg & 0xFFCF) + ((register_object.filtLPFvBuf & 0x3) << 4)
        reg = (reg & 0xFFF3) + ((register_object.filtLPFiBuf & 0x3) << 2)
        reg = (reg & 0xFFFD) + ((register_object.vinFiltBufEn & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.iinFiltBufEn & 0x1)
        dma(self.address, 0xE70C, reg)
    ## Not currently used in revD
    def spare(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 15, value)
        return(value)
    ## Bypass the input buffer in the PSYS path. THIS BIT IS NEW IN REV D
    def iinBufBypass(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 14, value)
        return(value)
    ## Bypass the ADC buffer in the PSYS path
    def iBufBypass(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 13, value)
        return(value)
    ## Bypass the ADC buffer in the VSYS path
    def vBufBypass(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 12, value)
        return(value)
    ## Bypass the input buffer in the VSYS path
    def vinBufBypass(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 11, value)
        return(value)
    ## Force the positive ADC buffers in the VSYS and PSYS conversion paths on
    def filtBufPEn(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 10, value)
        return(value)
    ## Bias current for ADC buffers in the conversion/antiAliased VSYS and PSYS paths. <BR> 0 - 2.5 uA <BR> 1 - 3.0 uA <BR> 2 - 3.5 uA <BR> 3 - 4.0 uA
    def filtBiasCnvt(self, value = None):
        value = dma_bits(0xE70C, self.address, 2, 8, value)
        return(value)
    ## Bias current for ADC buffers in the compare VSYS and PSYS paths. <BR> 0 - 2.5 uA <BR> 1 - 3.0 uA <BR> 2 - 3.5 uA <BR> 3 - 4.0 uA
    def filtBiasCmp(self, value = None):
        value = dma_bits(0xE70C, self.address, 2, 6, value)
        return(value)
    ## 0 - 50.00 kHz <BR> 1 - 25.00 kHz <BR> 2 - 12.500 kHz <BR> 3 - 6.250 kHz
    def filtLPFvBuf(self, value = None):
        value = dma_bits(0xE70C, self.address, 2, 4, value)
        return(value)
    ## 0 - 25.00 kHz <BR> 1 - 12.50 kHz <BR> 2 - 6.250 kHz <BR> 3 - 3.125 kHz
    def filtLPFiBuf(self, value = None):
        value = dma_bits(0xE70C, self.address, 2, 2, value)
        return(value)
    ## 1=bypass UTC wakeup for VIN filt buffer
    def vinFiltBufEn(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 1, value)
        return(value)
    ## 1=bypass UTC wakeup for IIN filt buffer
    def iinFiltBufEn(self, value = None):
        value = dma_bits(0xE70C, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class svidTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xE70D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svidTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70D, None)
            self.svi3ZeroIqEn = (self.reg_value >> 12) & 0x1
            self.svicDetTrim = (self.reg_value >> 10) & 0x3
            self.configSvRef = (self.reg_value >> 8) & 0x3
            self.svidHyst = (self.reg_value >> 6) & 0x3
            self.enable2Config = (self.reg_value >> 4) & 0x3
            self.enable1Config = (self.reg_value >> 2) & 0x3
            self.enable0Config = self.reg_value & 0x3

    def read_object(self):
        return(self.svidTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.svi3ZeroIqEn & 0x1) << 12)
        reg = (reg & 0x13FF) + ((register_object.svicDetTrim & 0x3) << 10)
        reg = (reg & 0x1CFF) + ((register_object.configSvRef & 0x3) << 8)
        reg = (reg & 0x1F3F) + ((register_object.svidHyst & 0x3) << 6)
        reg = (reg & 0x1FCF) + ((register_object.enable2Config & 0x3) << 4)
        reg = (reg & 0x1FF3) + ((register_object.enable1Config & 0x3) << 2)
        reg = (reg & 0x1FFC) + (register_object.enable0Config & 0x3)
        dma(self.address, 0xE70D, reg)
    ## Enables optional Schmitt trigger for SVI3 mode
    def svi3ZeroIqEn(self, value = None):
        value = dma_bits(0xE70D, self.address, 1, 12, value)
        return(value)
    ## Threshold adjust for Low Power svicDet comparator
    def svicDetTrim(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 10, value)
        return(value)
    ## Threshold adjust for SVID in
    def configSvRef(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 8, value)
        return(value)
    ## Hysteresis adjust for SVID in comparator
    def svidHyst(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 6, value)
        return(value)
    ## Threshold adjust for Enable 2
    def enable2Config(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 4, value)
        return(value)
    ## Threshold adjust for Enable 1
    def enable1Config(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 2, value)
        return(value)
    ## Threshold adjust for Enable 0
    def enable0Config(self, value = None):
        value = dma_bits(0xE70D, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenMode_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xE70E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70E, None)
            self.autoTrack = (self.reg_value >> 19) & 0x1
            self.dithAddSel = (self.reg_value >> 18) & 0x1
            self.msbXsbError = (self.reg_value >> 15) & 0x7
            self.offTrackMode = (self.reg_value >> 13) & 0x3
            self.ditherCalc = (self.reg_value >> 12) & 0x1
            self.firMode = (self.reg_value >> 11) & 0x1
            self.iirCoef = (self.reg_value >> 8) & 0x7
            self.trackMode = (self.reg_value >> 6) & 0x3
            self.invMode = (self.reg_value >> 4) & 0x3
            self.demMode = (self.reg_value >> 2) & 0x3
            self.ditherMode = self.reg_value & 0x3

    def read_object(self):
        return(self.vSenMode_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFF) + ((register_object.autoTrack & 0x1) << 19)
        reg = (reg & 0xBFFFF) + ((register_object.dithAddSel & 0x1) << 18)
        reg = (reg & 0xC7FFF) + ((register_object.msbXsbError & 0x7) << 15)
        reg = (reg & 0xF9FFF) + ((register_object.offTrackMode & 0x3) << 13)
        reg = (reg & 0xFEFFF) + ((register_object.ditherCalc & 0x1) << 12)
        reg = (reg & 0xFF7FF) + ((register_object.firMode & 0x1) << 11)
        reg = (reg & 0xFF8FF) + ((register_object.iirCoef & 0x7) << 8)
        reg = (reg & 0xFFF3F) + ((register_object.trackMode & 0x3) << 6)
        reg = (reg & 0xFFFCF) + ((register_object.invMode & 0x3) << 4)
        reg = (reg & 0xFFFF3) + ((register_object.demMode & 0x3) << 2)
        reg = (reg & 0xFFFFC) + (register_object.ditherMode & 0x3)
        dma(self.address, 0xE70E, reg)
    ## NA-NOT USED in MB Auto track mode, if trackMode=0 if clip, track every samp 1x else track on pos conv at 1x <BR> if trackMode=1 if clip, track every samp 1.5x else track on pos conv at 1x <BR> if trackMode=2 if clip, track every samp 1x else track on pos conv at 1.5x <BR> if trackMode=3 if clip, track every samp 1.5x else track on pos conv at 1.5x
    def autoTrack(self, value = None):
        value = dma_bits(0xE70E, self.address, 1, 19, value)
        return(value)
    ## NA-NOT USED in MB 0:use LFSR for dither 1:always add 7 for dither
    def dithAddSel(self, value = None):
        value = dma_bits(0xE70E, self.address, 1, 18, value)
        return(value)
    ## NA-NOT USED in MB Error from actual to ideal MSB to XSB ratio of 16 use to calc how many XSB to subtract when adding a MSB cap
    def msbXsbError(self, value = None):
        value = dma_bits(0xE70E, self.address, 3, 15, value)
        return(value)
    ## NA-NOT USED in MB 0:Use compOffCapCode 1:Hold, don't track  2: Fast Track offset  3: Slow track offset
    def offTrackMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 2, 13, value)
        return(value)
    ## NA-NOT USED in MB Do subtractive dither
    def ditherCalc(self, value = None):
        value = dma_bits(0xE70E, self.address, 1, 12, value)
        return(value)
    ## Use Fir Mode instead of subtracting avg diff
    def firMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 1, 11, value)
        return(value)
    ## IIR coeffs: 1+(0.5^m) (0=pass thru)
    def iirCoef(self, value = None):
        value = dma_bits(0xE70E, self.address, 3, 8, value)
        return(value)
    ## 0: Tracking every cycle 1: Tracking only on pos samples <BR> bit[1] - dynCompMode enable
    def trackMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 2, 6, value)
        return(value)
    ## 0/1:Normal chopping 2:Force Pos only sampling  3:Force Neg only sampling
    def invMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 2, 4, value)
        return(value)
    ## NA-NOT USED in MB Dynamic element matching mode: 0=none; 1=XSB only; 2=MSB only; 3=DWA XSB+MSB
    def demMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 2, 2, value)
        return(value)
    ## NA-NOT USED in MB Dither mode: 0=none; 1=LFSR
    def ditherMode(self, value = None):
        value = dma_bits(0xE70E, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telMode_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE70F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE70F, None)
            self.calcLsbSel = (self.reg_value >> 31) & 0x1
            self.tsAlignSel = (self.reg_value >> 29) & 0x3
            self.forceClkTsAlign = (self.reg_value >> 28) & 0x1
            self.calcAnaOffset = (self.reg_value >> 27) & 0x1
            self.compOffTrackMode = (self.reg_value >> 25) & 0x3
            self.telRstStB4Cnvt = (self.reg_value >> 24) & 0x1
            self.vsenPadTrim2 = (self.reg_value >> 21) & 0x7
            self.vsenPadTrim1 = (self.reg_value >> 18) & 0x7
            self.vsenPadTrim0 = (self.reg_value >> 15) & 0x7
            self.sampCrit2 = (self.reg_value >> 11) & 0xF
            self.useRstChSt = (self.reg_value >> 10) & 0x1
            self.convSel = (self.reg_value >> 8) & 0x3
            self.ditherMode = (self.reg_value >> 6) & 0x3
            self.ditherCalc = (self.reg_value >> 5) & 0x1
            self.iInSenDemForce = (self.reg_value >> 3) & 0x3
            self.iInSenAzDemEn = (self.reg_value >> 2) & 0x1
            self.telSampCapRstEn = (self.reg_value >> 1) & 0x1
            self.telUseOscClk = self.reg_value & 0x1

    def read_object(self):
        return(self.telMode_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.calcLsbSel & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.tsAlignSel & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.forceClkTsAlign & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.calcAnaOffset & 0x1) << 27)
        reg = (reg & 0xF9FFFFFF) + ((register_object.compOffTrackMode & 0x3) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.telRstStB4Cnvt & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.vsenPadTrim2 & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.vsenPadTrim1 & 0x7) << 18)
        reg = (reg & 0xFFFC7FFF) + ((register_object.vsenPadTrim0 & 0x7) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.sampCrit2 & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.useRstChSt & 0x1) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.convSel & 0x3) << 8)
        reg = (reg & 0xFFFFFF3F) + ((register_object.ditherMode & 0x3) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.ditherCalc & 0x1) << 5)
        reg = (reg & 0xFFFFFFE7) + ((register_object.iInSenDemForce & 0x3) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.iInSenAzDemEn & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.telSampCapRstEn & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.telUseOscClk & 0x1)
        dma(self.address, 0xE70F, reg)
    ## NA-NOT USED in MB-For lngCnvt1/2 if set
    def calcLsbSel(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 31, value)
        return(value)
    ## NA-NOT USED in MB-tsAlignSel: phase alignment of sample acq pos edge of clkTs
    def tsAlignSel(self, value = None):
        value = dma_bits(0xE70F, self.address, 2, 29, value)
        return(value)
    ## NA-NOT USED in MB-force ADC sample acqusition to align to clkTs as selected
    def forceClkTsAlign(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 28, value)
        return(value)
    ## use ana offset in calculations to determine result
    def calcAnaOffset(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 27, value)
        return(value)
    ## 0:Use compOffCapCode 1:Hold, don't track  2: Fast Track offset  3: Slow track offset
    def compOffTrackMode(self, value = None):
        value = dma_bits(0xE70F, self.address, 2, 25, value)
        return(value)
    ## If set
    def telRstStB4Cnvt(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 24, value)
        return(value)
    ## VSEN vs VCC pad comparator trim channel 2
    def vsenPadTrim2(self, value = None):
        value = dma_bits(0xE70F, self.address, 3, 21, value)
        return(value)
    ## VSEN vs VCC pad comparator trim channel 1
    def vsenPadTrim1(self, value = None):
        value = dma_bits(0xE70F, self.address, 3, 18, value)
        return(value)
    ## VSEN vs VCC pad comparator trim channel 0
    def vsenPadTrim0(self, value = None):
        value = dma_bits(0xE70F, self.address, 3, 15, value)
        return(value)
    ## Sample aperature of second crit sample 0 means no second crit sample/compare
    def sampCrit2(self, value = None):
        value = dma_bits(0xE70F, self.address, 4, 11, value)
        return(value)
    ## NA-NOT USED in MB-Always reset DAC caps using next state after conversion in ADC
    def useRstChSt(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 10, value)
        return(value)
    ## NA-NOT USED in MB Hard coded to 0 - Long Convert Mode
    def convSel(self, value = None):
        value = dma_bits(0xE70F, self.address, 2, 8, value)
        return(value)
    ## For subtractive dither
    def ditherMode(self, value = None):
        value = dma_bits(0xE70F, self.address, 2, 6, value)
        return(value)
    ## 1=enable subtractive dither
    def ditherCalc(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 5, value)
        return(value)
    ## Force the DEM pattern for anaIinSense
    def iInSenDemForce(self, value = None):
        value = dma_bits(0xE70F, self.address, 2, 3, value)
        return(value)
    ## Enable DEM pattern for anaIinSense AZ amp
    def iInSenAzDemEn(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 2, value)
        return(value)
    ## see MBIRD-1253 for details 1=enable resetting sampling caps
    def telSampCapRstEn(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 1, value)
        return(value)
    ## Make telAdc run off oscClk instead of clkTs - DONT SET WHILE RUNNING
    def telUseOscClk(self, value = None):
        value = dma_bits(0xE70F, self.address, 1, 0, value)
        return(value)

###################################################################
## Common control for all ISEN Phases
###################################################################
class phXIsenMode_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE710, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phXIsenMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE710, None)
            self.spares = (self.reg_value >> 17) & 0x3
            self.useRevAclks = (self.reg_value >> 16) & 0x1
            self.azSeqSel = (self.reg_value >> 15) & 0x1
            self.modeCfg = (self.reg_value >> 13) & 0x3
            self.dsSel = (self.reg_value >> 11) & 0x3
            self.dithAddSel = (self.reg_value >> 10) & 0x1
            self.compOffOvrEn = (self.reg_value >> 9) & 0x1
            self.ditherMode = (self.reg_value >> 7) & 0x3
            self.demEn = (self.reg_value >> 6) & 0x1
            self.iirCoef = (self.reg_value >> 3) & 0x7
            self.autoZeroRate = self.reg_value & 0x7

    def read_object(self):
        return(self.phXIsenMode_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFF) + ((register_object.spares & 0x3) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.useRevAclks & 0x1) << 16)
        reg = (reg & 0x77FFF) + ((register_object.azSeqSel & 0x1) << 15)
        reg = (reg & 0x79FFF) + ((register_object.modeCfg & 0x3) << 13)
        reg = (reg & 0x7E7FF) + ((register_object.dsSel & 0x3) << 11)
        reg = (reg & 0x7FBFF) + ((register_object.dithAddSel & 0x1) << 10)
        reg = (reg & 0x7FDFF) + ((register_object.compOffOvrEn & 0x1) << 9)
        reg = (reg & 0x7FE7F) + ((register_object.ditherMode & 0x3) << 7)
        reg = (reg & 0x7FFBF) + ((register_object.demEn & 0x1) << 6)
        reg = (reg & 0x7FFC7) + ((register_object.iirCoef & 0x7) << 3)
        reg = (reg & 0x7FFF8) + (register_object.autoZeroRate & 0x7)
        dma(self.address, 0xE710, reg)
    ## bit 0 - dynPdn (enable dynamic comparator in stg0) <BR> bit 1 - dynPdn1 (enable dynamic comparator in stg1) <BR> bit 2 - 0:lpfEn applies all the time 1: lpfEn only applies to compMode
    def spares(self, value = None):
        value = dma_bits(0xE710, self.address, 2, 17, value)
        return(value)
    ## 0-use kSamp1amp,ksamp1,kSamp2  1- use only kSamp1,kSamp2
    def useRevAclks(self, value = None):
        value = dma_bits(0xE710, self.address, 1, 16, value)
        return(value)
    ## 0:ph0,ph1,ph2,ph3,ph0Odd,ph1Odd,ph2Odd,ph3Odd  1:ph0,ph0Odd,ph1,ph1Odd,ph2,ph2Odd,ph3,ph3Odd
    def azSeqSel(self, value = None):
        value = dma_bits(0xE710, self.address, 1, 15, value)
        return(value)
    ## reserved controller bits for modes
    def modeCfg(self, value = None):
        value = dma_bits(0xE710, self.address, 2, 13, value)
        return(value)
    ## 0-disAble delta sigma 1-ds 14bit to 12bit 2-ds 14bit to 10bit 3-ds 14bit to 8bit
    def dsSel(self, value = None):
        value = dma_bits(0xE710, self.address, 2, 11, value)
        return(value)
    ## 0-use LFSR 1-always add 7
    def dithAddSel(self, value = None):
        value = dma_bits(0xE710, self.address, 1, 10, value)
        return(value)
    def compOffOvrEn(self, value = None):
        value = dma_bits(0xE710, self.address, 1, 9, value)
        return(value)
    ## dither add 0-none 1-.25LSB 2-0.5LSB 3-1LSB
    def ditherMode(self, value = None):
        value = dma_bits(0xE710, self.address, 2, 7, value)
        return(value)
    ## Enable DEM in iSen conversions
    def demEn(self, value = None):
        value = dma_bits(0xE710, self.address, 1, 6, value)
        return(value)
    ## IIR coeffs: 1+(0.5^m) (0=pass thru)
    def iirCoef(self, value = None):
        value = dma_bits(0xE710, self.address, 3, 3, value)
        return(value)
    ## az Rate (0:Constant 1:Tsw 2:2*Tsw 3: 4*Tsw 4:8*Tsw 5:16*Tsw 6:32*Tsw 7:Off)
    def autoZeroRate(self, value = None):
        value = dma_bits(0xE710, self.address, 3, 0, value)
        return(value)

###################################################################
## Common control for all ISEN Phases
###################################################################
class phCnvt8_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xE711, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phCnvt8_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE711, None)
            self.overRideCnvt8 = (self.reg_value >> 8) & 0x1
            self.phCnvt8 = self.reg_value & 0xFF

    def read_object(self):
        return(self.phCnvt8_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.overRideCnvt8 & 0x1) << 8)
        reg = (reg & 0x100) + (register_object.phCnvt8 & 0xFF)
        dma(self.address, 0xE711, reg)
    ## If set, use phCnvt8 directly to control 8/10bit conversions, ignore automatic controls
    def overRideCnvt8(self, value = None):
        value = dma_bits(0xE711, self.address, 1, 8, value)
        return(value)
    ## Force specific phase ADC to 8 bit mode
    def phCnvt8(self, value = None):
        value = dma_bits(0xE711, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xE712, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE712, None)
            self.spare = (self.reg_value >> 10) & 0x7
            self.vRefDacSel = (self.reg_value >> 8) & 0x3
            self.dynPdn1 = (self.reg_value >> 7) & 0x1
            self.dynPdn = (self.reg_value >> 6) & 0x1
            self.lpfEn = (self.reg_value >> 5) & 0x1
            self.clkAlign = (self.reg_value >> 4) & 0x1
            self.biasAdjAmp = (self.reg_value >> 2) & 0x3
            self.buf2xSel = self.reg_value & 0x1

    def read_object(self):
        return(self.vSenTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.spare & 0x7) << 10)
        reg = (reg & 0x1CFF) + ((register_object.vRefDacSel & 0x3) << 8)
        reg = (reg & 0x1F7F) + ((register_object.dynPdn1 & 0x1) << 7)
        reg = (reg & 0x1FBF) + ((register_object.dynPdn & 0x1) << 6)
        reg = (reg & 0x1FDF) + ((register_object.lpfEn & 0x1) << 5)
        reg = (reg & 0x1FEF) + ((register_object.clkAlign & 0x1) << 4)
        reg = (reg & 0x1FF3) + ((register_object.biasAdjAmp & 0x3) << 2)
        reg = (reg & 0x1FFE) + (register_object.buf2xSel & 0x1)
        dma(self.address, 0xE712, reg)
    def spare(self, value = None):
        value = dma_bits(0xE712, self.address, 3, 10, value)
        return(value)
    ## 0-Hi impedance vRef  1-Lo impedance ref  2/3-High impedance during conversion else lo
    def vRefDacSel(self, value = None):
        value = dma_bits(0xE712, self.address, 2, 8, value)
        return(value)
    ## 0- no dynamic power for stg1 of comp  1- allow stg1 to use only dynamic power
    def dynPdn1(self, value = None):
        value = dma_bits(0xE712, self.address, 1, 7, value)
        return(value)
    ## 0- no dynamic power for stg0 of comp  1- allow stg0 to use only dynamic power
    def dynPdn(self, value = None):
        value = dma_bits(0xE712, self.address, 1, 6, value)
        return(value)
    ## 0- no LPF on comparator outputs  1- add LPF to comparator output
    def lpfEn(self, value = None):
        value = dma_bits(0xE712, self.address, 1, 5, value)
        return(value)
    ## 0: dynPdn/dynPdn1 apply to both normal and compMode  1: dynPdn/dynPdn1 only apply to compMode
    def clkAlign(self, value = None):
        value = dma_bits(0xE712, self.address, 1, 4, value)
        return(value)
    ## 0:8uA  1/2:12uA  3:6uA
    def biasAdjAmp(self, value = None):
        value = dma_bits(0xE712, self.address, 2, 2, value)
        return(value)
    ## By default vSen ref buf range is ~1-240uA, this bit doubles that range
    def buf2xSel(self, value = None):
        value = dma_bits(0xE712, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE713, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE713, None)
            self.rstB4All = (self.reg_value >> 31) & 0x1
            self.compGateMode = (self.reg_value >> 27) & 0xF
            self.anaSpare = (self.reg_value >> 24) & 0x7
            self.vddioBufTest = (self.reg_value >> 23) & 0x1
            self.vRefDacSel = (self.reg_value >> 21) & 0x3
            self.lpfEn = (self.reg_value >> 20) & 0x1
            self.bias2xSel = (self.reg_value >> 19) & 0x1
            self.biasAdjAmp = (self.reg_value >> 17) & 0x3
            self.dynPdn1 = (self.reg_value >> 16) & 0x1
            self.dynPdn = (self.reg_value >> 15) & 0x1
            self.selTailR = (self.reg_value >> 12) & 0x7
            self.offsetTel = self.reg_value & 0x7FF

    def read_object(self):
        return(self.telTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.rstB4All & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.compGateMode & 0xF) << 27)
        reg = (reg & 0xF8FFFFFF) + ((register_object.anaSpare & 0x7) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.vddioBufTest & 0x1) << 23)
        reg = (reg & 0xFF9FFFFF) + ((register_object.vRefDacSel & 0x3) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.lpfEn & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.bias2xSel & 0x1) << 19)
        reg = (reg & 0xFFF9FFFF) + ((register_object.biasAdjAmp & 0x3) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.dynPdn1 & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.dynPdn & 0x1) << 15)
        reg = (reg & 0xFFFF8FFF) + ((register_object.selTailR & 0x7) << 12)
        reg = (reg & 0xFFFFF800) + (register_object.offsetTel & 0x7FF)
        dma(self.address, 0xE713, reg)
    ## Add reset state before every high speed sample state
    def rstB4All(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 31, value)
        return(value)
    ## Gate the comparator clock before comparator is enabled
    def compGateMode(self, value = None):
        value = dma_bits(0xE713, self.address, 4, 27, value)
        return(value)
    def anaSpare(self, value = None):
        value = dma_bits(0xE713, self.address, 3, 24, value)
        return(value)
    ## 0 - Regular Buffer Mode, 1 - OutP and OutN same voltage + offset
    def vddioBufTest(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 23, value)
        return(value)
    ## bit0: 0-Hi impedance vRef  1-Lo impedance ref  bit 1:digOffset[0]
    def vRefDacSel(self, value = None):
        value = dma_bits(0xE713, self.address, 2, 21, value)
        return(value)
    ## 0- no LPF on comparator outputs  1- add LPF to comparator output
    def lpfEn(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 20, value)
        return(value)
    ## Double bias currents to Buffer
    def bias2xSel(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 19, value)
        return(value)
    ## 0:8uA  1/2:12uA  3:6uA
    def biasAdjAmp(self, value = None):
        value = dma_bits(0xE713, self.address, 2, 17, value)
        return(value)
    ## 0- no dynamic power for stg1 of comp  1- allow stg1 to use only dynamic power
    def dynPdn1(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 16, value)
        return(value)
    ## 0- no dynamic power for stg0 of comp  1- allow stg0 to use only dynamic power
    def dynPdn(self, value = None):
        value = dma_bits(0xE713, self.address, 1, 15, value)
        return(value)
    ## Tel TailDac sel, 0=200n 1=10uA 2=20uA 3=30u 4=40u 5=50u 6=60u 7=70u
    def selTailR(self, value = None):
        value = dma_bits(0xE713, self.address, 3, 12, value)
        return(value)
    ## Signed Digital Offset applied to telem ADC (EMU CALTELOFFSET)
    def offsetTel(self, value = None):
        value = dma_bits(0xE713, self.address, 11, 0, value)
        return(value)

###################################################################
## 
###################################################################
class iSenTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 21

    def __call__(self, value = None):
        value = dma(self.address, 0xE714, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE714, None)
            self.trackEn = (self.reg_value >> 20) & 0x1
            self.latchCfg = (self.reg_value >> 17) & 0x7
            self.latchSel = (self.reg_value >> 15) & 0x3
            self.clkDisable = (self.reg_value >> 14) & 0x1
            self.clkDelSel = (self.reg_value >> 13) & 0x1
            self.biasAdjAmp = (self.reg_value >> 11) & 0x3
            self.biasAdjBuff = (self.reg_value >> 10) & 0x1
            self.setTailR = (self.reg_value >> 6) & 0x7
            self.nonOvCtrl = (self.reg_value >> 5) & 0x1
            self.xsbOvlpAna = (self.reg_value >> 1) & 0xF
            self.fsSel300 = self.reg_value & 0x1

    def read_object(self):
        return(self.iSenTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.trackEn & 0x1) << 20)
        reg = (reg & 0x11FFFF) + ((register_object.latchCfg & 0x7) << 17)
        reg = (reg & 0x1E7FFF) + ((register_object.latchSel & 0x3) << 15)
        reg = (reg & 0x1FBFFF) + ((register_object.clkDisable & 0x1) << 14)
        reg = (reg & 0x1FDFFF) + ((register_object.clkDelSel & 0x1) << 13)
        reg = (reg & 0x1FE7FF) + ((register_object.biasAdjAmp & 0x3) << 11)
        reg = (reg & 0x1FFBFF) + ((register_object.biasAdjBuff & 0x1) << 10)
        reg = (reg & 0x1FFE3F) + ((register_object.setTailR & 0x7) << 6)
        reg = (reg & 0x1FFFDF) + ((register_object.nonOvCtrl & 0x1) << 5)
        reg = (reg & 0x1FFFE1) + ((register_object.xsbOvlpAna & 0xF) << 1)
        reg = (reg & 0x1FFFFE) + (register_object.fsSel300 & 0x1)
        dma(self.address, 0xE714, reg)
    ## enable tracking for testing
    def trackEn(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 20, value)
        return(value)
    def latchCfg(self, value = None):
        value = dma_bits(0xE714, self.address, 3, 17, value)
        return(value)
    def latchSel(self, value = None):
        value = dma_bits(0xE714, self.address, 2, 15, value)
        return(value)
    ## 0- auto low power <BR> 1- force enable all clocks to iSen controller even if auto commands clocks off
    def clkDisable(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 14, value)
        return(value)
    ## 0- native delay 1-align all controllers in time
    def clkDelSel(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 13, value)
        return(value)
    def biasAdjAmp(self, value = None):
        value = dma_bits(0xE714, self.address, 2, 11, value)
        return(value)
    def biasAdjBuff(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 10, value)
        return(value)
    def setTailR(self, value = None):
        value = dma_bits(0xE714, self.address, 3, 6, value)
        return(value)
    ## for MBIRD lpfBypZ => 0 - bypas lpf  1 - use lpf for lower noise/lower bandwidth on output of comparator
    def nonOvCtrl(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 5, value)
        return(value)
    def xsbOvlpAna(self, value = None):
        value = dma_bits(0xE714, self.address, 4, 1, value)
        return(value)
    def fsSel300(self, value = None):
        value = dma_bits(0xE714, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telPsysCrit_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xE715, value)
        return(value)


###################################################################
## 
###################################################################
class telPsysWarn_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE716, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telPsysWarn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE716, None)
            self.warn2Level = (self.reg_value >> 12) & 0xFFF
            self.warn1Level = self.reg_value & 0xFFF

    def read_object(self):
        return(self.telPsysWarn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.warn2Level & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.warn1Level & 0xFFF)
        dma(self.address, 0xE716, reg)
    ## Fast Psys warn2 level in ADC wieghts
    def warn2Level(self, value = None):
        value = dma_bits(0xE716, self.address, 12, 12, value)
        return(value)
    ## Fast Psys warn1 level in ADC wieghts
    def warn1Level(self, value = None):
        value = dma_bits(0xE716, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenTest_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE717, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE717, None)
            self.compMode = (self.reg_value >> 31) & 0x1
            self.compOverRide = (self.reg_value >> 30) & 0x1
            self.testFb = (self.reg_value >> 27) & 0x7
            self.dataOutSel = (self.reg_value >> 25) & 0x3
            self.trackHold = (self.reg_value >> 24) & 0x1
            self.roughRefSel2 = (self.reg_value >> 23) & 0x1
            self.tieVsenPAVDD2 = (self.reg_value >> 22) & 0x1
            self.shCompStg1Vsen2 = (self.reg_value >> 21) & 0x1
            self.shCompStg0Vsen2 = (self.reg_value >> 20) & 0x1
            self.openVsen2P = (self.reg_value >> 19) & 0x1
            self.openVsen2N = (self.reg_value >> 18) & 0x1
            self.shortVsen2In = (self.reg_value >> 17) & 0x1
            self.tstDacSelVsen2 = (self.reg_value >> 16) & 0x1
            self.roughRefSel1 = (self.reg_value >> 15) & 0x1
            self.tieVsenPAVDD1 = (self.reg_value >> 14) & 0x1
            self.shCompStg1Vsen1 = (self.reg_value >> 13) & 0x1
            self.shCompStg0Vsen1 = (self.reg_value >> 12) & 0x1
            self.openVsen1P = (self.reg_value >> 11) & 0x1
            self.openVsen1N = (self.reg_value >> 10) & 0x1
            self.shortVsen1In = (self.reg_value >> 9) & 0x1
            self.tstDacSelVsen1 = (self.reg_value >> 8) & 0x1
            self.roughRefSel0 = (self.reg_value >> 7) & 0x1
            self.tieVsenPAVDD0 = (self.reg_value >> 6) & 0x1
            self.shCompStg1Vsen0 = (self.reg_value >> 5) & 0x1
            self.shCompStg0Vsen0 = (self.reg_value >> 4) & 0x1
            self.openVsen0P = (self.reg_value >> 3) & 0x1
            self.openVsen0N = (self.reg_value >> 2) & 0x1
            self.shortVsen0In = (self.reg_value >> 1) & 0x1
            self.tstDacSelVsen0 = self.reg_value & 0x1

    def read_object(self):
        return(self.vSenTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.compMode & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.compOverRide & 0x1) << 30)
        reg = (reg & 0xC7FFFFFF) + ((register_object.testFb & 0x7) << 27)
        reg = (reg & 0xF9FFFFFF) + ((register_object.dataOutSel & 0x3) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.trackHold & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.roughRefSel2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.tieVsenPAVDD2 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.shCompStg1Vsen2 & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.shCompStg0Vsen2 & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.openVsen2P & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.openVsen2N & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.shortVsen2In & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.tstDacSelVsen2 & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.roughRefSel1 & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.tieVsenPAVDD1 & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.shCompStg1Vsen1 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.shCompStg0Vsen1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.openVsen1P & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.openVsen1N & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.shortVsen1In & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.tstDacSelVsen1 & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.roughRefSel0 & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.tieVsenPAVDD0 & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.shCompStg1Vsen0 & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.shCompStg0Vsen0 & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.openVsen0P & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.openVsen0N & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.shortVsen0In & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.tstDacSelVsen0 & 0x1)
        dma(self.address, 0xE717, reg)
    ## Force compMode on vSen Adcs
    def compMode(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 31, value)
        return(value)
    ## Use compMode and verrComp to control compMode for all vSenAdcs
    def compOverRide(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 30, value)
        return(value)
    ## Enable testFb mode: <BR> bit[0]:enable testFb for loop0  <BR> bit[1]:enable testFb for loop1  <BR> bit[2]:enable testFb for loop2
    def testFb(self, value = None):
        value = dma_bits(0xE717, self.address, 3, 27, value)
        return(value)
    ## select signals for dataOut <BR> 0:adcData <BR> 1:offsetFilter <BR> 2:compTracking <BR> 3:vidDac
    def dataOutSel(self, value = None):
        value = dma_bits(0xE717, self.address, 2, 25, value)
        return(value)
    ## Stop tracking vSen inputs
    def trackHold(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 24, value)
        return(value)
    ## sel roughRefSel which is used to precharge reference during power up sequence
    def roughRefSel2(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 23, value)
        return(value)
    ## short VsenP to AVDD
    def tieVsenPAVDD2(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 22, value)
        return(value)
    ## force comp stage1 to reset state
    def shCompStg1Vsen2(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 21, value)
        return(value)
    ## force comp stage0 to reset state
    def shCompStg0Vsen2(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 20, value)
        return(value)
    ## open connection to vSenP pin
    def openVsen2P(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 19, value)
        return(value)
    ## open connection to vSenN pin
    def openVsen2N(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 18, value)
        return(value)
    ## short internal vSen+ to Vsen-
    def shortVsen2In(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 17, value)
        return(value)
    ## testDac connections are AGND33 in Nova ... so short vSen inputs to AGND33
    def tstDacSelVsen2(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 16, value)
        return(value)
    ## sel roughRefSel which is used to precharge reference during power up sequence
    def roughRefSel1(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 15, value)
        return(value)
    ## short VsenP to AVDD
    def tieVsenPAVDD1(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 14, value)
        return(value)
    ## force comp stage1 to reset state
    def shCompStg1Vsen1(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 13, value)
        return(value)
    ## force comp stage0 to reset state
    def shCompStg0Vsen1(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 12, value)
        return(value)
    ## open connection to vSenP pin
    def openVsen1P(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 11, value)
        return(value)
    ## open connection to vSenN pin
    def openVsen1N(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 10, value)
        return(value)
    ## short internal vSen+ to Vsen-
    def shortVsen1In(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 9, value)
        return(value)
    ## testDac connections are AGND33 in Nova ... so short vSen inputs to AGND33
    def tstDacSelVsen1(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 8, value)
        return(value)
    ## sel roughRefSel which is used to precharge reference during power up sequence
    def roughRefSel0(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 7, value)
        return(value)
    ## short VsenP to AVDD
    def tieVsenPAVDD0(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 6, value)
        return(value)
    ## force comp stage1 to reset state
    def shCompStg1Vsen0(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 5, value)
        return(value)
    ## force comp stage0 to reset state
    def shCompStg0Vsen0(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 4, value)
        return(value)
    ## open connection to vSenP pin
    def openVsen0P(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 3, value)
        return(value)
    ## open connection to vSenN pin
    def openVsen0N(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 2, value)
        return(value)
    ## short internal vSen+ to Vsen-
    def shortVsen0In(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 1, value)
        return(value)
    ## testDac connections are AGND33 in Nova ... so short vSen inputs to AGND33
    def tstDacSelVsen0(self, value = None):
        value = dma_bits(0xE717, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class adcTest_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE718, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class adcTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE718, None)
            self.verrCompOR = (self.reg_value >> 31) & 0x1
            self.verrCompALL = (self.reg_value >> 30) & 0x1
            self.verrComp = (self.reg_value >> 22) & 0xFF
            self.msbOffset = (self.reg_value >> 18) & 0xF
            self.xsbOffset = (self.reg_value >> 13) & 0x1F
            self.dacMsbOvrVal = (self.reg_value >> 9) & 0xF
            self.dacXsbOvrVal = (self.reg_value >> 4) & 0x1F
            self.dacOvrEn = (self.reg_value >> 2) & 0x3
            self.dacLsbOverEn = (self.reg_value >> 1) & 0x1
            self.updateIsenCalc = self.reg_value & 0x1

    def read_object(self):
        return(self.adcTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.verrCompOR & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.verrCompALL & 0x1) << 30)
        reg = (reg & 0xC03FFFFF) + ((register_object.verrComp & 0xFF) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.msbOffset & 0xF) << 18)
        reg = (reg & 0xFFFC1FFF) + ((register_object.xsbOffset & 0x1F) << 13)
        reg = (reg & 0xFFFFE1FF) + ((register_object.dacMsbOvrVal & 0xF) << 9)
        reg = (reg & 0xFFFFFE0F) + ((register_object.dacXsbOvrVal & 0x1F) << 4)
        reg = (reg & 0xFFFFFFF3) + ((register_object.dacOvrEn & 0x3) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.dacLsbOverEn & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.updateIsenCalc & 0x1)
        dma(self.address, 0xE718, reg)
    ## If !verrCompOR then use vSen#CompVerrThresholdSel directly to drive verrComp <BR> else use adcTest.verrComp to write to all verrComp else use:<BR> VSEN0: adcTest.verrComp <BR> VSEN1: phIsenValue
    def verrCompOR(self, value = None):
        value = dma_bits(0xE718, self.address, 1, 31, value)
        return(value)
    ## If verrCompALL then use adcTest.verrComp to write to all verrComp else use:<BR> VSEN0: adcTest.verrComp <BR> VSEN1: phIsenValue
    def verrCompALL(self, value = None):
        value = dma_bits(0xE718, self.address, 1, 30, value)
        return(value)
    ## Value to be use for comparator level in vSen ADC0
    def verrComp(self, value = None):
        value = dma_bits(0xE718, self.address, 8, 22, value)
        return(value)
    ## Value to put on MSB caps during samp state.<BR>In normal operation for vSen this MUST be 0
    def msbOffset(self, value = None):
        value = dma_bits(0xE718, self.address, 4, 18, value)
        return(value)
    ## Value to put on XSB caps during samp state.<BR>In normal operation for vSen this MUST be 0
    def xsbOffset(self, value = None):
        value = dma_bits(0xE718, self.address, 5, 13, value)
        return(value)
    ## Value to use for MSB value instead of tracked value for vSen ADC <BR> Also controls the Vcm of the anaComClkOscDriveStg1 block for ATB
    def dacMsbOvrVal(self, value = None):
        value = dma_bits(0xE718, self.address, 4, 9, value)
        return(value)
    ## Value to use for XSB value instead of tracked value for vSen ADC
    def dacXsbOvrVal(self, value = None):
        value = dma_bits(0xE718, self.address, 5, 4, value)
        return(value)
    ## Bit1: Use dacMsbOvrVal<BR>Bit0: Use dacXsbOvrVal
    def dacOvrEn(self, value = None):
        value = dma_bits(0xE718, self.address, 2, 2, value)
        return(value)
    ## If enabled, dacOvrEn[1] enables dacMsbOverVal[0] to override the LSB of the Msb dac <BR> and dacOvrEn[0] enables dacXsbOverVal[0] to override the LSB of the Xsb dac
    def dacLsbOverEn(self, value = None):
        value = dma_bits(0xE718, self.address, 1, 1, value)
        return(value)
    ## Not Used ... Rsvd Can be removed
    def updateIsenCalc(self, value = None):
        value = dma_bits(0xE718, self.address, 1, 0, value)
        return(value)

###################################################################
## Common control for all ISEN Phases
###################################################################
class phIsenValue_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE719, value)
        return(value)


###################################################################
## Common control for all ISEN Phases
###################################################################
class phIsenMask_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE71A, value)
        return(value)


###################################################################
## 
###################################################################
class telAdcTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE71C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telAdcTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE71C, None)
            self.msbWeight = (self.reg_value >> 20) & 0xFFF
            self.xsbWeight = (self.reg_value >> 8) & 0xFFF
            self.lsbWeight = self.reg_value & 0xFF

    def read_object(self):
        return(self.telAdcTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.msbWeight & 0xFFF) << 20)
        reg = (reg & 0xFFF000FF) + ((register_object.xsbWeight & 0xFFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.lsbWeight & 0xFF)
        dma(self.address, 0xE71C, reg)
    ## weight of MSB in LSB<<8 terms relative to FS=2^16
    def msbWeight(self, value = None):
        value = dma_bits(0xE71C, self.address, 12, 20, value)
        return(value)
    ## weight of XSB in LSB<<4 terms relative to FS=2^16
    def xsbWeight(self, value = None):
        value = dma_bits(0xE71C, self.address, 12, 8, value)
        return(value)
    ## weight of LSB in LSB<<4 terms relative to FS=2^16
    def lsbWeight(self, value = None):
        value = dma_bits(0xE71C, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telByteTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE71D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telByteTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE71D, None)
            self.m8AddWeight = (self.reg_value >> 23) & 0x1FF
            self.m4AddWeight = (self.reg_value >> 15) & 0xFF
            self.m2AddWeight = (self.reg_value >> 7) & 0xFF
            self.x8AddWeight = self.reg_value & 0x7F

    def read_object(self):
        return(self.telByteTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.m8AddWeight & 0x1FF) << 23)
        reg = (reg & 0xFF807FFF) + ((register_object.m4AddWeight & 0xFF) << 15)
        reg = (reg & 0xFFFF807F) + ((register_object.m2AddWeight & 0xFF) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.x8AddWeight & 0x7F)
        dma(self.address, 0xE71D, reg)
    ## signed trim factor for MSB*8
    def m8AddWeight(self, value = None):
        value = dma_bits(0xE71D, self.address, 9, 23, value)
        return(value)
    ## signed trim factor for MSB*4
    def m4AddWeight(self, value = None):
        value = dma_bits(0xE71D, self.address, 8, 15, value)
        return(value)
    ## signed trim factor for MSB*2
    def m2AddWeight(self, value = None):
        value = dma_bits(0xE71D, self.address, 8, 7, value)
        return(value)
    ## signed trim factor for XSB*8
    def x8AddWeight(self, value = None):
        value = dma_bits(0xE71D, self.address, 7, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telDacTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE71E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telDacTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE71E, None)
            self.spares = (self.reg_value >> 29) & 0x7
            self.pre1VcmAdj = (self.reg_value >> 25) & 0xF
            self.pre0VcmAdj = (self.reg_value >> 21) & 0xF
            self.biasAdj1Comp = (self.reg_value >> 18) & 0x7
            self.biasAdj0Comp = (self.reg_value >> 15) & 0x7
            self.refPsel = (self.reg_value >> 13) & 0x3
            self.refNsel = (self.reg_value >> 11) & 0x3
            self.compOffCapCode = self.reg_value & 0x7FF

    def read_object(self):
        return(self.telDacTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.spares & 0x7) << 29)
        reg = (reg & 0xE1FFFFFF) + ((register_object.pre1VcmAdj & 0xF) << 25)
        reg = (reg & 0xFE1FFFFF) + ((register_object.pre0VcmAdj & 0xF) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.biasAdj1Comp & 0x7) << 18)
        reg = (reg & 0xFFFC7FFF) + ((register_object.biasAdj0Comp & 0x7) << 15)
        reg = (reg & 0xFFFF9FFF) + ((register_object.refPsel & 0x3) << 13)
        reg = (reg & 0xFFFFE7FF) + ((register_object.refNsel & 0x3) << 11)
        reg = (reg & 0xFFFFF800) + (register_object.compOffCapCode & 0x7FF)
        dma(self.address, 0xE71E, reg)
    ## Not Used
    def spares(self, value = None):
        value = dma_bits(0xE71E, self.address, 3, 29, value)
        return(value)
    ## 0:lowest vcm1 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj1Comp=3 <BR> output vCm ~0.75V
    def pre1VcmAdj(self, value = None):
        value = dma_bits(0xE71E, self.address, 4, 25, value)
        return(value)
    ## 0:lowest vcm0 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj0Comp=3 <BR> output vCm ~0.75V
    def pre0VcmAdj(self, value = None):
        value = dma_bits(0xE71E, self.address, 4, 21, value)
        return(value)
    ## NA-NOT USED in MB 0:25uA 1:50uA 2:75uA 3:100uA 4:125uA 5:150uA 6:175uA 7:200uA
    def biasAdj1Comp(self, value = None):
        value = dma_bits(0xE71E, self.address, 3, 18, value)
        return(value)
    ## 0:14uA 1:25uA 2:36uA 3:48uA 4:60uA 5:71uA 6:82uA 7:94uA
    def biasAdj0Comp(self, value = None):
        value = dma_bits(0xE71E, self.address, 3, 15, value)
        return(value)
    def refPsel(self, value = None):
        value = dma_bits(0xE71E, self.address, 2, 13, value)
        return(value)
    ## Not used ... spare bits
    def refNsel(self, value = None):
        value = dma_bits(0xE71E, self.address, 2, 11, value)
        return(value)
    ## analog comp offset trim
    def compOffCapCode(self, value = None):
        value = dma_bits(0xE71E, self.address, 11, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenDigOffset_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE71F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenDigOffset_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE71F, None)
            self.offsetVsen2 = (self.reg_value >> 16) & 0xFF
            self.offsetVsen1 = (self.reg_value >> 8) & 0xFF
            self.offsetVsen0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.vSenDigOffset_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.offsetVsen2 & 0xFF) << 16)
        reg = (reg & 0xFF00FF) + ((register_object.offsetVsen1 & 0xFF) << 8)
        reg = (reg & 0xFFFF00) + (register_object.offsetVsen0 & 0xFF)
        dma(self.address, 0xE71F, reg)
    ## Signed Digital Offset applied to vSen2 ADC
    def offsetVsen2(self, value = None):
        value = dma_bits(0xE71F, self.address, 8, 16, value)
        return(value)
    ## Signed Digital Offset applied to vSen1 ADC
    def offsetVsen1(self, value = None):
        value = dma_bits(0xE71F, self.address, 8, 8, value)
        return(value)
    ## Signed Digital Offset applied to vSen0 ADC
    def offsetVsen0(self, value = None):
        value = dma_bits(0xE71F, self.address, 8, 0, value)
        return(value)

###################################################################
## Select telemetry input analog pathways (see rDCRFILTRES2 for user config store)
###################################################################
class selVinIinTref_class(object):
    def __init__(self, address):
        self.interface = 'anaCfgChip'
        self.address = address
        self.bits = 3

    def __call__(self, value = None):
        value = dma(self.address, 0xE720, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class selVinIinTref_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE720, None)
            self.useIntVin0DivHV = (self.reg_value >> 2) & 0x1
            self.useExtVin0DivHV = (self.reg_value >> 1) & 0x1
            self.useExtVin0DivLV = self.reg_value & 0x1

    def read_object(self):
        return(self.selVinIinTref_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3) + ((register_object.useIntVin0DivHV & 0x1) << 2)
        reg = (reg & 0x5) + ((register_object.useExtVin0DivHV & 0x1) << 1)
        reg = (reg & 0x6) + (register_object.useExtVin0DivLV & 0x1)
        dma(self.address, 0xE720, reg)
    ## Use Internal Divided HV Vin0 Sensor
    def useIntVin0DivHV(self, value = None):
        value = dma_bits(0xE720, self.address, 1, 2, value)
        return(value)
    ## Use External Divided HV Vin0 Sensor
    def useExtVin0DivHV(self, value = None):
        value = dma_bits(0xE720, self.address, 1, 1, value)
        return(value)
    ## Use External Divided LV Vin0 Sensor
    def useExtVin0DivLV(self, value = None):
        value = dma_bits(0xE720, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class comClkTest_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 2

    def __call__(self, value = None):
        value = dma(self.address, 0xE721, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class comClkTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE721, None)
            self.oscAmpBypass = (self.reg_value >> 1) & 0x1
            self.oscBypass = self.reg_value & 0x1

    def read_object(self):
        return(self.comClkTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1) + ((register_object.oscAmpBypass & 0x1) << 1)
        reg = (reg & 0x2) + (register_object.oscBypass & 0x1)
        dma(self.address, 0xE721, reg)
    ## Test pin Bypass oscLDO output with AVDD
    def oscAmpBypass(self, value = None):
        value = dma_bits(0xE721, self.address, 1, 1, value)
        return(value)
    ## Test pin Bypass for clock oscillator
    def oscBypass(self, value = None):
        value = dma_bits(0xE721, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telCfg_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 2

    def __call__(self, value = None):
        value = dma(self.address, 0xE722, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE722, None)
            self.telMuxRstEn = (self.reg_value >> 1) & 0x1
            self.telSkipRstSt = self.reg_value & 0x1

    def read_object(self):
        return(self.telCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1) + ((register_object.telMuxRstEn & 0x1) << 1)
        reg = (reg & 0x2) + (register_object.telSkipRstSt & 0x1)
        dma(self.address, 0xE722, reg)
    ## Enable MUX to reset everytime
    def telMuxRstEn(self, value = None):
        value = dma_bits(0xE722, self.address, 1, 1, value)
        return(value)
    ## 1=Skip reset state in telemetry adc controller
    def telSkipRstSt(self, value = None):
        value = dma_bits(0xE722, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class ana1Shot_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 3

    def __call__(self, value = None):
        value = dma(self.address, 0xE723, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ana1Shot_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE723, None)
            self.clearAVDD18Valid = (self.reg_value >> 2) & 0x1
            self.pwmDllCal = (self.reg_value >> 1) & 0x1
            self.swBgFastSettle = self.reg_value & 0x1

    def read_object(self):
        return(self.ana1Shot_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3) + ((register_object.clearAVDD18Valid & 0x1) << 2)
        reg = (reg & 0x5) + ((register_object.pwmDllCal & 0x1) << 1)
        reg = (reg & 0x6) + (register_object.swBgFastSettle & 0x1)
        dma(self.address, 0xE723, reg)
    ## See MBIRD-1775 <BR> If set, reset the avdd18Valid Latch which gets held high anytime AVDD18Valid goes low
    def clearAVDD18Valid(self, value = None):
        value = dma_bits(0xE723, self.address, 1, 2, value)
        return(value)
    ## If set, reset the pwmDLL cal counter and cal the del DAC's for 256 clkTs again
    def pwmDllCal(self, value = None):
        value = dma_bits(0xE723, self.address, 1, 1, value)
        return(value)
    ## If set, reset the swBgFstStl counter so that the swBg has low output impedance again for the fst settle time
    def swBgFastSettle(self, value = None):
        value = dma_bits(0xE723, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class telTest_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 6

    def __call__(self, value = None):
        value = dma(self.address, 0xE724, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE724, None)
            self.shCompStg1Tel = (self.reg_value >> 5) & 0x1
            self.shCompStg0Tel = (self.reg_value >> 4) & 0x1
            self.openTelP = (self.reg_value >> 3) & 0x1
            self.openTelN = (self.reg_value >> 2) & 0x1
            self.shortTelIn = (self.reg_value >> 1) & 0x1
            self.tstDacSelTel = self.reg_value & 0x1

    def read_object(self):
        return(self.telTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.shCompStg1Tel & 0x1) << 5)
        reg = (reg & 0x2F) + ((register_object.shCompStg0Tel & 0x1) << 4)
        reg = (reg & 0x37) + ((register_object.openTelP & 0x1) << 3)
        reg = (reg & 0x3B) + ((register_object.openTelN & 0x1) << 2)
        reg = (reg & 0x3D) + ((register_object.shortTelIn & 0x1) << 1)
        reg = (reg & 0x3E) + (register_object.tstDacSelTel & 0x1)
        dma(self.address, 0xE724, reg)
    ## force comp stage1 to reset state
    def shCompStg1Tel(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 5, value)
        return(value)
    ## force comp stage0 to reset state
    def shCompStg0Tel(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 4, value)
        return(value)
    ## open connection to telP pin
    def openTelP(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 3, value)
        return(value)
    ## open connection to telN pin
    def openTelN(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 2, value)
        return(value)
    ## short internal tel+ to tel-
    def shortTelIn(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 1, value)
        return(value)
    def tstDacSelTel(self, value = None):
        value = dma_bits(0xE724, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class iSenTest_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE725, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE725, None)
            self.memTestMode = (self.reg_value >> 30) & 0x3
            self.shCompStg1Isen3 = (self.reg_value >> 15) & 0x1
            self.shCompStg0Isen3 = (self.reg_value >> 14) & 0x1
            self.phIpShort3 = (self.reg_value >> 12) & 0x3
            self.shCompStg1Isen2 = (self.reg_value >> 11) & 0x1
            self.shCompStg0Isen2 = (self.reg_value >> 10) & 0x1
            self.phIpShort2 = (self.reg_value >> 8) & 0x3
            self.shCompStg1Isen1 = (self.reg_value >> 7) & 0x1
            self.shCompStg0Isen1 = (self.reg_value >> 6) & 0x1
            self.phIpShort1 = (self.reg_value >> 4) & 0x3
            self.shCompStg1Isen0 = (self.reg_value >> 3) & 0x1
            self.shCompStg0Isen0 = (self.reg_value >> 2) & 0x1
            self.phIpShort0 = self.reg_value & 0x3

    def read_object(self):
        return(self.iSenTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.memTestMode & 0x3) << 30)
        reg = (reg & 0xFFFF7FFF) + ((register_object.shCompStg1Isen3 & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.shCompStg0Isen3 & 0x1) << 14)
        reg = (reg & 0xFFFFCFFF) + ((register_object.phIpShort3 & 0x3) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.shCompStg1Isen2 & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.shCompStg0Isen2 & 0x1) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.phIpShort2 & 0x3) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.shCompStg1Isen1 & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.shCompStg0Isen1 & 0x1) << 6)
        reg = (reg & 0xFFFFFFCF) + ((register_object.phIpShort1 & 0x3) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.shCompStg1Isen0 & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.shCompStg0Isen0 & 0x1) << 2)
        reg = (reg & 0xFFFFFFFC) + (register_object.phIpShort0 & 0x3)
        dma(self.address, 0xE725, reg)
    ## 0:Disabled   1:Use M0 offset for ph0/1 and M1 offset for ph2/3 <BR> 2:Use M0 offset for ph0/2 and M1 offset for ph1/3 <BR> 3:Use M0 offset for ph0/3 and M1 offset for ph1/2
    def memTestMode(self, value = None):
        value = dma_bits(0xE725, self.address, 2, 30, value)
        return(value)
    def shCompStg1Isen3(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 15, value)
        return(value)
    def shCompStg0Isen3(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 14, value)
        return(value)
    def phIpShort3(self, value = None):
        value = dma_bits(0xE725, self.address, 2, 12, value)
        return(value)
    def shCompStg1Isen2(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 11, value)
        return(value)
    def shCompStg0Isen2(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 10, value)
        return(value)
    def phIpShort2(self, value = None):
        value = dma_bits(0xE725, self.address, 2, 8, value)
        return(value)
    def shCompStg1Isen1(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 7, value)
        return(value)
    def shCompStg0Isen1(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 6, value)
        return(value)
    def phIpShort1(self, value = None):
        value = dma_bits(0xE725, self.address, 2, 4, value)
        return(value)
    def shCompStg1Isen0(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 3, value)
        return(value)
    def shCompStg0Isen0(self, value = None):
        value = dma_bits(0xE725, self.address, 1, 2, value)
        return(value)
    def phIpShort0(self, value = None):
        value = dma_bits(0xE725, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class testCtl_class(object):
    def __init__(self, address):
        self.interface = 'anaFac'
        self.address = address
        self.bits = 3

    def __call__(self, value = None):
        value = dma(self.address, 0xE726, value)
        return(value)


###################################################################
## this register allows readback of clk sync blocks and azFiltData and swCapBgData
###################################################################
class anaClkLock_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE727, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class anaClkLock_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE727, None)
            self.avdd18ValidLatch = (self.reg_value >> 27) & 0x1
            self.telOffCapCode = (self.reg_value >> 16) & 0x7FF
            self.dllPwmLocked = (self.reg_value >> 14) & 0x3
            self.dllLocked = (self.reg_value >> 12) & 0x3
            self.dllFault = (self.reg_value >> 11) & 0x1
            self.swDataOut = (self.reg_value >> 9) & 0x3
            self.vSen2DataValid = (self.reg_value >> 8) & 0x1
            self.vSen1DataValid = (self.reg_value >> 7) & 0x1
            self.vSen0DataValid = (self.reg_value >> 6) & 0x1
            self.vSen2Clip = (self.reg_value >> 4) & 0x3
            self.vSen1Clip = (self.reg_value >> 2) & 0x3
            self.vSen0Clip = self.reg_value & 0x3

    def read_object(self):
        return(self.anaClkLock_Object(self.address))

    ## Readback of latch which gets set when avdd18Valid goes low
    def avdd18ValidLatch(self):
        value = dma_bits(0xE727, self.address, 1, 27, None)
        return(value)
    ## Readback of current tel compOffCapCode
    def telOffCapCode(self):
        value = dma_bits(0xE727, self.address, 11, 16, None)
        return(value)
    ## Readback adc dll clk fault
    def dllPwmLocked(self):
        value = dma_bits(0xE727, self.address, 2, 14, None)
        return(value)
    ## Readback adc dll clk fault
    def dllLocked(self):
        value = dma_bits(0xE727, self.address, 2, 12, None)
        return(value)
    ## Readback adc dll clk fault
    def dllFault(self):
        value = dma_bits(0xE727, self.address, 1, 11, None)
        return(value)
    ## Readback vSen adc dataValid
    def swDataOut(self):
        value = dma_bits(0xE727, self.address, 2, 9, None)
        return(value)
    ## Readback vSen adc dataValid
    def vSen2DataValid(self):
        value = dma_bits(0xE727, self.address, 1, 8, None)
        return(value)
    ## Readback vSen adc dataValid
    def vSen1DataValid(self):
        value = dma_bits(0xE727, self.address, 1, 7, None)
        return(value)
    ## Readback vSen adc dataValid
    def vSen0DataValid(self):
        value = dma_bits(0xE727, self.address, 1, 6, None)
        return(value)
    ## Readback vSen adc clip detect
    def vSen2Clip(self):
        value = dma_bits(0xE727, self.address, 2, 4, None)
        return(value)
    ## Readback vSen adc clip detect
    def vSen1Clip(self):
        value = dma_bits(0xE727, self.address, 2, 2, None)
        return(value)
    ## Readback vSen adc clip detect
    def vSen0Clip(self):
        value = dma_bits(0xE727, self.address, 2, 0, None)
        return(value)

###################################################################
## this register allows readback of clk sync blocks and azFiltData and swCapBgData
###################################################################
class anaIsenClip_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE728, value)
        return(value)


###################################################################
## 
###################################################################
class atbSelMisc_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xE729, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbSelMisc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE729, None)
            self.dllPwmAtb = (self.reg_value >> 20) & 0x3
            self.dllAtbTest = (self.reg_value >> 18) & 0x3
            self.testBip = (self.reg_value >> 16) & 0x3
            self.swBgAtbTest = (self.reg_value >> 13) & 0x7
            self.atbRef = (self.reg_value >> 10) & 0x7
            self.TmpAddrCfg = (self.reg_value >> 9) & 0x1
            self.Ldo = (self.reg_value >> 5) & 0xF
            self.currDist = (self.reg_value >> 3) & 0x3
            self.VinIin = self.reg_value & 0x7

    def read_object(self):
        return(self.atbSelMisc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.dllPwmAtb & 0x3) << 20)
        reg = (reg & 0x33FFFF) + ((register_object.dllAtbTest & 0x3) << 18)
        reg = (reg & 0x3CFFFF) + ((register_object.testBip & 0x3) << 16)
        reg = (reg & 0x3F1FFF) + ((register_object.swBgAtbTest & 0x7) << 13)
        reg = (reg & 0x3FE3FF) + ((register_object.atbRef & 0x7) << 10)
        reg = (reg & 0x3FFDFF) + ((register_object.TmpAddrCfg & 0x1) << 9)
        reg = (reg & 0x3FFE1F) + ((register_object.Ldo & 0xF) << 5)
        reg = (reg & 0x3FFFE7) + ((register_object.currDist & 0x3) << 3)
        reg = (reg & 0x3FFFF8) + (register_object.VinIin & 0x7)
        dma(self.address, 0xE729, reg)
    ## ATB/Test select for PWM dll <BR>  0-OFF <BR>  1-ATBP:dutyCycle ATBN: dllGnd<BR>  2-ATBP:VCCS ATBN: dllGnd<BR>  3-ATBP:dllGnd  ATBN: dllGnd
    def dllPwmAtb(self, value = None):
        value = dma_bits(0xE729, self.address, 2, 20, value)
        return(value)
    ## ATB/Test select for dll <BR>  0-OFF <BR>  1-ATBP:dutyCycle ATBN: dllGnd<BR>  2-ATBP:VCCS ATBN: dllGnd<BR>  3-ATBP:dllGnd  ATBN: dllGnd
    def dllAtbTest(self, value = None):
        value = dma_bits(0xE729, self.address, 2, 18, value)
        return(value)
    ## ATB/Test select for testing Bipolar voltages
    def testBip(self, value = None):
        value = dma_bits(0xE729, self.address, 2, 16, value)
        return(value)
    ## ATB/Test select for swBg <BR>  0-OFF  <BR> 1-Hi-Z  <BR>2/3- ATBP:Vb ATBN: swBgGnd<BR>  4-ATBP:vBgAdc ATBN: swBgGnd<BR>  5-ATBP:vAmp(Source follower) ATBN: swBgGnd<BR> 6-ATBP:swBgGnd(Source follower) ATBN: swBgGnd<BR>  7-ATBP:ATBN(source follower) ATBN: Hi-Z
    def swBgAtbTest(self, value = None):
        value = dma_bits(0xE729, self.address, 3, 13, value)
        return(value)
    ## ATB select for anaAtbRef
    def atbRef(self, value = None):
        value = dma_bits(0xE729, self.address, 3, 10, value)
        return(value)
    ## Output iTmpAddrCfg(trimmed)*R on atbP and AGND on atbN of 3.3V North testbus
    def TmpAddrCfg(self, value = None):
        value = dma_bits(0xE729, self.address, 1, 9, value)
        return(value)
    ## Output iBg30u(trimmed)*R on atbP and AGND on atbN of 3.3V North testbus <BR> bit3 used to select inv Vcm as input
    def Ldo(self, value = None):
        value = dma_bits(0xE729, self.address, 4, 5, value)
        return(value)
    ## ATB selects for anaCurrDist
    def currDist(self, value = None):
        value = dma_bits(0xE729, self.address, 2, 3, value)
        return(value)
    ## ATB selects for anaVinIin
    def VinIin(self, value = None):
        value = dma_bits(0xE729, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class testMisc_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE72A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class testMisc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72A, None)
            self.svdBypass = (self.reg_value >> 10) & 0x1
            self.tmonBypassDig = (self.reg_value >> 7) & 0x7
            self.clkDataRaw = (self.reg_value >> 6) & 0x1
            self.clkDataLatch = (self.reg_value >> 5) & 0x1
            self.unUsed1 = self.reg_value & 0x1F

    def read_object(self):
        return(self.testMisc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.svdBypass & 0x1) << 10)
        reg = (reg & 0x47F) + ((register_object.tmonBypassDig & 0x7) << 7)
        reg = (reg & 0x7BF) + ((register_object.clkDataRaw & 0x1) << 6)
        reg = (reg & 0x7DF) + ((register_object.clkDataLatch & 0x1) << 5)
        reg = (reg & 0x7E0) + (register_object.unUsed1 & 0x1F)
        dma(self.address, 0xE72A, reg)
    ## Setting to 1 bypasses the comparator in the SVC pad
    def svdBypass(self, value = None):
        value = dma_bits(0xE72A, self.address, 1, 10, value)
        return(value)
    ## Tmon Bypass
    def tmonBypassDig(self, value = None):
        value = dma_bits(0xE72A, self.address, 3, 7, value)
        return(value)
    ## Setting to 1 allows raw data on the anaClkLock flops with no latching effect
    def clkDataRaw(self, value = None):
        value = dma_bits(0xE72A, self.address, 1, 6, value)
        return(value)
    ## Setting to 1 creates a one-shot which resets the anaClkLock flops to the current values
    def clkDataLatch(self, value = None):
        value = dma_bits(0xE72A, self.address, 1, 5, value)
        return(value)
    ## Unused
    def unUsed1(self, value = None):
        value = dma_bits(0xE72A, self.address, 5, 0, value)
        return(value)

###################################################################
## 
###################################################################
class atbSelCom_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 21

    def __call__(self, value = None):
        value = dma(self.address, 0xE72B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbSelCom_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72B, None)
            self.intTmp = (self.reg_value >> 20) & 0x1
            self.refV = (self.reg_value >> 17) & 0x7
            self.refBg2 = (self.reg_value >> 12) & 0x1F
            self.refIbg = (self.reg_value >> 9) & 0x7
            self.refBias = (self.reg_value >> 6) & 0x7
            self.clkPll = (self.reg_value >> 1) & 0x1F
            self.clkOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.atbSelCom_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.intTmp & 0x1) << 20)
        reg = (reg & 0x11FFFF) + ((register_object.refV & 0x7) << 17)
        reg = (reg & 0x1E0FFF) + ((register_object.refBg2 & 0x1F) << 12)
        reg = (reg & 0x1FF1FF) + ((register_object.refIbg & 0x7) << 9)
        reg = (reg & 0x1FFE3F) + ((register_object.refBias & 0x7) << 6)
        reg = (reg & 0x1FFFC1) + ((register_object.clkPll & 0x1F) << 1)
        reg = (reg & 0x1FFFFE) + (register_object.clkOsc & 0x1)
        dma(self.address, 0xE72B, reg)
    ## Output [vTemp,gTemp] for 1
    def intTmp(self, value = None):
        value = dma_bits(0xE72B, self.address, 1, 20, value)
        return(value)
    ## Drive selected (one-hot) output onto 3.3V testbus  <BR> 0: None <BR> 1: iRef <BR> 2: AVDD33 <BR> 3: vReplica
    def refV(self, value = None):
        value = dma_bits(0xE72B, self.address, 3, 17, value)
        return(value)
    ## Drive selected (one-hot) output onto 3.3V testbus <BR> 0: None <BR> 1:AVDD33 <BR> 2:iCtat <BR> 3:iPtat <BR> 4:Buffered GND <BR> 5:Buffered GND <BR> 6:Buffered GND <BR> 7:Buffered GND <BR> 8:Buffered vBgRef <BR> 9:Buffered vDiode <BR> 10:Buffered vBgRef <BR> 11:Buffered vBgRef <BR> 12:Buffered VDD <BR> 13:VDD <BR> 14:Buffered VDD <BR> 15:Buffered VDD
    def refBg2(self, value = None):
        value = dma_bits(0xE72B, self.address, 5, 12, value)
        return(value)
    ## Drive selected (one-hot) output onto 3.3V testbus <BR> 0: None <BR> 1:AVDD33 <BR> 2:iCtat <BR> 3:iPtat <BR> 4:Buffered GND <BR> 5:Buffered GND <BR> 6:Buffered GND <BR> 7:Buffered GND <BR> 8:Buffered vBgRef <BR> 9:Buffered vDiode <BR> 10:Buffered vBgRef <BR> 11:Buffered vBgRef <BR> 12:Buffered VDD <BR> 13:VDD <BR> 14:Buffered VDD <BR> 15:Buffered VDD
    def refIbg(self, value = None):
        value = dma_bits(0xE72B, self.address, 3, 9, value)
        return(value)
    ## Drive selected (one-hot) output onto 3.3V testbus  <BR> 0: None <BR> 1: iRef <BR> 2: AVDD33 <BR> 3: vReplica
    def refBias(self, value = None):
        value = dma_bits(0xE72B, self.address, 3, 6, value)
        return(value)
    ## TBD on 1.2V testbus
    def clkPll(self, value = None):
        value = dma_bits(0xE72B, self.address, 5, 1, value)
        return(value)
    ## Output Oscillator Internal LDO output on atbP and AGND on atbN of 1.2V testbus
    def clkOsc(self, value = None):
        value = dma_bits(0xE72B, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class atbSelAdc_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE72C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbSelAdc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72C, None)
            self.telAdc = (self.reg_value >> 24) & 0xF
            self.iSenAdc3 = (self.reg_value >> 21) & 0x7
            self.iSenAdc2 = (self.reg_value >> 18) & 0x7
            self.iSenAdc1 = (self.reg_value >> 15) & 0x7
            self.iSenAdc0 = (self.reg_value >> 12) & 0x7
            self.vSenAdc2 = (self.reg_value >> 8) & 0xF
            self.vSenAdc1 = (self.reg_value >> 4) & 0xF
            self.vSenAdc0 = self.reg_value & 0xF

    def read_object(self):
        return(self.atbSelAdc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.telAdc & 0xF) << 24)
        reg = (reg & 0xF1FFFFF) + ((register_object.iSenAdc3 & 0x7) << 21)
        reg = (reg & 0xFE3FFFF) + ((register_object.iSenAdc2 & 0x7) << 18)
        reg = (reg & 0xFFC7FFF) + ((register_object.iSenAdc1 & 0x7) << 15)
        reg = (reg & 0xFFF8FFF) + ((register_object.iSenAdc0 & 0x7) << 12)
        reg = (reg & 0xFFFF0FF) + ((register_object.vSenAdc2 & 0xF) << 8)
        reg = (reg & 0xFFFFF0F) + ((register_object.vSenAdc1 & 0xF) << 4)
        reg = (reg & 0xFFFFFF0) + (register_object.vSenAdc0 & 0xF)
        dma(self.address, 0xE72C, reg)
    ## Output to ATB: 0,3-7,13-15=HiZ; 1=vRef post-buffer; 2=vRef pre-buffer; 8=comp amp0 tailV; 9=comp amp0 vCm; 10=comp amp1 tailV; 11=comp amp1 vCm; 12=vRefN post-buf
    def telAdc(self, value = None):
        value = dma_bits(0xE72C, self.address, 4, 24, value)
        return(value)
    ## Output to ATB:<br>001= vRef pre-buffer;<br>010= vRef post-buffer;<br>011= HiZ;<br>100=comp amp0 tailV;<br>101= comp amp0 vCm;<br>110= comp amp1 tailV;<br>111= comp amp1 vCm;
    def iSenAdc3(self, value = None):
        value = dma_bits(0xE72C, self.address, 3, 21, value)
        return(value)
    ## Output to ATB:<br>001= vRef pre-buffer;<br>010= vRef post-buffer;<br>011= HiZ;<br>100=comp amp0 tailV;<br>101= comp amp0 vCm;<br>110= comp amp1 tailV;<br>111= comp amp1 vCm;
    def iSenAdc2(self, value = None):
        value = dma_bits(0xE72C, self.address, 3, 18, value)
        return(value)
    ## Output to ATB:<br>001= vRef pre-buffer;<br>010= vRef post-buffer;<br>011= HiZ;<br>100=comp amp0 tailV;<br>101= comp amp0 vCm;<br>110= comp amp1 tailV;<br>111= comp amp1 vCm;
    def iSenAdc1(self, value = None):
        value = dma_bits(0xE72C, self.address, 3, 15, value)
        return(value)
    ## Output to ATB:<br>001= vRef pre-buffer;<br>010= vRef post-buffer;<br>011= HiZ;<br>100=comp amp0 tailV;<br>101= comp amp0 vCm;<br>110= comp amp1 tailV;<br>111= comp amp1 vCm;
    def iSenAdc0(self, value = None):
        value = dma_bits(0xE72C, self.address, 3, 12, value)
        return(value)
    ## Output to ATB:<br>001= vRef post-buffer;<br>010= vRef pre-buffer;<br>011= HiZ;<br>1000=comp amp0 tailV;<br>1001= comp amp0 vCm;<br>1010= comp amp1 tailV;<br>1011= comp amp1 vCm;<br> 1100= refN;
    def vSenAdc2(self, value = None):
        value = dma_bits(0xE72C, self.address, 4, 8, value)
        return(value)
    ## Output to ATB:<br>001= vRef post-buffer;<br>010= vRef pre-buffer;<br>011= HiZ;<br>1000=comp amp0 tailV;<br>1001= comp amp0 vCm;<br>1010= comp amp1 tailV;<br>1011= comp amp1 vCm;<br> 1100= refN;
    def vSenAdc1(self, value = None):
        value = dma_bits(0xE72C, self.address, 4, 4, value)
        return(value)
    ## Output to ATB:<br>001= vRef post-buffer;<br>010= vRef pre-buffer;<br>011= HiZ;<br>1000=comp amp0 tailV;<br>1001= comp amp0 vCm;<br>1010= comp amp1 tailV;<br>1011= comp amp1 vCm;<br> 1100= refN;
    def vSenAdc0(self, value = None):
        value = dma_bits(0xE72C, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class atbSelIsenComp_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE72D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbSelIsenComp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72D, None)
            self.iSenAdcComp3 = (self.reg_value >> 12) & 0xF
            self.iSenAdcComp2 = (self.reg_value >> 8) & 0xF
            self.iSenAdcComp1 = (self.reg_value >> 4) & 0xF
            self.iSenAdcComp0 = self.reg_value & 0xF

    def read_object(self):
        return(self.atbSelIsenComp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.iSenAdcComp3 & 0xF) << 12)
        reg = (reg & 0xF0FF) + ((register_object.iSenAdcComp2 & 0xF) << 8)
        reg = (reg & 0xFF0F) + ((register_object.iSenAdcComp1 & 0xF) << 4)
        reg = (reg & 0xFFF0) + (register_object.iSenAdcComp0 & 0xF)
        dma(self.address, 0xE72D, reg)
    def iSenAdcComp3(self, value = None):
        value = dma_bits(0xE72D, self.address, 4, 12, value)
        return(value)
    def iSenAdcComp2(self, value = None):
        value = dma_bits(0xE72D, self.address, 4, 8, value)
        return(value)
    def iSenAdcComp1(self, value = None):
        value = dma_bits(0xE72D, self.address, 4, 4, value)
        return(value)
    def iSenAdcComp0(self, value = None):
        value = dma_bits(0xE72D, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class atbSelIsen_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE72E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbSelIsen_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72E, None)
            self.iSenAdc3 = (self.reg_value >> 12) & 0xF
            self.iSenAdc2 = (self.reg_value >> 8) & 0xF
            self.iSenAdc1 = (self.reg_value >> 4) & 0xF
            self.iSenAdc0 = self.reg_value & 0xF

    def read_object(self):
        return(self.atbSelIsen_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.iSenAdc3 & 0xF) << 12)
        reg = (reg & 0xF0FF) + ((register_object.iSenAdc2 & 0xF) << 8)
        reg = (reg & 0xFF0F) + ((register_object.iSenAdc1 & 0xF) << 4)
        reg = (reg & 0xFFF0) + (register_object.iSenAdc0 & 0xF)
        dma(self.address, 0xE72E, reg)
    def iSenAdc3(self, value = None):
        value = dma_bits(0xE72E, self.address, 4, 12, value)
        return(value)
    def iSenAdc2(self, value = None):
        value = dma_bits(0xE72E, self.address, 4, 8, value)
        return(value)
    def iSenAdc1(self, value = None):
        value = dma_bits(0xE72E, self.address, 4, 4, value)
        return(value)
    def iSenAdc0(self, value = None):
        value = dma_bits(0xE72E, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class atbMux_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE72F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class atbMux_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE72F, None)
            self.atbNPadSel = (self.reg_value >> 17) & 0x3
            self.telMuxEn = (self.reg_value >> 16) & 0x1
            self.telAtbEn = (self.reg_value >> 15) & 0x1
            self.i2vResSel = (self.reg_value >> 12) & 0x7
            self.anaAtbSel = (self.reg_value >> 3) & 0x1FF
            self.atbNEn = (self.reg_value >> 2) & 0x1
            self.atbPEn = (self.reg_value >> 1) & 0x1
            self.atb1p2ClampByp = self.reg_value & 0x1

    def read_object(self):
        return(self.atbMux_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFF) + ((register_object.atbNPadSel & 0x3) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.telMuxEn & 0x1) << 16)
        reg = (reg & 0x77FFF) + ((register_object.telAtbEn & 0x1) << 15)
        reg = (reg & 0x78FFF) + ((register_object.i2vResSel & 0x7) << 12)
        reg = (reg & 0x7F007) + ((register_object.anaAtbSel & 0x1FF) << 3)
        reg = (reg & 0x7FFFB) + ((register_object.atbNEn & 0x1) << 2)
        reg = (reg & 0x7FFFD) + ((register_object.atbPEn & 0x1) << 1)
        reg = (reg & 0x7FFFE) + (register_object.atb1p2ClampByp & 0x1)
        dma(self.address, 0xE72F, reg)
    ## NA-NOT USED in MB ATBN only tied to TEMP0 ... legacy ATBN pad select 00: CFGSEL; 01: TEMP1; 10: TEMP0
    def atbNPadSel(self, value = None):
        value = dma_bits(0xE72F, self.address, 2, 17, value)
        return(value)
    ## Enable pass-gate switch at output of Telemetry mux (Default= 1)
    def telMuxEn(self, value = None):
        value = dma_bits(0xE72F, self.address, 1, 16, value)
        return(value)
    ## Enable pass-gate switch from Telemetry mux to 3.3V ATBus
    def telAtbEn(self, value = None):
        value = dma_bits(0xE72F, self.address, 1, 15, value)
        return(value)
    ## Multi-hot select for resistor to programmable source/sink: [5:0]= {AVDD33, AVDD, AGND}
    def i2vResSel(self, value = None):
        value = dma_bits(0xE72F, self.address, 3, 12, value)
        return(value)
    ## Multi-hot selects for ATBus switches:<br>[11:9] {8:6}= 3.3V {Bot, Com, Top};<br>[8:6] {5:3}= 1.2V {Bot, Com, Top};<br>[5] {2}= 1.2V enable;<br>[4:3] {1:0} = {atbNOut, atbPOut}
    def anaAtbSel(self, value = None):
        value = dma_bits(0xE72F, self.address, 9, 3, value)
        return(value)
    ## Active high enable for atbN bus: when LOW, drive atb1p2N and atb3p3N to AGND
    def atbNEn(self, value = None):
        value = dma_bits(0xE72F, self.address, 1, 2, value)
        return(value)
    ## Active high enable for atbP bus: when LOW, drive atb1p2P and atb3p3P to AGND
    def atbPEn(self, value = None):
        value = dma_bits(0xE72F, self.address, 1, 1, value)
        return(value)
    ## Bypass the clamp circuit in anaAtb to clamp 1.2V ATBus
    def atb1p2ClampByp(self, value = None):
        value = dma_bits(0xE72F, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class pullDownCs_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE730, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pullDownCs_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE730, None)
            self.pdCs7 = (self.reg_value >> 7) & 0x1
            self.pdCs6 = (self.reg_value >> 6) & 0x1
            self.pdCs5 = (self.reg_value >> 5) & 0x1
            self.pdCs4 = (self.reg_value >> 4) & 0x1
            self.pdCs3 = (self.reg_value >> 3) & 0x1
            self.pdCs2 = (self.reg_value >> 2) & 0x1
            self.pdCs1 = (self.reg_value >> 1) & 0x1
            self.pdCs0 = self.reg_value & 0x1

    def read_object(self):
        return(self.pullDownCs_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.pdCs7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.pdCs6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.pdCs5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.pdCs4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.pdCs3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.pdCs2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.pdCs1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.pdCs0 & 0x1)
        dma(self.address, 0xE730, reg)
    ## Pull down for CS7
    def pdCs7(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 7, value)
        return(value)
    ## Pull down for CS6
    def pdCs6(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 6, value)
        return(value)
    ## Pull down for CS5
    def pdCs5(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 5, value)
        return(value)
    ## Pull down for CS4
    def pdCs4(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 4, value)
        return(value)
    ## Pull down for CS3
    def pdCs3(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 3, value)
        return(value)
    ## Pull down for CS2
    def pdCs2(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 2, value)
        return(value)
    ## Pull down for CS1
    def pdCs1(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 1, value)
        return(value)
    ## Pull down for CS0
    def pdCs0(self, value = None):
        value = dma_bits(0xE730, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class pullDownPwm_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE731, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pullDownPwm_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE731, None)
            self.pwmPadPE7 = (self.reg_value >> 7) & 0x1
            self.pwmPadPE6 = (self.reg_value >> 6) & 0x1
            self.pwmPadPE5 = (self.reg_value >> 5) & 0x1
            self.pwmPadPE4 = (self.reg_value >> 4) & 0x1
            self.pwmPadPE3 = (self.reg_value >> 3) & 0x1
            self.pwmPadPE2 = (self.reg_value >> 2) & 0x1
            self.pwmPadPE1 = (self.reg_value >> 1) & 0x1
            self.pwmPadPE0 = self.reg_value & 0x1

    def read_object(self):
        return(self.pullDownPwm_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.pwmPadPE7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.pwmPadPE6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.pwmPadPE5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.pwmPadPE4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.pwmPadPE3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.pwmPadPE2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.pwmPadPE1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.pwmPadPE0 & 0x1)
        dma(self.address, 0xE731, reg)
    ## Pull down for PWM7
    def pwmPadPE7(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 7, value)
        return(value)
    ## Pull down for PWM6
    def pwmPadPE6(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 6, value)
        return(value)
    ## Pull down for PWM5
    def pwmPadPE5(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 5, value)
        return(value)
    ## Pull down for PWM4
    def pwmPadPE4(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 4, value)
        return(value)
    ## Pull down for PWM3
    def pwmPadPE3(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 3, value)
        return(value)
    ## Pull down for PWM2
    def pwmPadPE2(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 2, value)
        return(value)
    ## Pull down for PWM1
    def pwmPadPE1(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 1, value)
        return(value)
    ## Pull down for PWM0
    def pwmPadPE0(self, value = None):
        value = dma_bits(0xE731, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class pullDownA_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE732, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pullDownA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE732, None)
            self.sdifDataPadPE = (self.reg_value >> 31) & 0x1
            self.sdifClkPadPE = (self.reg_value >> 30) & 0x1
            self.pdRgnd2 = (self.reg_value >> 29) & 0x1
            self.pdRgnd1 = (self.reg_value >> 28) & 0x1
            self.pdRgnd0 = (self.reg_value >> 27) & 0x1
            self.pdVsen2 = (self.reg_value >> 26) & 0x1
            self.pdVsen1 = (self.reg_value >> 25) & 0x1
            self.pdVsen0 = (self.reg_value >> 24) & 0x1
            self.tempPadPd2 = (self.reg_value >> 23) & 0x1
            self.tempPadPd1 = (self.reg_value >> 22) & 0x1
            self.tempPadPd0 = (self.reg_value >> 21) & 0x1
            self.dio0PadPE = (self.reg_value >> 20) & 0x1
            self.svicPadPD = (self.reg_value >> 19) & 0x1
            self.svidPadPE = (self.reg_value >> 18) & 0x1
            self.svitiPadPD = (self.reg_value >> 17) & 0x1
            self.svitoPadPE = (self.reg_value >> 16) & 0x1
            self.dio5PadPE = (self.reg_value >> 15) & 0x1
            self.diopg3PadPE = (self.reg_value >> 14) & 0x1
            self.diopg7PadPE = (self.reg_value >> 13) & 0x1
            self.diopg1PadPE = (self.reg_value >> 12) & 0x1
            self.dioe4PadPE = (self.reg_value >> 11) & 0x1
            self.dioe11PadPE = (self.reg_value >> 10) & 0x1
            self.dioe2PadPE = (self.reg_value >> 9) & 0x1
            self.cfpPadPE = (self.reg_value >> 8) & 0x1
            self.dio6PadPE = (self.reg_value >> 7) & 0x1
            self.dior8PadPE = (self.reg_value >> 6) & 0x1
            self.pdConfigSel = (self.reg_value >> 5) & 0x1
            self.pdAddress = (self.reg_value >> 4) & 0x1
            self.pdIinSen0Lv = (self.reg_value >> 3) & 0x1
            self.pdVinSen0Lv = (self.reg_value >> 2) & 0x1
            self.dio10PadPE = (self.reg_value >> 1) & 0x1
            self.dio9PadPE = self.reg_value & 0x1

    def read_object(self):
        return(self.pullDownA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.sdifDataPadPE & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.sdifClkPadPE & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.pdRgnd2 & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.pdRgnd1 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.pdRgnd0 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.pdVsen2 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.pdVsen1 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.pdVsen0 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.tempPadPd2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.tempPadPd1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.tempPadPd0 & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.dio0PadPE & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.svicPadPD & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.svidPadPE & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.svitiPadPD & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.svitoPadPE & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.dio5PadPE & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.diopg3PadPE & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.diopg7PadPE & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.diopg1PadPE & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.dioe4PadPE & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.dioe11PadPE & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.dioe2PadPE & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.cfpPadPE & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.dio6PadPE & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.dior8PadPE & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.pdConfigSel & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.pdAddress & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.pdIinSen0Lv & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.pdVinSen0Lv & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.dio10PadPE & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.dio9PadPE & 0x1)
        dma(self.address, 0xE732, reg)
    ## Pull down for SDIF DATA
    def sdifDataPadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 31, value)
        return(value)
    ## Pull down for SDIF CLK
    def sdifClkPadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 30, value)
        return(value)
    ## Pull down for RGND2
    def pdRgnd2(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 29, value)
        return(value)
    ## Pull down for RGND1
    def pdRgnd1(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 28, value)
        return(value)
    ## Pull down for RGND0
    def pdRgnd0(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 27, value)
        return(value)
    ## Pull down for VSEN2
    def pdVsen2(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 26, value)
        return(value)
    ## Pull down for VSEN1
    def pdVsen1(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 25, value)
        return(value)
    ## Pull down for VSEN0
    def pdVsen0(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 24, value)
        return(value)
    ## Pull down for tempPadPd2
    def tempPadPd2(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 23, value)
        return(value)
    ## Pull down for tempPadPd1
    def tempPadPd1(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 22, value)
        return(value)
    ## Pull down for tempPadPd0
    def tempPadPd0(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 21, value)
        return(value)
    ## Pull down for dio0 legacy nPMALERT
    def dio0PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 20, value)
        return(value)
    ## Pull down for SVC
    def svicPadPD(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 19, value)
        return(value)
    ## Pull down for SVD
    def svidPadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 18, value)
        return(value)
    ## Pull down for SVTI
    def svitiPadPD(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 17, value)
        return(value)
    ## Pull down for SVTO
    def svitoPadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 16, value)
        return(value)
    ## Pull down for dio5 legacy nVRHOT
    def dio5PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 15, value)
        return(value)
    ## Pull down for diopg3 legacy PG0
    def diopg3PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 14, value)
        return(value)
    ## Pull down for diopg7 legacy PG1
    def diopg7PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 13, value)
        return(value)
    ## Pull down for diopg1 legacy PG2
    def diopg1PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 12, value)
        return(value)
    ## Pull down for dioe4 legacy EN0
    def dioe4PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 11, value)
        return(value)
    ## Pull down for dioe11 legacy EN1
    def dioe11PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 10, value)
        return(value)
    ## Pull down for dioe2 legacy EN2
    def dioe2PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 9, value)
        return(value)
    ## Pull down for CFP
    def cfpPadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 8, value)
        return(value)
    ## Pull down for dio6 legacy GPIO0
    def dio6PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 7, value)
        return(value)
    ## Pull down for dior8 legacy GPIO1
    def dior8PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 6, value)
        return(value)
    ## Pull down for CONFIGSEL
    def pdConfigSel(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 5, value)
        return(value)
    ## Pull down for ADDRESS
    def pdAddress(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 4, value)
        return(value)
    ## Pull down for IINSEN0LV
    def pdIinSen0Lv(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 3, value)
        return(value)
    ## Pull down for VINSEN0LV
    def pdVinSen0Lv(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 2, value)
        return(value)
    ## Pull down for DIO10 pad
    def dio10PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 1, value)
        return(value)
    ## Pull down for DIO9 pad
    def dio9PadPE(self, value = None):
        value = dma_bits(0xE732, self.address, 1, 0, value)
        return(value)

###################################################################
## raw digVsen Data from ADC
###################################################################
class vSen0Data_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE733, value)
        return(value)


###################################################################
## raw digVsen Data from ADC
###################################################################
class vSen1Data_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE734, value)
        return(value)


###################################################################
## raw digVsen Data from ADC
###################################################################
class vSen2Data_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE735, value)
        return(value)


###################################################################
## raw digIsen Data from ADC
###################################################################
class iSen10Data_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE736, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSen10Data_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE736, None)
            self.anaiSenData1 = (self.reg_value >> 16) & 0xFFFF
            self.anaiSenData0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.iSen10Data_Object(self.address))

    ## raw digIsen Data from ADC (2 MSB's are 0)
    def anaiSenData1(self):
        value = dma_bits(0xE736, self.address, 16, 16, None)
        return(value)
    ## raw digIsen Data from ADC (2 MSB's are 0)
    def anaiSenData0(self):
        value = dma_bits(0xE736, self.address, 16, 0, None)
        return(value)

###################################################################
## raw digIsen Data from ADC
###################################################################
class iSen32Data_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE737, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSen32Data_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE737, None)
            self.anaiSenData3 = (self.reg_value >> 16) & 0xFFFF
            self.anaiSenData2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.iSen32Data_Object(self.address))

    ## raw digIsen Data from ADC (2 MSB's are 0)
    def anaiSenData3(self):
        value = dma_bits(0xE737, self.address, 16, 16, None)
        return(value)
    ## raw digIsen Data from ADC (2 MSB's are 0)
    def anaiSenData2(self):
        value = dma_bits(0xE737, self.address, 16, 0, None)
        return(value)

###################################################################
## Analog power status signals including SVC clock detector
###################################################################
class pwrStatusAna_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xE738, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrStatusAna_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE738, None)
            self.avdd18Valid = (self.reg_value >> 13) & 0x1
            self.hssNeedOsc = (self.reg_value >> 12) & 0x1
            self.clockStoppedSVI3 = (self.reg_value >> 10) & 0x3
            self.clockStoppedSVID = (self.reg_value >> 8) & 0x3
            self.svicValid = (self.reg_value >> 7) & 0x1
            self.svBiasEnable = (self.reg_value >> 6) & 0x1
            self.svicDetTrim = (self.reg_value >> 4) & 0x3
            self.svicDetEnable = (self.reg_value >> 3) & 0x1
            self.dllEnable = (self.reg_value >> 2) & 0x1
            self.swCBgEn = (self.reg_value >> 1) & 0x1
            self.oscEnable = self.reg_value & 0x1

    def read_object(self):
        return(self.pwrStatusAna_Object(self.address))

    ## vdd 1.8 volt valid
    def avdd18Valid(self):
        value = dma_bits(0xE738, self.address, 1, 13, None)
        return(value)
    ## Qualified SVID/SVI3 clock detection to wakeup oscillator
    def hssNeedOsc(self):
        value = dma_bits(0xE738, self.address, 1, 12, None)
        return(value)
    ## Clock stopped detector from SVI3
    def clockStoppedSVI3(self):
        value = dma_bits(0xE738, self.address, 2, 10, None)
        return(value)
    ## Clock stopped detector from SVID
    def clockStoppedSVID(self):
        value = dma_bits(0xE738, self.address, 2, 8, None)
        return(value)
    ## SVIC clock detector output
    def svicValid(self):
        value = dma_bits(0xE738, self.address, 1, 7, None)
        return(value)
    ## SVID threshold bias enabled
    def svBiasEnable(self):
        value = dma_bits(0xE738, self.address, 1, 6, None)
        return(value)
    ## Trim setting for SVIC clock detector
    def svicDetTrim(self):
        value = dma_bits(0xE738, self.address, 2, 4, None)
        return(value)
    ## Enable SVC clock detector
    def svicDetEnable(self):
        value = dma_bits(0xE738, self.address, 1, 3, None)
        return(value)
    ## Enable DLL clock generation and PWM delays
    def dllEnable(self):
        value = dma_bits(0xE738, self.address, 1, 2, None)
        return(value)
    ## Enable switched-capacitor bandgap reference
    def swCBgEn(self):
        value = dma_bits(0xE738, self.address, 1, 1, None)
        return(value)
    ## Enable oscillator (how are you going to read this if it is off?)
    def oscEnable(self):
        value = dma_bits(0xE738, self.address, 1, 0, None)
        return(value)

###################################################################
## ADC power control signals
###################################################################
class pwrStatusAdc_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 25

    def __call__(self, value = None):
        value = dma(self.address, 0xE739, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrStatusAdc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE739, None)
            self.autoUtcEnable = (self.reg_value >> 24) & 0x1
            self.telCompEnable = (self.reg_value >> 23) & 0x1
            self.isen3CompEnable = (self.reg_value >> 22) & 0x1
            self.isen2CompEnable = (self.reg_value >> 21) & 0x1
            self.isen1CompEnable = (self.reg_value >> 20) & 0x1
            self.isen0CompEnable = (self.reg_value >> 19) & 0x1
            self.vsen2CompEnable = (self.reg_value >> 18) & 0x1
            self.vsen1CompEnable = (self.reg_value >> 17) & 0x1
            self.vsen0CompEnable = (self.reg_value >> 16) & 0x1
            self.telDigEnable = (self.reg_value >> 15) & 0x1
            self.isen3DigEnable = (self.reg_value >> 14) & 0x1
            self.isen2DigEnable = (self.reg_value >> 13) & 0x1
            self.isen1DigEnable = (self.reg_value >> 12) & 0x1
            self.isen0DigEnable = (self.reg_value >> 11) & 0x1
            self.vsen2DigEnable = (self.reg_value >> 10) & 0x1
            self.vsen1DigEnable = (self.reg_value >> 9) & 0x1
            self.vsen0DigEnable = (self.reg_value >> 8) & 0x1
            self.telAdcEnable = (self.reg_value >> 7) & 0x1
            self.isen3AdcEnable = (self.reg_value >> 6) & 0x1
            self.isen2AdcEnable = (self.reg_value >> 5) & 0x1
            self.isen1AdcEnable = (self.reg_value >> 4) & 0x1
            self.isen0AdcEnable = (self.reg_value >> 3) & 0x1
            self.vsen2AdcEnable = (self.reg_value >> 2) & 0x1
            self.vsen1AdcEnable = (self.reg_value >> 1) & 0x1
            self.vsen0AdcEnable = self.reg_value & 0x1

    def read_object(self):
        return(self.pwrStatusAdc_Object(self.address))

    ## Manual/Automatic enable of UTC
    def autoUtcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 24, None)
        return(value)
    ## Active high enable for TEL ADC (anaTelAdc comparator)
    def telCompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 23, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen3CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 22, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen2CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 21, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen1CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 20, None)
        return(value)
    ## Active high enable for ISEN ADC0 (anaIsenAdc comparator)
    def isen0CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 19, None)
        return(value)
    ## Active high enable for VSEN ADC2 (anaVsenAdc2 comparator)
    def vsen2CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 18, None)
        return(value)
    ## Active high enable for VSEN ADC1 (anaVsenAdc1 comparator)
    def vsen1CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 17, None)
        return(value)
    ## Active high enable for VSEN ADC0 (anaVsenAdc0 comparator)
    def vsen0CompEnable(self):
        value = dma_bits(0xE739, self.address, 1, 16, None)
        return(value)
    ## Active high digital enable for TEL ADC (anaTelAdc controller)
    def telDigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 15, None)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen3DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 14, None)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen2DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 13, None)
        return(value)
    ## Active high digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen1DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 12, None)
        return(value)
    ## Active high digital enable for ISEN ADC0 (anaIsenAdc controller)
    def isen0DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 11, None)
        return(value)
    ## Active high digital enable for VSEN ADC2 (anaVsenAdc2 controller)
    def vsen2DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 10, None)
        return(value)
    ## Active high digital enable for VSEN ADC1 (anaVsenAdc1 controller)
    def vsen1DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 9, None)
        return(value)
    ## Active high digital enable for VSEN ADC0 (anaVsenAdc0 controller)
    def vsen0DigEnable(self):
        value = dma_bits(0xE739, self.address, 1, 8, None)
        return(value)
    ## Active high enable for TEL ADC (anaTelAdc module)
    def telAdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 7, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen3AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 6, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen2AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 5, None)
        return(value)
    ## Active high enable for ISEN ADC1 (anaIsenAdc module)
    def isen1AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 4, None)
        return(value)
    ## Active high enable for ISEN ADC0 (anaIsenAdc module)
    def isen0AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 3, None)
        return(value)
    ## Active high enable for VSEN ADC2 (anaVsenAdc2 module)
    def vsen2AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 2, None)
        return(value)
    ## Active high enable for VSEN ADC1 (anaVsenAdc1 module)
    def vsen1AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 1, None)
        return(value)
    ## Active high enable for VSEN ADC0 (anaVsenAdc0 module)
    def vsen0AdcEnable(self):
        value = dma_bits(0xE739, self.address, 1, 0, None)
        return(value)

###################################################################
## PSYS comparator control signals and outputs
###################################################################
class psysStatus_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE73A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class psysStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73A, None)
            self.telPsysComp = (self.reg_value >> 8) & 0x7
            self.telPsysCmpCtrl = (self.reg_value >> 4) & 0xF
            self.vsysMode = (self.reg_value >> 3) & 0x1
            self.vsysModePeak = (self.reg_value >> 2) & 0x1
            self.useVR14Psys = (self.reg_value >> 1) & 0x1
            self.psysCmpValid = self.reg_value & 0x1

    def read_object(self):
        return(self.psysStatus_Object(self.address))

    ## PSYS comparator outputs {critDet,warn2Det,warn1Det}
    def telPsysComp(self):
        value = dma_bits(0xE73A, self.address, 3, 8, None)
        return(value)
    ## PSYS comparator controls {critSel, critEn, warnSel, warnEn}
    def telPsysCmpCtrl(self):
        value = dma_bits(0xE73A, self.address, 4, 4, None)
        return(value)
    ## SVID MultiVR warn1/2 use VSYS
    def vsysMode(self):
        value = dma_bits(0xE73A, self.address, 1, 3, None)
        return(value)
    ## SVID MultiVR crit use VSYS
    def vsysModePeak(self):
        value = dma_bits(0xE73A, self.address, 1, 2, None)
        return(value)
    ## Activate fast PSYS system
    def useVR14Psys(self):
        value = dma_bits(0xE73A, self.address, 1, 1, None)
        return(value)
    ## Validate PSYS comparator output
    def psysCmpValid(self):
        value = dma_bits(0xE73A, self.address, 1, 0, None)
        return(value)

###################################################################
## Vsen fault comparator control signals
###################################################################
class statusVsenFlt_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 21

    def __call__(self, value = None):
        value = dma(self.address, 0xE73B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class statusVsenFlt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73B, None)
            self.vsenFltVal = (self.reg_value >> 18) & 0x7
            self.vsenTrim = (self.reg_value >> 9) & 0x1FF
            self.vsenFltMode = (self.reg_value >> 6) & 0x7
            self.vsenPullupEn = (self.reg_value >> 3) & 0x7
            self.vsenFltEn = self.reg_value & 0x7

    def read_object(self):
        return(self.statusVsenFlt_Object(self.address))

    ## Vsen fault comparator output is valid (chan [2:0])
    def vsenFltVal(self):
        value = dma_bits(0xE73B, self.address, 3, 18, None)
        return(value)
    ## Vsen fault comparator threshold trim code 0-7 = Vsen > 1.25:0.25:3.0 V. (3 bits per chan [2:0][2:0])
    def vsenTrim(self):
        value = dma_bits(0xE73B, self.address, 9, 9, None)
        return(value)
    ## Vsen fault comparator mode 1=fault 0=pin open (chan [2:0])
    def vsenFltMode(self):
        value = dma_bits(0xE73B, self.address, 3, 6, None)
        return(value)
    ## Vsen fault pin pull up enabled (chan [2:0])
    def vsenPullupEn(self):
        value = dma_bits(0xE73B, self.address, 3, 3, None)
        return(value)
    ## Vsen fault comparator is enabled (chan [2:0])
    def vsenFltEn(self):
        value = dma_bits(0xE73B, self.address, 3, 0, None)
        return(value)

###################################################################
## Vsen0 ADC DCM only comparator mode signals
###################################################################
class vSen0CompMode_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE73C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSen0CompMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73C, None)
            self.comp = (self.reg_value >> 27) & 0x1
            self.compValid = (self.reg_value >> 26) & 0x1
            self.trackHold = (self.reg_value >> 25) & 0x1
            self.compMode = (self.reg_value >> 24) & 0x1
            self.compVerrThresholdSel = (self.reg_value >> 16) & 0xFF
            self.adcOffsetFilt = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.vSen0CompMode_Object(self.address))

    ## Vsen comparator output -- voltage is below threshold when 1
    def comp(self):
        value = dma_bits(0xE73C, self.address, 1, 27, None)
        return(value)
    ## Vsen comparator output valid
    def compValid(self):
        value = dma_bits(0xE73C, self.address, 1, 26, None)
        return(value)
    ## Vsen comparator training (mayDcmOnly)
    def trackHold(self):
        value = dma_bits(0xE73C, self.address, 1, 25, None)
        return(value)
    ## Vsen comparator active (dcmOnly)
    def compMode(self):
        value = dma_bits(0xE73C, self.address, 1, 24, None)
        return(value)
    ## Vsen comparator threshold selection
    def compVerrThresholdSel(self):
        value = dma_bits(0xE73C, self.address, 8, 16, None)
        return(value)
    ## Vsen chopping offset
    def adcOffsetFilt(self):
        value = dma_bits(0xE73C, self.address, 16, 0, None)
        return(value)

###################################################################
## Vsen1 ADC DCM only comparator mode signals
###################################################################
class vSen1CompMode_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE73D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSen1CompMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73D, None)
            self.comp = (self.reg_value >> 27) & 0x1
            self.compValid = (self.reg_value >> 26) & 0x1
            self.trackHold = (self.reg_value >> 25) & 0x1
            self.compMode = (self.reg_value >> 24) & 0x1
            self.compVerrThresholdSel = (self.reg_value >> 16) & 0xFF
            self.adcOffsetFilt = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.vSen1CompMode_Object(self.address))

    ## Vsen comparator output -- voltage is below threshold when 1
    def comp(self):
        value = dma_bits(0xE73D, self.address, 1, 27, None)
        return(value)
    ## Vsen comparator output valid
    def compValid(self):
        value = dma_bits(0xE73D, self.address, 1, 26, None)
        return(value)
    ## Vsen comparator training (mayDcmOnly)
    def trackHold(self):
        value = dma_bits(0xE73D, self.address, 1, 25, None)
        return(value)
    ## Vsen comparator active (dcmOnly)
    def compMode(self):
        value = dma_bits(0xE73D, self.address, 1, 24, None)
        return(value)
    ## Vsen comparator threshold selection
    def compVerrThresholdSel(self):
        value = dma_bits(0xE73D, self.address, 8, 16, None)
        return(value)
    ## Vsen chopping offset
    def adcOffsetFilt(self):
        value = dma_bits(0xE73D, self.address, 16, 0, None)
        return(value)

###################################################################
## Vsen2 ADC DCM only comparator mode signals
###################################################################
class vSen2CompMode_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE73E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSen2CompMode_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73E, None)
            self.comp = (self.reg_value >> 27) & 0x1
            self.compValid = (self.reg_value >> 26) & 0x1
            self.trackHold = (self.reg_value >> 25) & 0x1
            self.compMode = (self.reg_value >> 24) & 0x1
            self.compVerrThresholdSel = (self.reg_value >> 16) & 0xFF
            self.adcOffsetFilt = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.vSen2CompMode_Object(self.address))

    ## Vsen comparator output -- voltage is below threshold when 1
    def comp(self):
        value = dma_bits(0xE73E, self.address, 1, 27, None)
        return(value)
    ## Vsen comparator output valid
    def compValid(self):
        value = dma_bits(0xE73E, self.address, 1, 26, None)
        return(value)
    ## Vsen comparator training (mayDcmOnly)
    def trackHold(self):
        value = dma_bits(0xE73E, self.address, 1, 25, None)
        return(value)
    ## Vsen comparator active (dcmOnly)
    def compMode(self):
        value = dma_bits(0xE73E, self.address, 1, 24, None)
        return(value)
    ## Vsen comparator threshold selection
    def compVerrThresholdSel(self):
        value = dma_bits(0xE73E, self.address, 8, 16, None)
        return(value)
    ## Vsen chopping offset
    def adcOffsetFilt(self):
        value = dma_bits(0xE73E, self.address, 16, 0, None)
        return(value)

###################################################################
## Tel ADC raw analog data
###################################################################
class telData_class(object):
    def __init__(self, address):
        self.interface = 'anaBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE73F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telData_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE73F, None)
            self.telCompLevSel = (self.reg_value >> 30) & 0x3
            self.telPsysCrit = (self.reg_value >> 29) & 0x1
            self.telPsysWarn1 = (self.reg_value >> 28) & 0x1
            self.telPsysWarn0 = (self.reg_value >> 27) & 0x1
            self.telMuxSelOut = (self.reg_value >> 21) & 0x3F
            self.telLngCnvtData = (self.reg_value >> 20) & 0x1
            self.telMsbOffset = (self.reg_value >> 16) & 0xF
            self.telRawData = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.telData_Object(self.address))

    ## tel Comp Level Sel
    def telCompLevSel(self):
        value = dma_bits(0xE73F, self.address, 2, 30, None)
        return(value)
    ## tel Psys Crit
    def telPsysCrit(self):
        value = dma_bits(0xE73F, self.address, 1, 29, None)
        return(value)
    ## tel Psys Warn 1
    def telPsysWarn1(self):
        value = dma_bits(0xE73F, self.address, 1, 28, None)
        return(value)
    ## tel Psys Warn 0
    def telPsysWarn0(self):
        value = dma_bits(0xE73F, self.address, 1, 27, None)
        return(value)
    ## Raw tel Mux Sel
    def telMuxSelOut(self):
        value = dma_bits(0xE73F, self.address, 6, 21, None)
        return(value)
    ## tel Long Conv
    def telLngCnvtData(self):
        value = dma_bits(0xE73F, self.address, 1, 20, None)
        return(value)
    ## tel MSB offset
    def telMsbOffset(self):
        value = dma_bits(0xE73F, self.address, 4, 16, None)
        return(value)
    ## Raw tel Conversions
    def telRawData(self):
        value = dma_bits(0xE73F, self.address, 16, 0, None)
        return(value)

###################################################################
## per iSen ADC trim control
###################################################################
class iSenDacTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFacIs'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7A0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenDacTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7A0, None)
            self.compOffCapCode = (self.reg_value >> 22) & 0x3FF
            self.xsbOffset = (self.reg_value >> 19) & 0x7
            self.pre1VcmAdj = (self.reg_value >> 15) & 0xF
            self.pre0VcmAdj = (self.reg_value >> 11) & 0xF
            self.biasAdj1Comp = (self.reg_value >> 8) & 0x7
            self.biasAdj0Comp = (self.reg_value >> 5) & 0x7
            self.refNsel = self.reg_value & 0x1F

    def read_object(self):
        return(self.iSenDacTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.compOffCapCode & 0x3FF) << 22)
        reg = (reg & 0xFFC7FFFF) + ((register_object.xsbOffset & 0x7) << 19)
        reg = (reg & 0xFFF87FFF) + ((register_object.pre1VcmAdj & 0xF) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.pre0VcmAdj & 0xF) << 11)
        reg = (reg & 0xFFFFF8FF) + ((register_object.biasAdj1Comp & 0x7) << 8)
        reg = (reg & 0xFFFFFF1F) + ((register_object.biasAdj0Comp & 0x7) << 5)
        reg = (reg & 0xFFFFFFE0) + (register_object.refNsel & 0x1F)
        dma(self.address, 0xE7A0, reg)
    ## analog comp offset trim
    def compOffCapCode(self, value = None):
        value = dma_bits(0xE7A0, self.address, 10, 22, value)
        return(value)
    ## Reserved config bit for iSen controller per ADC
    def xsbOffset(self, value = None):
        value = dma_bits(0xE7A0, self.address, 3, 19, value)
        return(value)
    def pre1VcmAdj(self, value = None):
        value = dma_bits(0xE7A0, self.address, 4, 15, value)
        return(value)
    def pre0VcmAdj(self, value = None):
        value = dma_bits(0xE7A0, self.address, 4, 11, value)
        return(value)
    ## MBIRD - bit 0 - compGate ... if set, power down comparator in sample state
    def biasAdj1Comp(self, value = None):
        value = dma_bits(0xE7A0, self.address, 3, 8, value)
        return(value)
    def biasAdj0Comp(self, value = None):
        value = dma_bits(0xE7A0, self.address, 3, 5, value)
        return(value)
    def refNsel(self, value = None):
        value = dma_bits(0xE7A0, self.address, 5, 0, value)
        return(value)

###################################################################
## 
###################################################################
class phIsenAdcGain_class(object):
    def __init__(self, address):
        self.interface = 'anaMcuPh'
        self.address = address
        self.bits = 30

    def __call__(self, value = None):
        value = dma(self.address, 0xE7B0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phIsenAdcGain_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7B0, None)
            self.iSenOffset = (self.reg_value >> 18) & 0xFFF
            self.msbWeight = (self.reg_value >> 8) & 0x3FF
            self.xsbWeight = self.reg_value & 0xFF

    def read_object(self):
        return(self.phIsenAdcGain_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.iSenOffset & 0xFFF) << 18)
        reg = (reg & 0x3FFC00FF) + ((register_object.msbWeight & 0x3FF) << 8)
        reg = (reg & 0x3FFFFF00) + (register_object.xsbWeight & 0xFF)
        dma(self.address, 0xE7B0, reg)
    ## N/A to be removed in MBIRD replaced by phIsenAdcDnlTrim.iSenOffset Current sense phase offset trim, managed by firmware
    def iSenOffset(self, value = None):
        value = dma_bits(0xE7B0, self.address, 12, 18, value)
        return(value)
    ## 10bit iSen multiplier for ADC gain, managed by firmware
    def msbWeight(self, value = None):
        value = dma_bits(0xE7B0, self.address, 10, 8, value)
        return(value)
    ## 8bit iSen multiplier for ADC gain, managed by firmware
    def xsbWeight(self, value = None):
        value = dma_bits(0xE7B0, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenDacTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFacCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7D0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenDacTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7D0, None)
            self.spares = (self.reg_value >> 27) & 0x1F
            self.currEstCalcSel = (self.reg_value >> 24) & 0x7
            self.setTailR = (self.reg_value >> 21) & 0x7
            self.pre1VcmAdj = (self.reg_value >> 17) & 0xF
            self.pre0VcmAdj = (self.reg_value >> 13) & 0xF
            self.biasAdj0Comp = (self.reg_value >> 10) & 0x7
            self.compOffCapCode = self.reg_value & 0x3FF

    def read_object(self):
        return(self.vSenDacTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFF) + ((register_object.spares & 0x1F) << 27)
        reg = (reg & 0xF8FFFFFF) + ((register_object.currEstCalcSel & 0x7) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.setTailR & 0x7) << 21)
        reg = (reg & 0xFFE1FFFF) + ((register_object.pre1VcmAdj & 0xF) << 17)
        reg = (reg & 0xFFFE1FFF) + ((register_object.pre0VcmAdj & 0xF) << 13)
        reg = (reg & 0xFFFFE3FF) + ((register_object.biasAdj0Comp & 0x7) << 10)
        reg = (reg & 0xFFFFFC00) + (register_object.compOffCapCode & 0x3FF)
        dma(self.address, 0xE7D0, reg)
    ## Reserved for ana trims ...
    def spares(self, value = None):
        value = dma_bits(0xE7D0, self.address, 5, 27, value)
        return(value)
    ## used to determine which curEstCalc is looped back to vSen in testFb mode
    def currEstCalcSel(self, value = None):
        value = dma_bits(0xE7D0, self.address, 3, 24, value)
        return(value)
    ## Reference current:<br>0-1.5uA<br>1-30uA<br>2-60uA<br>3-90u<br>4-120u<br>5-150u<br>6-180u<br>7-210u
    def setTailR(self, value = None):
        value = dma_bits(0xE7D0, self.address, 3, 21, value)
        return(value)
    ## 0:lowest vcm1 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj1Comp=3 <BR> output vCm ~0.75V
    def pre1VcmAdj(self, value = None):
        value = dma_bits(0xE7D0, self.address, 4, 17, value)
        return(value)
    ## 0:lowest vcm0 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj0Comp=3 <BR> output vCm ~0.75V
    def pre0VcmAdj(self, value = None):
        value = dma_bits(0xE7D0, self.address, 4, 13, value)
        return(value)
    ## 0:21uA<br> 1:42uA<br> 2:62uA<br> 3:82uA<br> 4:102uA<br> 5:122uA<br> 6:142uA<br> 7:162uA
    def biasAdj0Comp(self, value = None):
        value = dma_bits(0xE7D0, self.address, 3, 10, value)
        return(value)
    ## analog comp offset trim -  <BR>NOTE: bit[3:0] used to determine which phases are added together in the 0/1/2 currEstCalc0/1/2 block testFb mode
    def compOffCapCode(self, value = None):
        value = dma_bits(0xE7D0, self.address, 10, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenLpDacTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFacCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7D4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenLpDacTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7D4, None)
            self.spares = (self.reg_value >> 30) & 0x3
            self.digSpares = (self.reg_value >> 27) & 0x7
            self.currEstCalcSel = (self.reg_value >> 24) & 0x7
            self.setTailR = (self.reg_value >> 21) & 0x7
            self.pre1VcmAdj = (self.reg_value >> 17) & 0xF
            self.pre0VcmAdj = (self.reg_value >> 13) & 0xF
            self.biasAdj0Comp = (self.reg_value >> 10) & 0x7
            self.compOffCapCode = self.reg_value & 0x3FF

    def read_object(self):
        return(self.vSenLpDacTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.spares & 0x3) << 30)
        reg = (reg & 0xC7FFFFFF) + ((register_object.digSpares & 0x7) << 27)
        reg = (reg & 0xF8FFFFFF) + ((register_object.currEstCalcSel & 0x7) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.setTailR & 0x7) << 21)
        reg = (reg & 0xFFE1FFFF) + ((register_object.pre1VcmAdj & 0xF) << 17)
        reg = (reg & 0xFFFE1FFF) + ((register_object.pre0VcmAdj & 0xF) << 13)
        reg = (reg & 0xFFFFE3FF) + ((register_object.biasAdj0Comp & 0x7) << 10)
        reg = (reg & 0xFFFFFC00) + (register_object.compOffCapCode & 0x3FF)
        dma(self.address, 0xE7D4, reg)
    ## bit[1:0] compGate[1:0] bit[0] - if set and sampleState and in compMode, gate comparator current <BR>  bit[1] -  if set and sampleState, gate comparator <BR>  bit[2] - analog spare
    def spares(self, value = None):
        value = dma_bits(0xE7D4, self.address, 2, 30, value)
        return(value)
    ## Reserved for ana trims ...
    def digSpares(self, value = None):
        value = dma_bits(0xE7D4, self.address, 3, 27, value)
        return(value)
    ## used to determine which curEstCalc is looped back to vSen in testFb mode
    def currEstCalcSel(self, value = None):
        value = dma_bits(0xE7D4, self.address, 3, 24, value)
        return(value)
    ## Reference current  0-1.5uA 1-30uA 2-60uA 3-90u 4-120u 5-150u 6-180u 7-210u
    def setTailR(self, value = None):
        value = dma_bits(0xE7D4, self.address, 3, 21, value)
        return(value)
    ## 0:lowest vcm1 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj1Comp=3 <BR> output vCm ~0.75V
    def pre1VcmAdj(self, value = None):
        value = dma_bits(0xE7D4, self.address, 4, 17, value)
        return(value)
    ## 0:lowest vcm0 bias voltage 15:highest vcmbias voltage. <BR>In mmSim 9 works across corners with biasAdj0Comp=3 <BR> output vCm ~0.75V
    def pre0VcmAdj(self, value = None):
        value = dma_bits(0xE7D4, self.address, 4, 13, value)
        return(value)
    ## 0:21uA<br> 1:42uA<br> 2:62uA<br> 3:82uA<br> 4:102uA<br> 5:122uA<br> 6:142uA<br> 7:162uA
    def biasAdj0Comp(self, value = None):
        value = dma_bits(0xE7D4, self.address, 3, 10, value)
        return(value)
    ## analog comp offset trim -  <BR>NOTE: bit[3:0] used to determine which phases are added together in the 0/1/2 currEstCalc0/1/2 block testFb mode
    def compOffCapCode(self, value = None):
        value = dma_bits(0xE7D4, self.address, 10, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenSarTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFacCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7D8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenSarTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7D8, None)
            self.msbWeight = (self.reg_value >> 20) & 0xFFF
            self.xsbWeight = (self.reg_value >> 8) & 0xFFF
            self.lsbWeight = self.reg_value & 0xFF

    def read_object(self):
        return(self.vSenSarTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.msbWeight & 0xFFF) << 20)
        reg = (reg & 0xFFF000FF) + ((register_object.xsbWeight & 0xFFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.lsbWeight & 0xFF)
        dma(self.address, 0xE7D8, reg)
    ## MSB gain for vSen ADC  Trimmed to give full scale vSen digital=4.096V
    def msbWeight(self, value = None):
        value = dma_bits(0xE7D8, self.address, 12, 20, value)
        return(value)
    ## XSB gain for vSen ADC was 3642 (EMU vSen digital offset trim)
    def xsbWeight(self, value = None):
        value = dma_bits(0xE7D8, self.address, 12, 8, value)
        return(value)
    ## LSB gain for vSen ADC was 159 (EMU vSen gain trim)
    def lsbWeight(self, value = None):
        value = dma_bits(0xE7D8, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class chIsenCfg_class(object):
    def __init__(self, address):
        self.interface = 'anaCfgCh'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xE7E0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chIsenCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7E0, None)
            self.fltOCUCminCnt = (self.reg_value >> 17) & 0x7
            self.adcModeSel = (self.reg_value >> 16) & 0x1
            self.fltUCLimit = (self.reg_value >> 8) & 0xFF
            self.fltOCLimit = self.reg_value & 0xFF

    def read_object(self):
        return(self.chIsenCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFF) + ((register_object.fltOCUCminCnt & 0x7) << 17)
        reg = (reg & 0xEFFFF) + ((register_object.adcModeSel & 0x1) << 16)
        reg = (reg & 0xF00FF) + ((register_object.fltUCLimit & 0xFF) << 8)
        reg = (reg & 0xFFF00) + (register_object.fltOCLimit & 0xFF)
        dma(self.address, 0xE7E0, reg)
    ## Number of OC/UC samples required in a row to set OC/UC <BR> NOTE: Even though the registers are per channel, the RTL only uses the Cnt from the channel associated with Phase 0 for all phases, therefore:<BR> the same value should always be set in all 3 channels to ensure operation of this feature
    def fltOCUCminCnt(self, value = None):
        value = dma_bits(0xE7E0, self.address, 3, 17, value)
        return(value)
    ## Select ADC mode convert MSB/LSB
    def adcModeSel(self, value = None):
        value = dma_bits(0xE7E0, self.address, 1, 16, value)
        return(value)
    ## DAC input for ISEN UC reference <BR> NOTE: 255 means ONLY clip/fault on ADC comparator descisions all 1/0
    def fltUCLimit(self, value = None):
        value = dma_bits(0xE7E0, self.address, 8, 8, value)
        return(value)
    ## DAC input for ISEN OC reference <BR> NOTE: 255 means ONLY clip/fault on ADC comparator descisions all 1/0
    def fltOCLimit(self, value = None):
        value = dma_bits(0xE7E0, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vSenByteTrim_class(object):
    def __init__(self, address):
        self.interface = 'anaFacCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7E8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vSenByteTrim_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7E8, None)
            self.m8AddWeight = (self.reg_value >> 23) & 0x1FF
            self.m4AddWeight = (self.reg_value >> 15) & 0xFF
            self.m2AddWeight = (self.reg_value >> 7) & 0xFF
            self.x8AddWeight = self.reg_value & 0x7F

    def read_object(self):
        return(self.vSenByteTrim_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.m8AddWeight & 0x1FF) << 23)
        reg = (reg & 0xFF807FFF) + ((register_object.m4AddWeight & 0xFF) << 15)
        reg = (reg & 0xFFFF807F) + ((register_object.m2AddWeight & 0xFF) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.x8AddWeight & 0x7F)
        dma(self.address, 0xE7E8, reg)
    ## signed trim factor for MSB*8
    def m8AddWeight(self, value = None):
        value = dma_bits(0xE7E8, self.address, 9, 23, value)
        return(value)
    ## signed trim factor for MSB*4
    def m4AddWeight(self, value = None):
        value = dma_bits(0xE7E8, self.address, 8, 15, value)
        return(value)
    ## signed trim factor for MSB*2
    def m2AddWeight(self, value = None):
        value = dma_bits(0xE7E8, self.address, 8, 7, value)
        return(value)
    ## signed trim factor for XSB*8
    def x8AddWeight(self, value = None):
        value = dma_bits(0xE7E8, self.address, 7, 0, value)
        return(value)

###################################################################
## Utility manager (see rUSRCONFIG for user config store)
###################################################################
class utcMgr_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE800, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcMgr_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE800, None)
            self.manual = (self.reg_value >> 7) & 0x1
            self.testData = (self.reg_value >> 6) & 0x1
            self.tsCfgSel = (self.reg_value >> 5) & 0x1
            self.tsAddrSel = (self.reg_value >> 4) & 0x1
            self.utcIntEn = (self.reg_value >> 3) & 0x1
            self.int50us = (self.reg_value >> 2) & 0x1
            self.vddmonFilt = (self.reg_value >> 1) & 0x1
            self.priSlotCfgOnly = self.reg_value & 0x1

    def read_object(self):
        return(self.utcMgr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.manual & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.testData & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.tsCfgSel & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.tsAddrSel & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.utcIntEn & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.int50us & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.vddmonFilt & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.priSlotCfgOnly & 0x1)
        dma(self.address, 0xE800, reg)
    ## Temperature sense control 0=auto 1=bit-bang
    def manual(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 7, value)
        return(value)
    ## Enable utility ADC test data write when 1
    def testData(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 6, value)
        return(value)
    ## Manual activate CONFIGSEL pin bias 0=none 1=100ua
    def tsCfgSel(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 5, value)
        return(value)
    ## Manual activate ADDRESS pin bias: 0=none 1=100ua
    def tsAddrSel(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 4, value)
        return(value)
    ## UTC interrupt enable: 0=none 1=active
    def utcIntEn(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 3, value)
        return(value)
    ## Enable 50us interrupt
    def int50us(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 2, value)
        return(value)
    ## VDDMON detector source data: 0 - raw, 1 - average
    def vddmonFilt(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 1, value)
        return(value)
    ## If set, this bit makes the only config to the tel ADC the primary slots config
    def priSlotCfgOnly(self, value = None):
        value = dma_bits(0xE800, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class utcFiltRst_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xE801, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcFiltRst_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE801, None)
            self.filtRstPsys = (self.reg_value >> 10) & 0x1
            self.filtRstAz = (self.reg_value >> 9) & 0x1
            self.filtRstRes = (self.reg_value >> 8) & 0x1
            self.filtRstInternal = (self.reg_value >> 7) & 0x1
            self.filtRstTemp2 = (self.reg_value >> 6) & 0x1
            self.filtRstTemp1 = (self.reg_value >> 5) & 0x1
            self.filtRstTemp0 = (self.reg_value >> 4) & 0x1
            self.filtRstIntTemp = (self.reg_value >> 3) & 0x1
            self.filtRstVout = (self.reg_value >> 2) & 0x1
            self.filtRstIin0 = (self.reg_value >> 1) & 0x1
            self.filtRstVin0 = self.reg_value & 0x1

    def read_object(self):
        return(self.utcFiltRst_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.filtRstPsys & 0x1) << 10)
        reg = (reg & 0x5FF) + ((register_object.filtRstAz & 0x1) << 9)
        reg = (reg & 0x6FF) + ((register_object.filtRstRes & 0x1) << 8)
        reg = (reg & 0x77F) + ((register_object.filtRstInternal & 0x1) << 7)
        reg = (reg & 0x7BF) + ((register_object.filtRstTemp2 & 0x1) << 6)
        reg = (reg & 0x7DF) + ((register_object.filtRstTemp1 & 0x1) << 5)
        reg = (reg & 0x7EF) + ((register_object.filtRstTemp0 & 0x1) << 4)
        reg = (reg & 0x7F7) + ((register_object.filtRstIntTemp & 0x1) << 3)
        reg = (reg & 0x7FB) + ((register_object.filtRstVout & 0x1) << 2)
        reg = (reg & 0x7FD) + ((register_object.filtRstIin0 & 0x1) << 1)
        reg = (reg & 0x7FE) + (register_object.filtRstVin0 & 0x1)
        dma(self.address, 0xE801, reg)
    ## Reset Psys filter bit 10
    def filtRstPsys(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 10, value)
        return(value)
    ## Reset Auto Zero filter bit 9
    def filtRstAz(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 9, value)
        return(value)
    ## Reset Resistor reader filters bit 8
    def filtRstRes(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 8, value)
        return(value)
    ## Reset Internal filter bit 7 (ATB, VCC, VCCS, VDD1P8, VDDIO)
    def filtRstInternal(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 7, value)
        return(value)
    ## Reset Temperature 2 filter bit 6
    def filtRstTemp2(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 6, value)
        return(value)
    ## Reset Temperature 1 filter bit 5
    def filtRstTemp1(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 5, value)
        return(value)
    ## Reset Temperature 0 filter bit 4
    def filtRstTemp0(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 4, value)
        return(value)
    ## Reset Internal Temperature filter bit 3
    def filtRstIntTemp(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 3, value)
        return(value)
    ## Reset Vout filters bit 2
    def filtRstVout(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 2, value)
        return(value)
    ## Reset IIN0 filter bit 1
    def filtRstIin0(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 1, value)
        return(value)
    ## Reset VIN0 filter bit 0
    def filtRstVin0(self, value = None):
        value = dma_bits(0xE801, self.address, 1, 0, value)
        return(value)

###################################################################
## UTC telemetry test data control
###################################################################
class utcTelTest_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xE802, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcTelTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE802, None)
            self.zeroData = (self.reg_value >> 21) & 0x1
            self.sourceSel = (self.reg_value >> 16) & 0x1F
            self.testData = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.utcTelTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.zeroData & 0x1) << 21)
        reg = (reg & 0x20FFFF) + ((register_object.sourceSel & 0x1F) << 16)
        reg = (reg & 0x3F0000) + (register_object.testData & 0xFFFF)
        dma(self.address, 0xE802, reg)
    ## Apply to zero data
    def zeroData(self, value = None):
        value = dma_bits(0xE802, self.address, 1, 21, value)
        return(value)
    ## UTC input source selector
    def sourceSel(self, value = None):
        value = dma_bits(0xE802, self.address, 5, 16, value)
        return(value)
    ## UTC telemetry test data replacement
    def testData(self, value = None):
        value = dma_bits(0xE802, self.address, 16, 0, value)
        return(value)

###################################################################
## Default temp values to report when driver in sleep mode
###################################################################
class sleepTemp_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE803, value)
        return(value)


###################################################################
## Telemetry ADC configuration for VINSEN0 sample acquisition
###################################################################
class vinSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE804, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vinSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE804, None)
            self.vinAdcOff = (self.reg_value >> 11) & 0xF
            self.vinAZdis = (self.reg_value >> 10) & 0x1
            self.vinLCnvt = (self.reg_value >> 9) & 0x1
            self.vinSampPdnShft = (self.reg_value >> 7) & 0x3
            self.vinSampShft = (self.reg_value >> 4) & 0x7
            self.vinSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.vinSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.vinAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.vinAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.vinLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.vinSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.vinSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.vinSampVal & 0xF)
        dma(self.address, 0xE804, reg)
    ## VINSEN0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def vinAdcOff(self, value = None):
        value = dma_bits(0xE804, self.address, 4, 11, value)
        return(value)
    ## VINSEN0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def vinAZdis(self, value = None):
        value = dma_bits(0xE804, self.address, 1, 10, value)
        return(value)
    ## VINSEN0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def vinLCnvt(self, value = None):
        value = dma_bits(0xE804, self.address, 1, 9, value)
        return(value)
    ## VINSEN0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def vinSampPdnShft(self, value = None):
        value = dma_bits(0xE804, self.address, 2, 7, value)
        return(value)
    ## VINSEN0 ADC sample shift
    def vinSampShft(self, value = None):
        value = dma_bits(0xE804, self.address, 3, 4, value)
        return(value)
    ## VINSEN0 ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def vinSampVal(self, value = None):
        value = dma_bits(0xE804, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for IINSEN0 sample acquisition
###################################################################
class iinSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE805, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iinSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE805, None)
            self.iinAdcOff = (self.reg_value >> 11) & 0xF
            self.iinAZdis = (self.reg_value >> 10) & 0x1
            self.iinLCnvt = (self.reg_value >> 9) & 0x1
            self.iinSampPdnShft = (self.reg_value >> 7) & 0x3
            self.iinSampShft = (self.reg_value >> 4) & 0x7
            self.iinSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.iinSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.iinAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.iinAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.iinLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.iinSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.iinSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.iinSampVal & 0xF)
        dma(self.address, 0xE805, reg)
    ## IINSEN0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def iinAdcOff(self, value = None):
        value = dma_bits(0xE805, self.address, 4, 11, value)
        return(value)
    ## IINSEN0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def iinAZdis(self, value = None):
        value = dma_bits(0xE805, self.address, 1, 10, value)
        return(value)
    ## IINSEN0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def iinLCnvt(self, value = None):
        value = dma_bits(0xE805, self.address, 1, 9, value)
        return(value)
    ## IINSEN0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def iinSampPdnShft(self, value = None):
        value = dma_bits(0xE805, self.address, 2, 7, value)
        return(value)
    ## IINSEN0 ADC sample shift
    def iinSampShft(self, value = None):
        value = dma_bits(0xE805, self.address, 3, 4, value)
        return(value)
    ## IINSEN0 ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def iinSampVal(self, value = None):
        value = dma_bits(0xE805, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for TEMP0 sample acquisition
###################################################################
class temp0SlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE806, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class temp0SlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE806, None)
            self.temp0AdcOff = (self.reg_value >> 11) & 0xF
            self.temp0AZdis = (self.reg_value >> 10) & 0x1
            self.temp0LCnvt = (self.reg_value >> 9) & 0x1
            self.temp0SampPdnShft = (self.reg_value >> 7) & 0x3
            self.temp0SampShft = (self.reg_value >> 4) & 0x7
            self.temp0SampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.temp0SlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.temp0AdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.temp0AZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.temp0LCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.temp0SampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.temp0SampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.temp0SampVal & 0xF)
        dma(self.address, 0xE806, reg)
    ## TEMP0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp0AdcOff(self, value = None):
        value = dma_bits(0xE806, self.address, 4, 11, value)
        return(value)
    ## TEMP0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp0AZdis(self, value = None):
        value = dma_bits(0xE806, self.address, 1, 10, value)
        return(value)
    ## TEMP0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp0LCnvt(self, value = None):
        value = dma_bits(0xE806, self.address, 1, 9, value)
        return(value)
    ## TEMP0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp0SampPdnShft(self, value = None):
        value = dma_bits(0xE806, self.address, 2, 7, value)
        return(value)
    ## TEMP0 ADC sample shift
    def temp0SampShft(self, value = None):
        value = dma_bits(0xE806, self.address, 3, 4, value)
        return(value)
    ## TEMP0 ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def temp0SampVal(self, value = None):
        value = dma_bits(0xE806, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for TEMP1 sample acquisition
###################################################################
class temp1SlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE807, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class temp1SlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE807, None)
            self.temp1AdcOff = (self.reg_value >> 11) & 0xF
            self.temp1AZdis = (self.reg_value >> 10) & 0x1
            self.temp1LCnvt = (self.reg_value >> 9) & 0x1
            self.temp1SampPdnShft = (self.reg_value >> 7) & 0x3
            self.temp1SampShft = (self.reg_value >> 4) & 0x7
            self.temp1SampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.temp1SlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.temp1AdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.temp1AZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.temp1LCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.temp1SampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.temp1SampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.temp1SampVal & 0xF)
        dma(self.address, 0xE807, reg)
    ## TEMP1 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp1AdcOff(self, value = None):
        value = dma_bits(0xE807, self.address, 4, 11, value)
        return(value)
    ## TEMP1 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp1AZdis(self, value = None):
        value = dma_bits(0xE807, self.address, 1, 10, value)
        return(value)
    ## TEMP1 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp1LCnvt(self, value = None):
        value = dma_bits(0xE807, self.address, 1, 9, value)
        return(value)
    ## TEMP1 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp1SampPdnShft(self, value = None):
        value = dma_bits(0xE807, self.address, 2, 7, value)
        return(value)
    ## TEMP1 ADC sample shift
    def temp1SampShft(self, value = None):
        value = dma_bits(0xE807, self.address, 3, 4, value)
        return(value)
    ## TEMP1 ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def temp1SampVal(self, value = None):
        value = dma_bits(0xE807, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for TEMP2 sample acquisition
###################################################################
class temp2SlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE808, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class temp2SlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE808, None)
            self.temp2AdcOff = (self.reg_value >> 11) & 0xF
            self.temp2AZdis = (self.reg_value >> 10) & 0x1
            self.temp2LCnvt = (self.reg_value >> 9) & 0x1
            self.temp2SampPdnShft = (self.reg_value >> 7) & 0x3
            self.temp2SampShft = (self.reg_value >> 4) & 0x7
            self.temp2SampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.temp2SlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.temp2AdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.temp2AZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.temp2LCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.temp2SampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.temp2SampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.temp2SampVal & 0xF)
        dma(self.address, 0xE808, reg)
    ## TEMP2 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp2AdcOff(self, value = None):
        value = dma_bits(0xE808, self.address, 4, 11, value)
        return(value)
    ## TEMP2 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp2AZdis(self, value = None):
        value = dma_bits(0xE808, self.address, 1, 10, value)
        return(value)
    ## TEMP2 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp2LCnvt(self, value = None):
        value = dma_bits(0xE808, self.address, 1, 9, value)
        return(value)
    ## TEMP2 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp2SampPdnShft(self, value = None):
        value = dma_bits(0xE808, self.address, 2, 7, value)
        return(value)
    ## TEMP2 ADC sample shift
    def temp2SampShft(self, value = None):
        value = dma_bits(0xE808, self.address, 3, 4, value)
        return(value)
    ## TEMP2 ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def temp2SampVal(self, value = None):
        value = dma_bits(0xE808, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for Vinternal sample acquisition
###################################################################
class vIntSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE809, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vIntSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE809, None)
            self.vIntAdcOff = (self.reg_value >> 11) & 0xF
            self.vIntAZdis = (self.reg_value >> 10) & 0x1
            self.vIntLCnvt = (self.reg_value >> 9) & 0x1
            self.vIntSampPdnShft = (self.reg_value >> 7) & 0x3
            self.vIntSampShft = (self.reg_value >> 4) & 0x7
            self.vIntSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.vIntSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.vIntAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.vIntAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.vIntLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.vIntSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.vIntSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.vIntSampVal & 0xF)
        dma(self.address, 0xE809, reg)
    ## Vinternal ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def vIntAdcOff(self, value = None):
        value = dma_bits(0xE809, self.address, 4, 11, value)
        return(value)
    ## Vinternal ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def vIntAZdis(self, value = None):
        value = dma_bits(0xE809, self.address, 1, 10, value)
        return(value)
    ## Vinternal ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def vIntLCnvt(self, value = None):
        value = dma_bits(0xE809, self.address, 1, 9, value)
        return(value)
    ## Vinternal ADC sample acquisition count additional shift if in pdn in clkSys*2
    def vIntSampPdnShft(self, value = None):
        value = dma_bits(0xE809, self.address, 2, 7, value)
        return(value)
    ## Vinternal ADC sample shift
    def vIntSampShft(self, value = None):
        value = dma_bits(0xE809, self.address, 3, 4, value)
        return(value)
    ## Vinternal ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def vIntSampVal(self, value = None):
        value = dma_bits(0xE809, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for internal teperature and ATB sample acquisition
###################################################################
class intTempSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE80A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class intTempSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80A, None)
            self.intTempAdcOff = (self.reg_value >> 11) & 0xF
            self.intTempAZdis = (self.reg_value >> 10) & 0x1
            self.intTempLCnvt = (self.reg_value >> 9) & 0x1
            self.intTempSampPdnShft = (self.reg_value >> 7) & 0x3
            self.intTempSampShft = (self.reg_value >> 4) & 0x7
            self.intTempSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.intTempSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.intTempAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.intTempAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.intTempLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.intTempSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.intTempSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.intTempSampVal & 0xF)
        dma(self.address, 0xE80A, reg)
    ## Vinternal ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def intTempAdcOff(self, value = None):
        value = dma_bits(0xE80A, self.address, 4, 11, value)
        return(value)
    ## Vinternal ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def intTempAZdis(self, value = None):
        value = dma_bits(0xE80A, self.address, 1, 10, value)
        return(value)
    ## Vinternal ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def intTempLCnvt(self, value = None):
        value = dma_bits(0xE80A, self.address, 1, 9, value)
        return(value)
    ## Vinternal ADC sample acquisition count additional shift if in pdn in clkSys*2
    def intTempSampPdnShft(self, value = None):
        value = dma_bits(0xE80A, self.address, 2, 7, value)
        return(value)
    ## Vinternal ADC sample shift
    def intTempSampShft(self, value = None):
        value = dma_bits(0xE80A, self.address, 3, 4, value)
        return(value)
    ## Vinternal ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def intTempSampVal(self, value = None):
        value = dma_bits(0xE80A, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for Address and Config sample acquisition
###################################################################
class extSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE80B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class extSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80B, None)
            self.extAdcOff = (self.reg_value >> 11) & 0xF
            self.extAZdis = (self.reg_value >> 10) & 0x1
            self.extLCnvt = (self.reg_value >> 9) & 0x1
            self.extSampPdnShft = (self.reg_value >> 7) & 0x3
            self.extSampShft = (self.reg_value >> 4) & 0x7
            self.extSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.extSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.extAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.extAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.extLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.extSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.extSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.extSampVal & 0xF)
        dma(self.address, 0xE80B, reg)
    ## External Slots ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def extAdcOff(self, value = None):
        value = dma_bits(0xE80B, self.address, 4, 11, value)
        return(value)
    ## External Slots ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def extAZdis(self, value = None):
        value = dma_bits(0xE80B, self.address, 1, 10, value)
        return(value)
    ## External Slots ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def extLCnvt(self, value = None):
        value = dma_bits(0xE80B, self.address, 1, 9, value)
        return(value)
    ## External Slots ADC sample acquisition count additional shift if in pdn in clkSys*2
    def extSampPdnShft(self, value = None):
        value = dma_bits(0xE80B, self.address, 2, 7, value)
        return(value)
    ## External Slots ADC sample shift
    def extSampShft(self, value = None):
        value = dma_bits(0xE80B, self.address, 3, 4, value)
        return(value)
    ## External Slots ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def extSampVal(self, value = None):
        value = dma_bits(0xE80B, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for Auto Zero sample acquisition
###################################################################
class azSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE80C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class azSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80C, None)
            self.azAdcOff = (self.reg_value >> 11) & 0xF
            self.azAZdis = (self.reg_value >> 10) & 0x1
            self.azLCnvt = (self.reg_value >> 9) & 0x1
            self.azSampPdnShft = (self.reg_value >> 7) & 0x3
            self.azSampShft = (self.reg_value >> 4) & 0x7
            self.azSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.azSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.azAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.azAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.azLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.azSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.azSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.azSampVal & 0xF)
        dma(self.address, 0xE80C, reg)
    ## Auto-Zero Slots ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def azAdcOff(self, value = None):
        value = dma_bits(0xE80C, self.address, 4, 11, value)
        return(value)
    ## Auto-Zero Slots ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def azAZdis(self, value = None):
        value = dma_bits(0xE80C, self.address, 1, 10, value)
        return(value)
    ## Auto-Zero Slots ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def azLCnvt(self, value = None):
        value = dma_bits(0xE80C, self.address, 1, 9, value)
        return(value)
    ## Auto-Zero Slots ADC sample acquisition count additional shift if in pdn in clkSys*2
    def azSampPdnShft(self, value = None):
        value = dma_bits(0xE80C, self.address, 2, 7, value)
        return(value)
    ## Auto-Zero Slots ADC sample shift
    def azSampShft(self, value = None):
        value = dma_bits(0xE80C, self.address, 3, 4, value)
        return(value)
    ## Auto-Zero Slots ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def azSampVal(self, value = None):
        value = dma_bits(0xE80C, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry ADC configuration for Slow Auto Zero sample acquisition
###################################################################
class azSlowCfg_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 15

    def __call__(self, value = None):
        value = dma(self.address, 0xE80D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class azSlowCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80D, None)
            self.azSlowAdcOff = (self.reg_value >> 11) & 0xF
            self.azSlowAZdis = (self.reg_value >> 10) & 0x1
            self.azSlowLCnvt = (self.reg_value >> 9) & 0x1
            self.azSlowSampPdnShft = (self.reg_value >> 7) & 0x3
            self.azSlowSampShft = (self.reg_value >> 4) & 0x7
            self.azSlowSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.azSlowCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.azSlowAdcOff & 0xF) << 11)
        reg = (reg & 0x7BFF) + ((register_object.azSlowAZdis & 0x1) << 10)
        reg = (reg & 0x7DFF) + ((register_object.azSlowLCnvt & 0x1) << 9)
        reg = (reg & 0x7E7F) + ((register_object.azSlowSampPdnShft & 0x3) << 7)
        reg = (reg & 0x7F8F) + ((register_object.azSlowSampShft & 0x7) << 4)
        reg = (reg & 0x7FF0) + (register_object.azSlowSampVal & 0xF)
        dma(self.address, 0xE80D, reg)
    ## Slow Auto-Zero Slots ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def azSlowAdcOff(self, value = None):
        value = dma_bits(0xE80D, self.address, 4, 11, value)
        return(value)
    ## Slow Auto-Zero Slots ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def azSlowAZdis(self, value = None):
        value = dma_bits(0xE80D, self.address, 1, 10, value)
        return(value)
    ## Slow Auto-Zero Slots ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def azSlowLCnvt(self, value = None):
        value = dma_bits(0xE80D, self.address, 1, 9, value)
        return(value)
    ## Slow Auto-Zero Slots ADC sample acquisition count additional shift if in pdn in clkSys*2
    def azSlowSampPdnShft(self, value = None):
        value = dma_bits(0xE80D, self.address, 2, 7, value)
        return(value)
    ## Slow Auto-Zero Slots ADC sample shift
    def azSlowSampShft(self, value = None):
        value = dma_bits(0xE80D, self.address, 3, 4, value)
        return(value)
    ## Slow Auto-Zero Slots ADC sample acquisition time = ((val*2^Shift)+2)*adcClk (adcClk = telUseOscClk ? clkSys : clkTs)
    def azSlowSampVal(self, value = None):
        value = dma_bits(0xE80D, self.address, 4, 0, value)
        return(value)

###################################################################
## Utility Primary Slot Select A
###################################################################
class utcPSSA_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE80E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcPSSA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80E, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcPSSA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE80E, reg)
    ## UTC Primary Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE80E, self.address, 8, 24, value)
        return(value)
    ## UTC Primary Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE80E, self.address, 8, 16, value)
        return(value)
    ## UTC Primary Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE80E, self.address, 8, 8, value)
        return(value)
    ## UTC Primary Slot 0 <BR> Primary & Alternate <BR>  0/0 =VIN0   1/1 =n/a   2/2 =IIN0  3/3 =n/a   4/4 =n/a    5/5 =n/a   <BR>  6/6 =VOUT0  7/7 =VOUT1 <BR>  8/8 =VOUT2  <BR> 9/9 =IntT  <BR> A/10=TMP0  B/11=TMP1  C/12=TMP2   <BR> D/13=ATB   <BR>   E/14=VCC    F/15=VCCS  <BR> 10/16=VDDIO 11/17=ADDR 12/18=CNFG 13/19=VDD1V8       <BR>                                          30/48=SlowNull   <BR>                                                                                                  3A/58=SlowAZ 3B/59=AZ  <BR>  3C/60=n/a  <BR>  3D/61=Alt1   3E/62=Alt2  <BR> 3F/63=Ext   <BR> External slot codes (ESS) <BR>  0/0 =ADDR Zero  1/1 =CONFIG Zero  2/2 =n/a        3/3 =n/a     <BR>    4/4 =n/a        5/5 =n/a          6/6 =n/a        7/7 =n/a      <BR>   8/8 =ADDR       9/9 =CONFIG       A/10=n/a        B/11=n/a      <BR>   C/12=n/a        D/12=n/a          E/15=n/a        F/15=n/a      <BR>
    def slot0(self, value = None):
        value = dma_bits(0xE80E, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Primary Slot Select B
###################################################################
class utcPSSB_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE80F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcPSSB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE80F, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcPSSB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE80F, reg)
    ## UTC Primary Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE80F, self.address, 8, 24, value)
        return(value)
    ## UTC Primary Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE80F, self.address, 8, 16, value)
        return(value)
    ## UTC Primary Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE80F, self.address, 8, 8, value)
        return(value)
    ## UTC Primary Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE80F, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 1 Slot Select A
###################################################################
class utcASS1A_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE810, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS1A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE810, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS1A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE810, reg)
    ## UTC Alternate 1 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE810, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 1 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE810, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 1 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE810, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 1 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE810, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 1 Slot Select B
###################################################################
class utcASS1B_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE811, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS1B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE811, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS1B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE811, reg)
    ## UTC Alternate 1 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE811, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 1 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE811, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 1 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE811, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 1 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE811, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 2 Slot Select A
###################################################################
class utcASS2A_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE812, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS2A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE812, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS2A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE812, reg)
    ## UTC Alternate 2 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE812, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 2 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE812, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 2 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE812, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 2 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE812, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 2 Slot Select B
###################################################################
class utcASS2B_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE813, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS2B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE813, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS2B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE813, reg)
    ## UTC Alternate 2 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE813, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 2 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE813, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 2 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE813, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 2 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE813, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility External Slot Select
###################################################################
class utcESS_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE814, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcESS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE814, None)
            self.slot7 = (self.reg_value >> 28) & 0xF
            self.slot6 = (self.reg_value >> 24) & 0xF
            self.slot5 = (self.reg_value >> 20) & 0xF
            self.slot4 = (self.reg_value >> 16) & 0xF
            self.slot3 = (self.reg_value >> 12) & 0xF
            self.slot2 = (self.reg_value >> 8) & 0xF
            self.slot1 = (self.reg_value >> 4) & 0xF
            self.slot0 = self.reg_value & 0xF

    def read_object(self):
        return(self.utcESS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.slot7 & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.slot6 & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.slot5 & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.slot4 & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.slot3 & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.slot2 & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.slot1 & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.slot0 & 0xF)
        dma(self.address, 0xE814, reg)
    ## UTC External Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 28, value)
        return(value)
    ## UTC External Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 24, value)
        return(value)
    ## UTC External Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 20, value)
        return(value)
    ## UTC External Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 16, value)
        return(value)
    ## UTC External Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 12, value)
        return(value)
    ## UTC External Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 8, value)
        return(value)
    ## UTC External Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 4, value)
        return(value)
    ## UTC External Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE814, self.address, 4, 0, value)
        return(value)

###################################################################
## Utility Primary Slot Select A -- Slow/Low Power
###################################################################
class utcPSSASLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE815, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcPSSASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE815, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcPSSASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE815, reg)
    ## UTC Primary Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE815, self.address, 8, 24, value)
        return(value)
    ## UTC Primary Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE815, self.address, 8, 16, value)
        return(value)
    ## UTC Primary Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE815, self.address, 8, 8, value)
        return(value)
    ## UTC Primary Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE815, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Primary Slot Select B -- Slow/Low Power
###################################################################
class utcPSSBSLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE816, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcPSSBSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE816, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcPSSBSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE816, reg)
    ## UTC Primary Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE816, self.address, 8, 24, value)
        return(value)
    ## UTC Primary Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE816, self.address, 8, 16, value)
        return(value)
    ## UTC Primary Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE816, self.address, 8, 8, value)
        return(value)
    ## UTC Primary Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE816, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 1 Slot Select A -- Slow/Low Power
###################################################################
class utcASS1ASLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE817, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS1ASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE817, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS1ASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE817, reg)
    ## UTC Alternate 1 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE817, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 1 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE817, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 1 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE817, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 1 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE817, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 1 Slot Select B -- Slow/Low Power
###################################################################
class utcASS1BSLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE818, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS1BSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE818, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS1BSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE818, reg)
    ## UTC Alternate 1 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE818, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 1 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE818, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 1 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE818, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 1 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE818, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 2 Slot Select A -- Slow/Low Power
###################################################################
class utcASS2ASLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE819, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS2ASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE819, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS2ASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xE819, reg)
    ## UTC Alternate 2 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE819, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 2 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE819, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 2 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE819, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 2 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE819, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility Alternate 2 Slot Select B -- Slow/Low Power
###################################################################
class utcASS2BSLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE81A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcASS2BSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81A, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.utcASS2BSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xE81A, reg)
    ## UTC Alternate 2 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE81A, self.address, 8, 24, value)
        return(value)
    ## UTC Alternate 2 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE81A, self.address, 8, 16, value)
        return(value)
    ## UTC Alternate 2 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE81A, self.address, 8, 8, value)
        return(value)
    ## UTC Alternate 2 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE81A, self.address, 8, 0, value)
        return(value)

###################################################################
## Utility External Slot Select -- Slow/Low Power
###################################################################
class utcESSSLOW_class(object):
    def __init__(self, address):
        self.interface = 'utcSlot'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE81B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class utcESSSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81B, None)
            self.slot7 = (self.reg_value >> 28) & 0xF
            self.slot6 = (self.reg_value >> 24) & 0xF
            self.slot5 = (self.reg_value >> 20) & 0xF
            self.slot4 = (self.reg_value >> 16) & 0xF
            self.slot3 = (self.reg_value >> 12) & 0xF
            self.slot2 = (self.reg_value >> 8) & 0xF
            self.slot1 = (self.reg_value >> 4) & 0xF
            self.slot0 = self.reg_value & 0xF

    def read_object(self):
        return(self.utcESSSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.slot7 & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.slot6 & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.slot5 & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.slot4 & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.slot3 & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.slot2 & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.slot1 & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.slot0 & 0xF)
        dma(self.address, 0xE81B, reg)
    ## UTC External Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 28, value)
        return(value)
    ## UTC External Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 24, value)
        return(value)
    ## UTC External Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 20, value)
        return(value)
    ## UTC External Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 16, value)
        return(value)
    ## UTC External Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 12, value)
        return(value)
    ## UTC External Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 8, value)
        return(value)
    ## UTC External Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 4, value)
        return(value)
    ## UTC External Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xE81B, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem input voltage VINSEN0 filter
###################################################################
class filtVinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE81C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtVinTel0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81C, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtVinTel0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE81C, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE81C, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE81C, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem input current IINSEN0 filter
###################################################################
class filtIinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE81D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtIinTel0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81D, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtIinTel0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE81D, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE81D, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE81D, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem output voltage filter
###################################################################
class filtVoutTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE81E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtVoutTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81E, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtVoutTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE81E, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE81E, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE81E, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem internal temperature filter
###################################################################
class filtIntTempTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE81F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtIntTempTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE81F, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtIntTempTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE81F, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE81F, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE81F, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem temperature filter for TEMP0
###################################################################
class filtTempTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE820, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtTempTel0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE820, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtTempTel0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE820, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE820, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE820, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem temperature filter for TEMP1
###################################################################
class filtTempTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE821, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtTempTel1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE821, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtTempTel1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE821, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE821, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE821, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem temperature filter for TEMP2
###################################################################
class filtTempTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE822, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtTempTel2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE822, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtTempTel2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE822, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE822, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE822, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem internal source filter
###################################################################
class filtInternalTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE823, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtInternalTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE823, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtInternalTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE823, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE823, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE823, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem resistor reader filter
###################################################################
class filtResTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE824, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtResTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE824, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtResTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE824, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE824, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE824, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem Pin V*I filter
###################################################################
class filtPinViTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE825, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtPinViTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE825, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtPinViTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE825, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE825, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE825, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem Auto Zero filter
###################################################################
class filtAzTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE826, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtAzTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE826, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtAzTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE826, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE826, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE826, self.address, 4, 0, value)
        return(value)

###################################################################
## UTC Telem input voltage scaling
###################################################################
class gainVinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE827, value)
        return(value)


###################################################################
## UTC Telem input voltage scaling
###################################################################
class gainIinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE828, value)
        return(value)


###################################################################
## UTC Telem output voltage scaling
###################################################################
class gainVoutTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE829, value)
        return(value)


###################################################################
## UTC Telem output voltage scaling
###################################################################
class gainVoutTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE82A, value)
        return(value)


###################################################################
## UTC Telem output voltage scaling
###################################################################
class gainVoutTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE82B, value)
        return(value)


###################################################################
## UTC Calculated power (V*I) scaling
###################################################################
class gainPinViTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE82C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPinViTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE82C, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPinViTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE82C, reg)
    ## Up shift applied to voltage when computing power, 1-4
    def vShift(self, value = None):
        value = dma_bits(0xE82C, self.address, 2, 16, value)
        return(value)
    ## Scale from volts times amps to watts
    def val(self, value = None):
        value = dma_bits(0xE82C, self.address, 16, 0, value)
        return(value)

###################################################################
## UTC Vsys data scaling
###################################################################
class gainVsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE82D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainVsysTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE82D, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainVsysTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE82D, reg)
    ## Up shift applied to multiplier output when computing normalized voltage, 2^(4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE82D, self.address, 2, 16, value)
        return(value)
    ## Scale from volts to VINMAX
    def val(self, value = None):
        value = dma_bits(0xE82D, self.address, 16, 0, value)
        return(value)

###################################################################
## UTC Psys/Isys data scaling
###################################################################
class gainIsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE82E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainIsysTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE82E, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainIsysTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE82E, reg)
    ## Up shift applied to multiplier output when computing normalized current, 2^(4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE82E, self.address, 2, 16, value)
        return(value)
    ## Scale from amps to IINMAX
    def val(self, value = None):
        value = dma_bits(0xE82E, self.address, 16, 0, value)
        return(value)

###################################################################
## UTC Psys/Isys data scaling
###################################################################
class gainPsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE82F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPsysTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE82F, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPsysTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE82F, reg)
    ## Up shift applied to multiplier output when computing normalized power, 2^(4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE82F, self.address, 2, 16, value)
        return(value)
    ## Scale from watts to PINMAX
    def val(self, value = None):
        value = dma_bits(0xE82F, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel input voltage telemetry scaling
###################################################################
class gainHsVin_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE830, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsVin_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE830, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsVin_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE830, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE830, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE830, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel input voltage telemetry offset
###################################################################
class offHsVin_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE831, value)
        return(value)


###################################################################
## High-speed interface auxiliary Imon current telemetry scaling
###################################################################
class gainHsIauxTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE832, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsIauxTel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE832, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsIauxTel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE832, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE832, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus Aux Imon (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE832, self.address, 16, 0, value)
        return(value)

###################################################################
## UTC Telem external temperature 0 reading scaling
###################################################################
class gainExtTempTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE833, value)
        return(value)


###################################################################
## UTC Telem external temperature 1 reading scaling
###################################################################
class gainExtTempTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE834, value)
        return(value)


###################################################################
## UTC Telem external temperature 2 reading scaling
###################################################################
class gainExtTempTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE835, value)
        return(value)


###################################################################
## UTC Telem ADDRESS/CONFIG pin scaling
###################################################################
class gainRes_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE836, value)
        return(value)


###################################################################
## UTC buffer gain for VIN0 Div measure
###################################################################
class vin0DivBuffGainTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE837, value)
        return(value)


###################################################################
## UTC buffer gain for VIN0 measure
###################################################################
class vin0BuffGainTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE838, value)
        return(value)


###################################################################
## UTC buffer gain for IIN0 measure
###################################################################
class iin0BuffGainTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE839, value)
        return(value)


###################################################################
## UTC buffer gain for VDDIO measure
###################################################################
class vddioBuffGainTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83A, value)
        return(value)


###################################################################
## UTC VIN0 buffer offset when using internal divider
###################################################################
class vin0DivBuffOffsetTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83B, value)
        return(value)


###################################################################
## UTC VIN0 buffer offset
###################################################################
class vin0BuffOffsetTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83C, value)
        return(value)


###################################################################
## UTC IIN0 buffer offset
###################################################################
class iin0BuffOffsetTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83D, value)
        return(value)


###################################################################
## UTC VDDIO buffer offset
###################################################################
class vddioBuffOffsetTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83E, value)
        return(value)


###################################################################
## UTC Telem VINSEN0 input voltage offset
###################################################################
class offVinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE83F, value)
        return(value)


###################################################################
## UTC Telem IINSEN0 input current offset
###################################################################
class offIinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE840, value)
        return(value)


###################################################################
## UTC Telem TEMP0 temperature offset
###################################################################
class offTempTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE841, value)
        return(value)


###################################################################
## UTC Telem TEMP1 temperature offset
###################################################################
class offTempTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE842, value)
        return(value)


###################################################################
## UTC Telem TEMP2 temperature offset
###################################################################
class offTempTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE843, value)
        return(value)


###################################################################
## UTC Telem ADDRESS offset
###################################################################
class offAddressTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE844, value)
        return(value)


###################################################################
## UTC Telem CONFIG offset
###################################################################
class offConfigTel_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE845, value)
        return(value)


###################################################################
## Bypass hardware telemetry scaling and use firmware
###################################################################
class hwBypass_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE870, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class hwBypass_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE870, None)
            self.hsAuxImon = (self.reg_value >> 17) & 0x1
            self.hsPsys = (self.reg_value >> 16) & 0x1
            self.hsIsys = (self.reg_value >> 15) & 0x1
            self.hsVsys = (self.reg_value >> 14) & 0x1
            self.hsVin = (self.reg_value >> 13) & 0x1
            self.hsPout2 = (self.reg_value >> 12) & 0x1
            self.hsPout1 = (self.reg_value >> 11) & 0x1
            self.hsPout0 = (self.reg_value >> 10) & 0x1
            self.hsIout2 = (self.reg_value >> 9) & 0x1
            self.hsIout1 = (self.reg_value >> 8) & 0x1
            self.hsIout0 = (self.reg_value >> 7) & 0x1
            self.hsVout2 = (self.reg_value >> 6) & 0x1
            self.hsVout1 = (self.reg_value >> 5) & 0x1
            self.hsVout0 = (self.reg_value >> 4) & 0x1
            self.posPout = (self.reg_value >> 3) & 0x1
            self.posIout = (self.reg_value >> 2) & 0x1
            self.posIin = (self.reg_value >> 1) & 0x1
            self.posVin = self.reg_value & 0x1

    def read_object(self):
        return(self.hwBypass_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFF) + ((register_object.hsAuxImon & 0x1) << 17)
        reg = (reg & 0x2FFFF) + ((register_object.hsPsys & 0x1) << 16)
        reg = (reg & 0x37FFF) + ((register_object.hsIsys & 0x1) << 15)
        reg = (reg & 0x3BFFF) + ((register_object.hsVsys & 0x1) << 14)
        reg = (reg & 0x3DFFF) + ((register_object.hsVin & 0x1) << 13)
        reg = (reg & 0x3EFFF) + ((register_object.hsPout2 & 0x1) << 12)
        reg = (reg & 0x3F7FF) + ((register_object.hsPout1 & 0x1) << 11)
        reg = (reg & 0x3FBFF) + ((register_object.hsPout0 & 0x1) << 10)
        reg = (reg & 0x3FDFF) + ((register_object.hsIout2 & 0x1) << 9)
        reg = (reg & 0x3FEFF) + ((register_object.hsIout1 & 0x1) << 8)
        reg = (reg & 0x3FF7F) + ((register_object.hsIout0 & 0x1) << 7)
        reg = (reg & 0x3FFBF) + ((register_object.hsVout2 & 0x1) << 6)
        reg = (reg & 0x3FFDF) + ((register_object.hsVout1 & 0x1) << 5)
        reg = (reg & 0x3FFEF) + ((register_object.hsVout0 & 0x1) << 4)
        reg = (reg & 0x3FFF7) + ((register_object.posPout & 0x1) << 3)
        reg = (reg & 0x3FFFB) + ((register_object.posIout & 0x1) << 2)
        reg = (reg & 0x3FFFD) + ((register_object.posIin & 0x1) << 1)
        reg = (reg & 0x3FFFE) + (register_object.posVin & 0x1)
        dma(self.address, 0xE870, reg)
    ## Bypass hardware high-speed bus telemetry aux channel (external) Imon current scaling and use firmware
    def hsAuxImon(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 17, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry system input power scaling and use firmware
    def hsPsys(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 16, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry system input current scaling and use firmware
    def hsIsys(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 15, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry system input voltage scaling and use firmware
    def hsVsys(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 14, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry input voltage (all channels) scaling and use firmware
    def hsVin(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 13, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output power scaling (ch 2) and use firmware
    def hsPout2(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 12, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output power scaling (ch 1) and use firmware
    def hsPout1(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 11, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output power scaling (ch 0) and use firmware
    def hsPout0(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 10, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output current scaling (ch 2) and use firmware
    def hsIout2(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 9, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output current scaling (ch 1) and use firmware
    def hsIout1(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 8, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output current scaling (ch 0) and use firmware
    def hsIout0(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 7, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output voltage scaling (ch 2) and use firmware
    def hsVout2(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 6, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output voltage scaling (ch 1) and use firmware
    def hsVout1(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 5, value)
        return(value)
    ## Bypass hardware high-speed bus telemetry output voltage scaling (ch 0) and use firmware
    def hsVout0(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 4, value)
        return(value)
    ## Clip PMBus telem Pout values to be >=0 if this is set
    def posPout(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 3, value)
        return(value)
    ## Clip PMBus telem Iout values to be >=0 if this is set
    def posIout(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 2, value)
        return(value)
    ## [Deprecated] Clip PMBus telem Iin values to be >=0 if this is set
    def posIin(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 1, value)
        return(value)
    ## Clip PMBus telem Vin values to be >=0 if this is set
    def posVin(self, value = None):
        value = dma_bits(0xE870, self.address, 1, 0, value)
        return(value)

###################################################################
## Firmware scaled high-speed bus telem result Vin all channels
###################################################################
class mcuHsVin_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE871, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vsys (svidVin3)
###################################################################
class mcuHsVsys_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE872, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vsys (svidIin3)
###################################################################
class mcuHsIsys_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE873, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vsys (svidPin3)
###################################################################
class mcuHsPsys_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE874, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result aux channel Imon (SVIDIOUT3)
###################################################################
class mcuHsAuxImon_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE875, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vout0
###################################################################
class mcuHsVout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE876, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vout1
###################################################################
class mcuHsVout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE877, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Vout2
###################################################################
class mcuHsVout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE878, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Iout0
###################################################################
class mcuHsIout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE879, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Iout1
###################################################################
class mcuHsIout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE87A, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Iout2
###################################################################
class mcuHsIout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE87B, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Pout0
###################################################################
class mcuHsPout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE87C, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Pout1
###################################################################
class mcuHsPout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE87D, value)
        return(value)


###################################################################
## Firmware scaled high-speed bus telem result Pout2
###################################################################
class mcuHsPout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE87E, value)
        return(value)


###################################################################
## Programmable telemetry update interrupt time period.
###################################################################
class telIrqTicks_class(object):
    def __init__(self, address):
        self.interface = 'utcTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE87F, value)
        return(value)


###################################################################
## General Purpose Timer Configuration
###################################################################
class tConfig_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 31

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tConfig_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8B0, None)
            self.tsCapSlvSel = (self.reg_value >> 29) & 0x3
            self.dtbSrcSel = (self.reg_value >> 25) & 0xF
            self.intrOnCapEvntEn = (self.reg_value >> 24) & 0x1
            self.intrTimerOn = (self.reg_value >> 23) & 0x1
            self.evntCntMax = (self.reg_value >> 15) & 0xFF
            self.tickClkSel = (self.reg_value >> 10) & 0x1F
            self.trigType = (self.reg_value >> 4) & 0x3F
            self.cntOpt = (self.reg_value >> 2) & 0x3
            self.intrEn = (self.reg_value >> 1) & 0x1
            self.timerEn = self.reg_value & 0x1

    def read_object(self):
        return(self.tConfig_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.tsCapSlvSel & 0x3) << 29)
        reg = (reg & 0x61FFFFFF) + ((register_object.dtbSrcSel & 0xF) << 25)
        reg = (reg & 0x7EFFFFFF) + ((register_object.intrOnCapEvntEn & 0x1) << 24)
        reg = (reg & 0x7F7FFFFF) + ((register_object.intrTimerOn & 0x1) << 23)
        reg = (reg & 0x7F807FFF) + ((register_object.evntCntMax & 0xFF) << 15)
        reg = (reg & 0x7FFF83FF) + ((register_object.tickClkSel & 0x1F) << 10)
        reg = (reg & 0x7FFFFC0F) + ((register_object.trigType & 0x3F) << 4)
        reg = (reg & 0x7FFFFFF3) + ((register_object.cntOpt & 0x3) << 2)
        reg = (reg & 0x7FFFFFFD) + ((register_object.intrEn & 0x1) << 1)
        reg = (reg & 0x7FFFFFFE) + (register_object.timerEn & 0x1)
        dma(self.address, 0xE8B0, reg)
    ## Select the external DTB trigger signal for trigType = 1 mode
    def tsCapSlvSel(self, value = None):
        value = dma_bits(0xE8B0, self.address, 2, 29, value)
        return(value)
    ## Select the external DTB trigger signal for trigType = 1 mode
    def dtbSrcSel(self, value = None):
        value = dma_bits(0xE8B0, self.address, 4, 25, value)
        return(value)
    ## Interrupt occurs on timestamp capture event
    def intrOnCapEvntEn(self, value = None):
        value = dma_bits(0xE8B0, self.address, 1, 24, value)
        return(value)
    ## Interrupt occurs on trigger event that restarts the timer
    def intrTimerOn(self, value = None):
        value = dma_bits(0xE8B0, self.address, 1, 23, value)
        return(value)
    ## Number of timer events before interrupt occurs
    def evntCntMax(self, value = None):
        value = dma_bits(0xE8B0, self.address, 8, 15, value)
        return(value)
    ## Timer tick clock source selection. 0: 1us, 1: 100us, 2: 250ns, 3: clock Ts, 4: clockTs/2, 5: clockTs/4, others: reserved.
    def tickClkSel(self, value = None):
        value = dma_bits(0xE8B0, self.address, 5, 10, value)
        return(value)
    ## 0: Timer is not triggered by external events, 1: Timer is triggered by next DTB capture event, 2: Timestamp capture is triggered on Timestamp capture events masks. Timer is free running. Event counts are how many times the counter has been reset to 0. others: reserved
    def trigType(self, value = None):
        value = dma_bits(0xE8B0, self.address, 6, 4, value)
        return(value)
    ## 0: Counter register increments 1 per timer tick, 1: Coutner register increments 1 per timer tick. Timer starts on first trigger event and stops on second event, 2: Counter register increments 1 per time tick. Timer starts on first trigger event and restarts on each subsequent event, others: reserved
    def cntOpt(self, value = None):
        value = dma_bits(0xE8B0, self.address, 2, 2, value)
        return(value)
    ## Interrupt occurs when evntCnt = evntCntMax
    def intrEn(self, value = None):
        value = dma_bits(0xE8B0, self.address, 1, 1, value)
        return(value)
    ## 1: Timer is enabled and counter is updated each timer tick period, 0: Timer is disabled and counter is not updated
    def timerEn(self, value = None):
        value = dma_bits(0xE8B0, self.address, 1, 0, value)
        return(value)

###################################################################
## General Purpose Timer Max Counter Value
###################################################################
class tCounterReload_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B1, value)
        return(value)


###################################################################
## General Purpose Timer Max Counter Value
###################################################################
class tStatus_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8B2, None)
            self.validCapture = (self.reg_value >> 11) & 0x1
            self.intrStatus = (self.reg_value >> 10) & 0x1
            self.timerOnFlag = (self.reg_value >> 9) & 0x1
            self.evntCnt = (self.reg_value >> 1) & 0xFF
            self.clrEvntCnt = self.reg_value & 0x1

    def read_object(self):
        return(self.tStatus_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.validCapture & 0x1) << 11)
        reg = (reg & 0xBFF) + ((register_object.intrStatus & 0x1) << 10)
        reg = (reg & 0xDFF) + ((register_object.timerOnFlag & 0x1) << 9)
        reg = (reg & 0xE01) + ((register_object.evntCnt & 0xFF) << 1)
        reg = (reg & 0xFFE) + (register_object.clrEvntCnt & 0x1)
        dma(self.address, 0xE8B2, reg)
    ## 1: tTsCapture register has valid trigger timestamp
    def validCapture(self):
        value = dma_bits(0xE8B2, self.address, 1, 11, None)
        return(value)
    ## Interrupt status bit. Write 0 to clear interrupt status
    def intrStatus(self, value = None):
        value = dma_bits(0xE8B2, self.address, 1, 10, value)
        return(value)
    ## Timer was activated during the last interrupt assertion
    def timerOnFlag(self):
        value = dma_bits(0xE8B2, self.address, 1, 9, None)
        return(value)
    ## Number of times timer event has occurred
    def evntCnt(self):
        value = dma_bits(0xE8B2, self.address, 8, 1, None)
        return(value)
    ## Write 1 to clear Status register
    def clrEvntCnt(self, value = None):
        value = dma_bits(0xE8B2, self.address, 1, 0, value)
        return(value)

###################################################################
## General Purpose Timer Current Counter Value
###################################################################
class tCntVal_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B3, value)
        return(value)


###################################################################
## General Purpose Timer Timestamp Capture Mask
###################################################################
class tTsCaptureMask_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tTsCaptureMask_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8B4, None)
            self.svi3PSChg = (self.reg_value >> 9) & 0x1
            self.svi3Vid = (self.reg_value >> 8) & 0x1
            self.svidDvidDnDecay = (self.reg_value >> 3) & 0x1
            self.svidSetPS = (self.reg_value >> 2) & 0x1
            self.svidDvidDn = (self.reg_value >> 1) & 0x1
            self.svidDvidUp = self.reg_value & 0x1

    def read_object(self):
        return(self.tTsCaptureMask_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FF) + ((register_object.svi3PSChg & 0x1) << 9)
        reg = (reg & 0x2FF) + ((register_object.svi3Vid & 0x1) << 8)
        reg = (reg & 0x3F7) + ((register_object.svidDvidDnDecay & 0x1) << 3)
        reg = (reg & 0x3FB) + ((register_object.svidSetPS & 0x1) << 2)
        reg = (reg & 0x3FD) + ((register_object.svidDvidDn & 0x1) << 1)
        reg = (reg & 0x3FE) + (register_object.svidDvidUp & 0x1)
        dma(self.address, 0xE8B4, reg)
    ## Capture on SVI3 Change Power State event
    def svi3PSChg(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 9, value)
        return(value)
    ## Capture on SVI3 VID packet event
    def svi3Vid(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 8, value)
        return(value)
    ## Capture on SVID DVID down decay event
    def svidDvidDnDecay(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 3, value)
        return(value)
    ## Capture on SVID setPS event
    def svidSetPS(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 2, value)
        return(value)
    ## Capture on SVID DVID down event
    def svidDvidDn(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 1, value)
        return(value)
    ## Capture on SVID DVID up event
    def svidDvidUp(self, value = None):
        value = dma_bits(0xE8B4, self.address, 1, 0, value)
        return(value)

###################################################################
## General Purpose Timer Timestamp Capture. This register shows the top of the 2-deep FIFO entries of capture result.
###################################################################
class tTsCapture_class(object):
    def __init__(self, address):
        self.interface = 'timerBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8B5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tTsCapture_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8B5, None)
            self.tsCapSource = (self.reg_value >> 28) & 0xF
            self.tsEvntMiss = (self.reg_value >> 27) & 0x1
            self.tsFifoNonEmpty = (self.reg_value >> 26) & 0x1
            self.timesRst0Cnt = (self.reg_value >> 17) & 0xFF
            self.timeStampCnt = self.reg_value & 0x1FFFF

    def read_object(self):
        return(self.tTsCapture_Object(self.address))

    ## Encode the source of the capture event in these 4 bits: 0: SVID DVID up event occurred, 1: SVID DVID down event occured, 2: SVID SetPS event occurred, 3: SVID DVID down decay event occurred, 4~7: Reserved, 8: SVI3 VID packet event occurred, 9: SVI3 Change Power State event occurred, 10 ~ 15: Reserved.
    def tsCapSource(self):
        value = dma_bits(0xE8B5, self.address, 4, 28, None)
        return(value)
    ## The timer capture FIFO is full, and some trigger event is missing
    def tsEvntMiss(self):
        value = dma_bits(0xE8B5, self.address, 1, 27, None)
        return(value)
    ## The timer capture is still not empty after reading this entry. The host should read this register one more time
    def tsFifoNonEmpty(self):
        value = dma_bits(0xE8B5, self.address, 1, 26, None)
        return(value)
    ## Number of times counter was reset to 0
    def timesRst0Cnt(self):
        value = dma_bits(0xE8B5, self.address, 8, 17, None)
        return(value)
    ## Timer count value captured upon event
    def timeStampCnt(self):
        value = dma_bits(0xE8B5, self.address, 17, 0, None)
        return(value)

###################################################################
## Phase telemetry test data control
###################################################################
class phaseTelTest_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xE890, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phaseTelTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE890, None)
            self.runPhaseOnly = (self.reg_value >> 11) & 0x1
            self.faultDet = (self.reg_value >> 10) & 0x1
            self.selMonOut = (self.reg_value >> 9) & 0x1
            self.selIsen = (self.reg_value >> 8) & 0x1
            self.testPhase = self.reg_value & 0xFF

    def read_object(self):
        return(self.phaseTelTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FF) + ((register_object.runPhaseOnly & 0x1) << 11)
        reg = (reg & 0xBFF) + ((register_object.faultDet & 0x1) << 10)
        reg = (reg & 0xDFF) + ((register_object.selMonOut & 0x1) << 9)
        reg = (reg & 0xEFF) + ((register_object.selIsen & 0x1) << 8)
        reg = (reg & 0xF00) + (register_object.testPhase & 0xFF)
        dma(self.address, 0xE890, reg)
    ## Run phase filter path even if phase off
    def runPhaseOnly(self, value = None):
        value = dma_bits(0xE890, self.address, 1, 11, value)
        return(value)
    ## Replace data feeding phase balance and dig peak OC detectors also
    def faultDet(self, value = None):
        value = dma_bits(0xE890, self.address, 1, 10, value)
        return(value)
    ## Report monOutPhase data if 1 (all phases)
    def selMonOut(self, value = None):
        value = dma_bits(0xE890, self.address, 1, 9, value)
        return(value)
    ## Report Isen data if 1, Iest if 0 (all phases)
    def selIsen(self, value = None):
        value = dma_bits(0xE890, self.address, 1, 8, value)
        return(value)
    ## Replace phase current (synth/adc) data phase mask
    def testPhase(self, value = None):
        value = dma_bits(0xE890, self.address, 8, 0, value)
        return(value)

###################################################################
## Phase telemetry test data
###################################################################
class phaseTestData_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE891, value)
        return(value)


###################################################################
## Isense full-scale range per phase for channel
###################################################################
class iSenRange0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE892, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenRange0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE892, None)
            self.iAdcShift = (self.reg_value >> 12) & 0xF
            self.iAdcFineGain = self.reg_value & 0xFFF

    def read_object(self):
        return(self.iSenRange0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.iAdcShift & 0xF) << 12)
        reg = (reg & 0xF000) + (register_object.iAdcFineGain & 0xFFF)
        dma(self.address, 0xE892, reg)
    ## Isense right shift to get to 100ma
    def iAdcShift(self, value = None):
        value = dma_bits(0xE892, self.address, 4, 12, value)
        return(value)
    ## Isense right shift to get to 100ma
    def iAdcFineGain(self, value = None):
        value = dma_bits(0xE892, self.address, 12, 0, value)
        return(value)

###################################################################
## Isense full-scale range per phase for channel
###################################################################
class iSenRange1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE893, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenRange1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE893, None)
            self.iAdcShift = (self.reg_value >> 12) & 0xF
            self.iAdcFineGain = self.reg_value & 0xFFF

    def read_object(self):
        return(self.iSenRange1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.iAdcShift & 0xF) << 12)
        reg = (reg & 0xF000) + (register_object.iAdcFineGain & 0xFFF)
        dma(self.address, 0xE893, reg)
    ## Isense right shift to get to 100ma
    def iAdcShift(self, value = None):
        value = dma_bits(0xE893, self.address, 4, 12, value)
        return(value)
    ## Isense right shift to get to 100ma
    def iAdcFineGain(self, value = None):
        value = dma_bits(0xE893, self.address, 12, 0, value)
        return(value)

###################################################################
## Isense full-scale range per phase for channel
###################################################################
class iSenRange2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE894, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenRange2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE894, None)
            self.iAdcShift = (self.reg_value >> 12) & 0xF
            self.iAdcFineGain = self.reg_value & 0xFFF

    def read_object(self):
        return(self.iSenRange2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.iAdcShift & 0xF) << 12)
        reg = (reg & 0xF000) + (register_object.iAdcFineGain & 0xFFF)
        dma(self.address, 0xE894, reg)
    ## Isense right shift to get to 100ma
    def iAdcShift(self, value = None):
        value = dma_bits(0xE894, self.address, 4, 12, value)
        return(value)
    ## Isense right shift to get to 100ma
    def iAdcFineGain(self, value = None):
        value = dma_bits(0xE894, self.address, 12, 0, value)
        return(value)

###################################################################
## Loop Telem phase current filter
###################################################################
class filtIph_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE898, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtIph_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE898, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtIph_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE898, reg)
    ## Time constant right shift (1=3.7us 2=9.2u 3=20u 4=41u 5=83u 6=166u 7=340u 8=680u 9=1.35u 10=2.7ms 11=5.45m)
    def shft(self, value = None):
        value = dma_bits(0xE898, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier (tau = 1/mant * shift value lookup)
    def mant(self, value = None):
        value = dma_bits(0xE898, self.address, 4, 0, value)
        return(value)

###################################################################
## Loop Telem output sense voltage filter
###################################################################
class filtVadc_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE899, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtVadc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE899, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtVadc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE899, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE899, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE899, self.address, 4, 0, value)
        return(value)

###################################################################
## Loop Telem channel output current filter
###################################################################
class filtIout_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE89A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtIout_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE89A, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtIout_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE89A, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE89A, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE89A, self.address, 4, 0, value)
        return(value)

###################################################################
## Loop Telem channel output power filter
###################################################################
class filtPout_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE89B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class filtPout_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE89B, None)
            self.shft = (self.reg_value >> 4) & 0xF
            self.mant = self.reg_value & 0xF

    def read_object(self):
        return(self.filtPout_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.shft & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.mant & 0xF)
        dma(self.address, 0xE89B, reg)
    ## Time constant right shift
    def shft(self, value = None):
        value = dma_bits(0xE89B, self.address, 4, 4, value)
        return(value)
    ## Time constant fractional multiplier
    def mant(self, value = None):
        value = dma_bits(0xE89B, self.address, 4, 0, value)
        return(value)

###################################################################
## [Deprecated] Loop Telem input power scaling
###################################################################
class gainPin0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE89C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPin0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE89C, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPin0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE89C, reg)
    ## Up shift applied to voltage when computing power
    def vShift(self, value = None):
        value = dma_bits(0xE89C, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor
    def val(self, value = None):
        value = dma_bits(0xE89C, self.address, 16, 0, value)
        return(value)

###################################################################
## [Deprecated] Loop Telem input power scaling
###################################################################
class gainPin1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE89D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPin1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE89D, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPin1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE89D, reg)
    ## Up shift applied to voltage when computing power
    def vShift(self, value = None):
        value = dma_bits(0xE89D, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor
    def val(self, value = None):
        value = dma_bits(0xE89D, self.address, 16, 0, value)
        return(value)

###################################################################
## Loop Telem channel output voltage scaling
###################################################################
class gainVadc0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE89E, value)
        return(value)


###################################################################
## Loop Telem channel output voltage scaling
###################################################################
class gainVadc1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE89F, value)
        return(value)


###################################################################
## Loop Telem channel output voltage scaling
###################################################################
class gainVadc2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A0, value)
        return(value)


###################################################################
## Loop Telem channel output power scaling
###################################################################
class gainPout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPout0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A1, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPout0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A1, reg)
    ## Up shift applied to voltage when computing power
    def vShift(self, value = None):
        value = dma_bits(0xE8A1, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor
    def val(self, value = None):
        value = dma_bits(0xE8A1, self.address, 16, 0, value)
        return(value)

###################################################################
## Loop Telem channel output power scaling
###################################################################
class gainPout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPout1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A2, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPout1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A2, reg)
    ## Up shift applied to voltage when computing power
    def vShift(self, value = None):
        value = dma_bits(0xE8A2, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor
    def val(self, value = None):
        value = dma_bits(0xE8A2, self.address, 16, 0, value)
        return(value)

###################################################################
## Loop Telem channel output power scaling
###################################################################
class gainPout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainPout2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A3, None)
            self.vShift = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainPout2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vShift & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A3, reg)
    ## Up shift applied to voltage when computing power
    def vShift(self, value = None):
        value = dma_bits(0xE8A3, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor
    def val(self, value = None):
        value = dma_bits(0xE8A3, self.address, 16, 0, value)
        return(value)

###################################################################
## [Deprecated] SVID Pin Alert scaling
###################################################################
class gainPinAlert_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A4, value)
        return(value)


###################################################################
## High-speed interface channel output voltage telemetry scaling
###################################################################
class gainHsVout_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsVout_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A5, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsVout_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A5, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8A5, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8A5, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output current telemetry offset
###################################################################
class offHsVout_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class offHsVout_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A6, None)
            self.invert = (self.reg_value >> 16) & 0x1
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.offHsVout_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.invert & 0x1) << 16)
        reg = (reg & 0x10000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A6, reg)
    ## Invert sign of incoming PMBus Vout data for SVI2 VID conversion
    def invert(self, value = None):
        value = dma_bits(0xE8A6, self.address, 1, 16, value)
        return(value)
    ## Reporting Vout offset for HS bus, subtracted from PMBus value
    def val(self, value = None):
        value = dma_bits(0xE8A6, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output current telemetry scaling
###################################################################
class gainHsIout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsIout0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A7, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsIout0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A7, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8A7, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8A7, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output current telemetry offset
###################################################################
class offHsIout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A8, value)
        return(value)


###################################################################
## High-speed interface channel output current telemetry scaling
###################################################################
class gainHsIout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8A9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsIout1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8A9, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsIout1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8A9, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8A9, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8A9, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output current telemetry offset
###################################################################
class offHsIout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AA, value)
        return(value)


###################################################################
## High-speed interface channel output current telemetry scaling
###################################################################
class gainHsIout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsIout2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8AB, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsIout2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8AB, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8AB, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8AB, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output current telemetry offset
###################################################################
class offHsIout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AC, value)
        return(value)


###################################################################
## High-speed interface channel output power telemetry scaling
###################################################################
class gainHsPout0_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsPout0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8AD, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsPout0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8AD, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8AD, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8AD, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output power telemetry scaling
###################################################################
class gainHsPout1_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsPout1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8AE, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsPout1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8AE, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8AE, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8AE, self.address, 16, 0, value)
        return(value)

###################################################################
## High-speed interface channel output power telemetry scaling
###################################################################
class gainHsPout2_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8AF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class gainHsPout2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8AF, None)
            self.shft = (self.reg_value >> 16) & 0x3
            self.val = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.gainHsPout2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.shft & 0x3) << 16)
        reg = (reg & 0x30000) + (register_object.val & 0xFFFF)
        dma(self.address, 0xE8AF, reg)
    ## Shift after multiply (left shift by 4,6,8,10)
    def shft(self, value = None):
        value = dma_bits(0xE8AF, self.address, 2, 16, value)
        return(value)
    ## Reporting scale factor for HS bus (will be left-shifted 1 bit since unsigned)
    def val(self, value = None):
        value = dma_bits(0xE8AF, self.address, 16, 0, value)
        return(value)

###################################################################
## PMBus telemetry LSB size
###################################################################
class pmbTelLsb_class(object):
    def __init__(self, address):
        self.interface = 'lpTel'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xE8C0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pmbTelLsb_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8C0, None)
            self.iInSen1Lsb = (self.reg_value >> 16) & 0x3
            self.iInSen0Lsb = (self.reg_value >> 14) & 0x3
            self.vInSen1Lsb = (self.reg_value >> 12) & 0x3
            self.vInSen0Lsb = (self.reg_value >> 10) & 0x3
            self.pOutLsb = (self.reg_value >> 8) & 0x3
            self.iOutLsb = (self.reg_value >> 6) & 0x3
            self.pInLsb = (self.reg_value >> 4) & 0x3
            self.iInLsb = (self.reg_value >> 2) & 0x3
            self.vInLsb = self.reg_value & 0x3

    def read_object(self):
        return(self.pmbTelLsb_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iInSen1Lsb & 0x3) << 16)
        reg = (reg & 0x33FFF) + ((register_object.iInSen0Lsb & 0x3) << 14)
        reg = (reg & 0x3CFFF) + ((register_object.vInSen1Lsb & 0x3) << 12)
        reg = (reg & 0x3F3FF) + ((register_object.vInSen0Lsb & 0x3) << 10)
        reg = (reg & 0x3FCFF) + ((register_object.pOutLsb & 0x3) << 8)
        reg = (reg & 0x3FF3F) + ((register_object.iOutLsb & 0x3) << 6)
        reg = (reg & 0x3FFCF) + ((register_object.pInLsb & 0x3) << 4)
        reg = (reg & 0x3FFF3) + ((register_object.iInLsb & 0x3) << 2)
        reg = (reg & 0x3FFFC) + (register_object.vInLsb & 0x3)
        dma(self.address, 0xE8C0, reg)
    ## 1=0.1
    def iInSen1Lsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 16, value)
        return(value)
    ## 1=0.1
    def iInSen0Lsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 14, value)
        return(value)
    ## 1=0.1
    def vInSen1Lsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 12, value)
        return(value)
    ## 1=0.1
    def vInSen0Lsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 10, value)
        return(value)
    ## 1=0.1W
    def pOutLsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 8, value)
        return(value)
    ## 1=0.1A
    def iOutLsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 6, value)
        return(value)
    ## 1=0.1W
    def pInLsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 4, value)
        return(value)
    ## 1=0.1A
    def iInLsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 2, value)
        return(value)
    ## 1=0.1V
    def vInLsb(self, value = None):
        value = dma_bits(0xE8C0, self.address, 2, 0, value)
        return(value)

###################################################################
## Vout 0 Alert Mask
###################################################################
class voutMask0_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D0, value)
        return(value)


###################################################################
## Vout 1 Alert Mask
###################################################################
class voutMask1_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D1, value)
        return(value)


###################################################################
## Vout 2 Alert Mask
###################################################################
class voutMask2_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D2, value)
        return(value)


###################################################################
## Iout 0 Alert Mask
###################################################################
class ioutMask0_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D3, value)
        return(value)


###################################################################
## Iout 1 Alert Mask
###################################################################
class ioutMask1_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D4, value)
        return(value)


###################################################################
## Iout 2 Alert Mask
###################################################################
class ioutMask2_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D5, value)
        return(value)


###################################################################
## Input 0 Alert Mask
###################################################################
class inputMask0_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D6, value)
        return(value)


###################################################################
## Input 1 Alert Mask
###################################################################
class inputMask1_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D7, value)
        return(value)


###################################################################
## Input 2 Alert Mask
###################################################################
class inputMask2_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D8, value)
        return(value)


###################################################################
## Temp 0 Alert Mask
###################################################################
class tempMask0_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8D9, value)
        return(value)


###################################################################
## Temp 1 Alert Mask
###################################################################
class tempMask1_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8DA, value)
        return(value)


###################################################################
## Temp 2 Alert Mask
###################################################################
class tempMask2_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8DB, value)
        return(value)


###################################################################
## CML Alert Mask
###################################################################
class cmlMask_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8DC, value)
        return(value)


###################################################################
## MFR Alert Mask
###################################################################
class mfrMask_class(object):
    def __init__(self, address):
        self.interface = 'smbMsk'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE8DD, value)
        return(value)


###################################################################
## Multi-function input pin control
###################################################################
class multiFunInSwditms_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInSwditms_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E0, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInSwditms_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E0, reg)
    ## Select DIOE11 input for SWDITMS
    def dioe11(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for SWDITMS
    def dio10(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for SWDITMS
    def dio9(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for SWDITMS
    def dior8(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for SWDITMS
    def diopg7(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for SWDITMS
    def dio6(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for SWDITMS
    def dio5(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for SWDITMS
    def dioe4(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for SWDITMS
    def diopg3(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for SWDITMS
    def dioe2(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for SWDITMS
    def diopg1(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for SWDITMS
    def dio0(self, value = None):
        value = dma_bits(0xE8E0, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInSwclktck_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInSwclktck_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E1, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInSwclktck_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E1, reg)
    ## Select DIOE11 input for SWDITMS
    def dioe11(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for SWDITMS
    def dio10(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for SWDITMS
    def dio9(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for SWDITMS
    def dior8(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for SWDITMS
    def diopg7(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for SWDITMS
    def dio6(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for SWDITMS
    def dio5(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for SWDITMS
    def dioe4(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for SWDITMS
    def diopg3(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for SWDITMS
    def dioe2(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for SWDITMS
    def diopg1(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for SWDITMS
    def dio0(self, value = None):
        value = dma_bits(0xE8E1, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInEn0_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInEn0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E2, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInEn0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E2, reg)
    ## Select DIOE11 input for EN0
    def dioe11(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for EN0
    def dio10(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for EN0
    def dio9(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for EN0
    def dior8(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for EN0
    def diopg7(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for EN0
    def dio6(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for EN0
    def dio5(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for EN0 - default
    def dioe4(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for EN0
    def diopg3(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for EN0
    def dioe2(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for EN0
    def diopg1(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for EN0
    def dio0(self, value = None):
        value = dma_bits(0xE8E2, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInEn1_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInEn1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E3, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInEn1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E3, reg)
    ## Select DIOE11 input for EN1 - default
    def dioe11(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for EN1
    def dio10(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for EN1
    def dio9(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for EN1
    def dior8(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for EN1
    def diopg7(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for EN1
    def dio6(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for EN1
    def dio5(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for EN1
    def dioe4(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for EN1
    def diopg3(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for EN1
    def dioe2(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for EN1
    def diopg1(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for EN1
    def dio0(self, value = None):
        value = dma_bits(0xE8E3, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInEn2_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInEn2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E4, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInEn2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E4, reg)
    ## Select DIOE11 input for EN2
    def dioe11(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for EN2
    def dio10(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for EN2
    def dio9(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for EN2
    def dior8(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for EN2
    def diopg7(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for EN2
    def dio6(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for EN2
    def dio5(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for EN2
    def dioe4(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for EN2
    def diopg3(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for EN2
    def dioe2(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for EN2
    def diopg1(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for EN2
    def dio0(self, value = None):
        value = dma_bits(0xE8E4, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio0_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E5, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E5, reg)
    ## Select DIOE11 input for GPIO0
    def dioe11(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO0
    def dio10(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO0
    def dio9(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO0
    def dior8(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO0
    def diopg7(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO0- default GPIO0
    def dio6(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO0
    def dio5(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO0
    def dioe4(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO0
    def diopg3(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO0
    def dioe2(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO0
    def diopg1(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO0
    def dio0(self, value = None):
        value = dma_bits(0xE8E5, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio1_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E6, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E6, reg)
    ## Select DIOE11 input for GPIO1
    def dioe11(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO1
    def dio10(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO1
    def dio9(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO1 - default GPIO1
    def dior8(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO1
    def diopg7(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO1
    def dio6(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO1
    def dio5(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO1
    def dioe4(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO1
    def diopg3(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO1
    def dioe2(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO1
    def diopg1(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO1
    def dio0(self, value = None):
        value = dma_bits(0xE8E6, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio2_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E7, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E7, reg)
    ## Select DIOE11 input for GPIO2 - default EN1
    def dioe11(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO2
    def dio10(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO2
    def dio9(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO2
    def dior8(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO2
    def diopg7(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO2
    def dio6(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO2
    def dio5(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO2
    def dioe4(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO2
    def diopg3(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO2
    def dioe2(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO2
    def diopg1(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO2
    def dio0(self, value = None):
        value = dma_bits(0xE8E7, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio3_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E8, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E8, reg)
    ## Select DIOE11 input for GPIO3
    def dioe11(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO3
    def dio10(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO3
    def dio9(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO3
    def dior8(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO3
    def diopg7(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO3
    def dio6(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO3
    def dio5(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO3
    def dioe4(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO3
    def diopg3(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO3 - default EN2
    def dioe2(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO3
    def diopg1(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO3
    def dio0(self, value = None):
        value = dma_bits(0xE8E8, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio4_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8E9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio4_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8E9, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio4_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8E9, reg)
    ## Select DIOE11 input for GPIO4
    def dioe11(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO4
    def dio10(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO4 - default for SDIFCLK
    def dio9(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO4
    def dior8(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO4
    def diopg7(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO4
    def dio6(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO4
    def dio5(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO4
    def dioe4(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO4
    def diopg3(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO4
    def dioe2(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO4
    def diopg1(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO4
    def dio0(self, value = None):
        value = dma_bits(0xE8E9, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio5_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8EA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio5_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8EA, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio5_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8EA, reg)
    ## Select DIOE11 input for GPIO5
    def dioe11(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO5 - default for SDIFDATA
    def dio10(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO5
    def dio9(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO5
    def dior8(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO5
    def diopg7(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO5
    def dio6(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO5
    def dio5(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO5
    def dioe4(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO5
    def diopg3(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO5
    def dioe2(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO5
    def diopg1(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO5 - default nPMALERT
    def dio0(self, value = None):
        value = dma_bits(0xE8EA, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio6_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8EB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio6_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8EB, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio6_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8EB, reg)
    ## Select DIOE11 input for GPIO6
    def dioe11(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO6
    def dio10(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO6
    def dio9(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO6
    def dior8(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO6
    def diopg7(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO6
    def dio6(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO6 - default nVRHOT
    def dio5(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO6
    def dioe4(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO6
    def diopg3(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO6
    def dioe2(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO6
    def diopg1(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO6
    def dio0(self, value = None):
        value = dma_bits(0xE8EB, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function input pin control
###################################################################
class multiFunInGpio7_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE8EC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunInGpio7_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8EC, None)
            self.dioe11 = (self.reg_value >> 11) & 0x1
            self.dio10 = (self.reg_value >> 10) & 0x1
            self.dio9 = (self.reg_value >> 9) & 0x1
            self.dior8 = (self.reg_value >> 8) & 0x1
            self.diopg7 = (self.reg_value >> 7) & 0x1
            self.dio6 = (self.reg_value >> 6) & 0x1
            self.dio5 = (self.reg_value >> 5) & 0x1
            self.dioe4 = (self.reg_value >> 4) & 0x1
            self.diopg3 = (self.reg_value >> 3) & 0x1
            self.dioe2 = (self.reg_value >> 2) & 0x1
            self.diopg1 = (self.reg_value >> 1) & 0x1
            self.dio0 = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunInGpio7_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.dioe11 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.dio10 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.dio9 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.dior8 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diopg7 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.dio6 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dio5 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dioe4 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.diopg3 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.dioe2 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diopg1 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.dio0 & 0x1)
        dma(self.address, 0xE8EC, reg)
    ## Select DIOE11 input for GPIO7
    def dioe11(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 11, value)
        return(value)
    ## Select DIO10 input for GPIO7
    def dio10(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 10, value)
        return(value)
    ## Select DIO9 input for GPIO7
    def dio9(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 9, value)
        return(value)
    ## Select DIOR8 input for GPIO7
    def dior8(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 8, value)
        return(value)
    ## Select DIOPG7 input for GPIO7
    def diopg7(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 7, value)
        return(value)
    ## Select DIO6 input for GPIO7
    def dio6(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 6, value)
        return(value)
    ## Select DIO5 input for GPIO7
    def dio5(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 5, value)
        return(value)
    ## Select DIOE4 input for GPIO7
    def dioe4(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 4, value)
        return(value)
    ## Select DIOPG3 input for GPIO7
    def diopg3(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 3, value)
        return(value)
    ## Select DIOE2 input for GPIO7
    def dioe2(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 2, value)
        return(value)
    ## Select DIOPG1 input for GPIO7
    def diopg1(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 1, value)
        return(value)
    ## Select DIO0 input for GPIO7
    def dio0(self, value = None):
        value = dma_bits(0xE8EC, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDio0_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDio0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F0, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDio0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F0, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F0, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F0, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioPg1_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioPg1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F1, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioPg1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F1, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F1, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2 (default)<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F1, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioE2_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioE2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F2, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioE2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F2, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F2, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F2, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioPg3_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioPg3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F3, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioPg3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F3, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F3, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0 (default)<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F3, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioE4_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioE4_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F4, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioE4_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F4, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F4, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F4, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDio5_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDio5_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F5, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDio5_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F5, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F5, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal - default
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F5, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDio6_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDio6_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F6, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDio6_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F6, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F6, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal - default
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F6, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioPg7_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioPg7_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F7, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioPg7_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F7, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F7, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1 (default)<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F7, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioR8_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioR8_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F8, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioR8_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F8, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F8, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F8, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDio9_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8F9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDio9_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8F9, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDio9_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8F9, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8F9, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock - default
    def sdifClk(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8F9, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDio10_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8FA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDio10_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8FA, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDio10_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8FA, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8FA, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data - default
    def sdifData(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8FA, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin control
###################################################################
class multiFunOutDioE11_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8FB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class multiFunOutDioE11_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8FB, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.multiFunOutDioE11_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xE8FB, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xE8FB, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal
    def pmalert(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 12, value)
        return(value)
    ## 11:9 - PG Select:<br>000 - 0<br>001 - PG0<br>010 - PG1<br>011 - PG0 && PG1<br>100 - PG2<br>101 - PG0 && PG2<br>110 - PG1 && PG2<br>111 - PG0 && PG1 && PG2
    def pwrg2Out(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 11, value)
        return(value)
    def pwrg1Out(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 10, value)
        return(value)
    def pwrg0Out(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xE8FB, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure multi-function input thresholds and enables
###################################################################
class dioInputCtrl_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 26

    def __call__(self, value = None):
        value = dma(self.address, 0xE8FC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dioInputCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8FC, None)
            self.svDetComparator = (self.reg_value >> 25) & 0x1
            self.dioe11PadIE = (self.reg_value >> 24) & 0x1
            self.dio10PadIE = (self.reg_value >> 23) & 0x1
            self.dio9PadIE = (self.reg_value >> 22) & 0x1
            self.dior8PadIE = (self.reg_value >> 21) & 0x1
            self.diopg7PadIE = (self.reg_value >> 20) & 0x1
            self.dio6PadIE = (self.reg_value >> 19) & 0x1
            self.dio5PadIE = (self.reg_value >> 18) & 0x1
            self.dioe4PadIE = (self.reg_value >> 17) & 0x1
            self.diopg3PadIE = (self.reg_value >> 16) & 0x1
            self.dioe2PadIE = (self.reg_value >> 15) & 0x1
            self.diopg1PadIE = (self.reg_value >> 14) & 0x1
            self.dio0PadIE = (self.reg_value >> 13) & 0x1
            self.diopg7outsel = (self.reg_value >> 12) & 0x1
            self.diopg3outsel = (self.reg_value >> 11) & 0x1
            self.diopg1outsel = (self.reg_value >> 10) & 0x1
            self.dior8outSel = (self.reg_value >> 9) & 0x1
            self.dioe11amdPwrOk = (self.reg_value >> 8) & 0x1
            self.dioe11intel = (self.reg_value >> 7) & 0x1
            self.dioe11svi3 = (self.reg_value >> 6) & 0x1
            self.dioe4amdPwrOk = (self.reg_value >> 5) & 0x1
            self.dioe4intel = (self.reg_value >> 4) & 0x1
            self.dioe4svi3 = (self.reg_value >> 3) & 0x1
            self.dioe2amdPwrOk = (self.reg_value >> 2) & 0x1
            self.dioe2intel = (self.reg_value >> 1) & 0x1
            self.dioe2svi3 = self.reg_value & 0x1

    def read_object(self):
        return(self.dioInputCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFF) + ((register_object.svDetComparator & 0x1) << 25)
        reg = (reg & 0x2FFFFFF) + ((register_object.dioe11PadIE & 0x1) << 24)
        reg = (reg & 0x37FFFFF) + ((register_object.dio10PadIE & 0x1) << 23)
        reg = (reg & 0x3BFFFFF) + ((register_object.dio9PadIE & 0x1) << 22)
        reg = (reg & 0x3DFFFFF) + ((register_object.dior8PadIE & 0x1) << 21)
        reg = (reg & 0x3EFFFFF) + ((register_object.diopg7PadIE & 0x1) << 20)
        reg = (reg & 0x3F7FFFF) + ((register_object.dio6PadIE & 0x1) << 19)
        reg = (reg & 0x3FBFFFF) + ((register_object.dio5PadIE & 0x1) << 18)
        reg = (reg & 0x3FDFFFF) + ((register_object.dioe4PadIE & 0x1) << 17)
        reg = (reg & 0x3FEFFFF) + ((register_object.diopg3PadIE & 0x1) << 16)
        reg = (reg & 0x3FF7FFF) + ((register_object.dioe2PadIE & 0x1) << 15)
        reg = (reg & 0x3FFBFFF) + ((register_object.diopg1PadIE & 0x1) << 14)
        reg = (reg & 0x3FFDFFF) + ((register_object.dio0PadIE & 0x1) << 13)
        reg = (reg & 0x3FFEFFF) + ((register_object.diopg7outsel & 0x1) << 12)
        reg = (reg & 0x3FFF7FF) + ((register_object.diopg3outsel & 0x1) << 11)
        reg = (reg & 0x3FFFBFF) + ((register_object.diopg1outsel & 0x1) << 10)
        reg = (reg & 0x3FFFDFF) + ((register_object.dior8outSel & 0x1) << 9)
        reg = (reg & 0x3FFFEFF) + ((register_object.dioe11amdPwrOk & 0x1) << 8)
        reg = (reg & 0x3FFFF7F) + ((register_object.dioe11intel & 0x1) << 7)
        reg = (reg & 0x3FFFFBF) + ((register_object.dioe11svi3 & 0x1) << 6)
        reg = (reg & 0x3FFFFDF) + ((register_object.dioe4amdPwrOk & 0x1) << 5)
        reg = (reg & 0x3FFFFEF) + ((register_object.dioe4intel & 0x1) << 4)
        reg = (reg & 0x3FFFFF7) + ((register_object.dioe4svi3 & 0x1) << 3)
        reg = (reg & 0x3FFFFFB) + ((register_object.dioe2amdPwrOk & 0x1) << 2)
        reg = (reg & 0x3FFFFFD) + ((register_object.dioe2intel & 0x1) << 1)
        reg = (reg & 0x3FFFFFE) + (register_object.dioe2svi3 & 0x1)
        dma(self.address, 0xE8FC, reg)
    ## Choose comparator for svDet pins. 0 for SVID levels - not used anymore
    def svDetComparator(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 25, value)
        return(value)
    ## Activate input receiver for DIOPG0
    def dioe11PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 24, value)
        return(value)
    ## Activate input receiver for DIO10
    def dio10PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 23, value)
        return(value)
    ## Activate input receiver for DIOER9
    def dio9PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 22, value)
        return(value)
    ## Activate input receiver for DIOR8
    def dior8PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 21, value)
        return(value)
    ## Activate input receiver for DIO7
    def diopg7PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 20, value)
        return(value)
    ## Activate input receiver for DIO6
    def dio6PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 19, value)
        return(value)
    ## Activate input receiver for DIOE5
    def dio5PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 18, value)
        return(value)
    ## Activate input receiver for DIOE4
    def dioe4PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 17, value)
        return(value)
    ## Activate input receiver for DIOE3
    def diopg3PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 16, value)
        return(value)
    ## Activate input receiver for DIO2
    def dioe2PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 15, value)
        return(value)
    ## Activate input receiver for DIO1
    def diopg1PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 14, value)
        return(value)
    ## Activate input receiver for DIO0
    def dio0PadIE(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 13, value)
        return(value)
    ## Select input receiver threshold for DIOPG7 - 0 Normal GPIO, 1 AUXVID
    def diopg7outsel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 12, value)
        return(value)
    ## Select input receiver threshold for DIOPG3 - 0 Normal GPIO, 1 AUXVID
    def diopg3outsel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 11, value)
        return(value)
    ## Select input receiver threshold for DIOPG1 - 0 Normal GPIO, 1 AUXVID
    def diopg1outsel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 10, value)
        return(value)
    ## Select threshold for DIOR8 receiver:  0=GPIO, 1=RESET_L
    def dior8outSel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 9, value)
        return(value)
    ## Select SVI2 PWROK threshold for DIOE5 receiver
    def dioe11amdPwrOk(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 8, value)
        return(value)
    ## Select SVID ENABLE threshold for DIOE5 receiver
    def dioe11intel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 7, value)
        return(value)
    ## Select SVI3 ENABLE threshold for DIOE5 receiver
    def dioe11svi3(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 6, value)
        return(value)
    ## Select SVI2 PWROK threshold for DIOE4 receiver
    def dioe4amdPwrOk(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 5, value)
        return(value)
    ## Select SVID ENABLE threshold for DIOE4 receiver
    def dioe4intel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 4, value)
        return(value)
    ## Select SVI3 ENABLE threshold for DIOE4 receiver
    def dioe4svi3(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 3, value)
        return(value)
    ## Select SVI2 PWROK threshold for DIOE3 receiver
    def dioe2amdPwrOk(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 2, value)
        return(value)
    ## Select SVID ENABLE threshold for DIOE3 receiver
    def dioe2intel(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 1, value)
        return(value)
    ## Select SVI3 ENABLE threshold for DIOE3 receiver
    def dioe2svi3(self, value = None):
        value = dma_bits(0xE8FC, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure multi-function output drive strength
###################################################################
class dioDriveCtrl_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xE8FD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dioDriveCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8FD, None)
            self.diopg7DS = (self.reg_value >> 8) & 0x1
            self.diopg3DS = (self.reg_value >> 7) & 0x1
            self.diopg1DS = (self.reg_value >> 6) & 0x1
            self.dio10DS = (self.reg_value >> 5) & 0x1
            self.dio9DS = (self.reg_value >> 4) & 0x1
            self.dior8DS = (self.reg_value >> 3) & 0x1
            self.dio6DS = (self.reg_value >> 2) & 0x1
            self.dio5DS = (self.reg_value >> 1) & 0x1
            self.dio0DS = self.reg_value & 0x1

    def read_object(self):
        return(self.dioDriveCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.diopg7DS & 0x1) << 8)
        reg = (reg & 0x17F) + ((register_object.diopg3DS & 0x1) << 7)
        reg = (reg & 0x1BF) + ((register_object.diopg1DS & 0x1) << 6)
        reg = (reg & 0x1DF) + ((register_object.dio10DS & 0x1) << 5)
        reg = (reg & 0x1EF) + ((register_object.dio9DS & 0x1) << 4)
        reg = (reg & 0x1F7) + ((register_object.dior8DS & 0x1) << 3)
        reg = (reg & 0x1FB) + ((register_object.dio6DS & 0x1) << 2)
        reg = (reg & 0x1FD) + ((register_object.dio5DS & 0x1) << 1)
        reg = (reg & 0x1FE) + (register_object.dio0DS & 0x1)
        dma(self.address, 0xE8FD, reg)
    ## Manage drive low strength for DIOPG7 pad: 0 - 4mA, 1 = 8mA
    def diopg7DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 8, value)
        return(value)
    ## Manage drive low strength for DIOPG3 pad: 0 - 4mA, 1 = 8mA
    def diopg3DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 7, value)
        return(value)
    ## Manage drive low strength for DIOPG1 pad: 0 - 4mA, 1 = 8mA
    def diopg1DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 6, value)
        return(value)
    ## Manage drive low strength for DIO10 pad: 0 - 8mA, 1 = 18mA
    def dio10DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 5, value)
        return(value)
    ## Manage drive low strength for DIO9 pad: 0 - 8mA, 1 = 18mA
    def dio9DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 4, value)
        return(value)
    ## Manage drive low strength for DIOR8 pad: 0 - 8mA, 1 = 18mA
    def dior8DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 3, value)
        return(value)
    ## Manage drive low strength for DIO6 pad: 0 - 8mA, 1 = 18mA
    def dio6DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 2, value)
        return(value)
    ## Manage drive low strength for DIO5 pad: 0 - 8mA, 1 = 18mA
    def dio5DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 1, value)
        return(value)
    ## Manage drive low strength for DIO0 pad: 0 - 8mA, 1 = 18mA
    def dio0DS(self, value = None):
        value = dma_bits(0xE8FD, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function source signals - RO
###################################################################
class multiFunOutSig_class(object):
    def __init__(self, address):
        self.interface = 'pinCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8FF, value)
        return(value)


###################################################################
## Fault control
###################################################################
class fltCtrl_class(object):
    def __init__(self, address):
        self.interface = 'fltCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE900, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class fltCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE900, None)
            self.fltTest = (self.reg_value >> 7) & 0x1
            self.fltIntEn = (self.reg_value >> 6) & 0x1
            self.lmsIntEn = (self.reg_value >> 5) & 0x1
            self.dbgFltClr = (self.reg_value >> 4) & 0x1
            self.srcLatEn = (self.reg_value >> 3) & 0x1
            self.ssEn = (self.reg_value >> 2) & 0x1
            self.ssWarnEn = (self.reg_value >> 1) & 0x1
            self.glbFltEn = self.reg_value & 0x1

    def read_object(self):
        return(self.fltCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.fltTest & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.fltIntEn & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.lmsIntEn & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.dbgFltClr & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.srcLatEn & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ssEn & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ssWarnEn & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.glbFltEn & 0x1)
        dma(self.address, 0xE900, reg)
    ## Fault test mode
    def fltTest(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 7, value)
        return(value)
    ## Fault interrupt enable
    def fltIntEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 6, value)
        return(value)
    ## LMS interrupt enable
    def lmsIntEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 5, value)
        return(value)
    ## Debug Fault Clear Latches on write of 1, must clear manually
    def dbgFltClr(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 4, value)
        return(value)
    ## Enable fault input source latches if 1, clear them if 0 -- used during system initialization
    def srcLatEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 3, value)
        return(value)
    ## Snap shot enable, capture data to RAM
    def ssEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 2, value)
        return(value)
    ## Backward compatibility bit for fault warnings. 1 - write BB on warning, 0 - no write on warning
    def ssWarnEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 1, value)
        return(value)
    ## Global fault enable 0=report fault only 1=enable shutdown and CFP
    def glbFltEn(self, value = None):
        value = dma_bits(0xE900, self.address, 1, 0, value)
        return(value)

###################################################################
## Vcc33 telemetry undervoltage fault control
###################################################################
class vccUvFltCtrl_class(object):
    def __init__(self, address):
        self.interface = 'fltCfg'
        self.address = address
        self.bits = 21

    def __call__(self, value = None):
        value = dma(self.address, 0xE901, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vccUvFltCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE901, None)
            self.vccUvHyst = (self.reg_value >> 15) & 0x3F
            self.vinLowPwrEn = (self.reg_value >> 14) & 0x1
            self.vccUvUseFilt = (self.reg_value >> 13) & 0x1
            self.vccUvFltEn = (self.reg_value >> 12) & 0x1
            self.vccUvFltLmt = self.reg_value & 0xFFF

    def read_object(self):
        return(self.vccUvFltCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.vccUvHyst & 0x3F) << 15)
        reg = (reg & 0x1FBFFF) + ((register_object.vinLowPwrEn & 0x1) << 14)
        reg = (reg & 0x1FDFFF) + ((register_object.vccUvUseFilt & 0x1) << 13)
        reg = (reg & 0x1FEFFF) + ((register_object.vccUvFltEn & 0x1) << 12)
        reg = (reg & 0x1FF000) + (register_object.vccUvFltLmt & 0xFFF)
        dma(self.address, 0xE901, reg)
    ## hysteresis for vccUv to be X/2048
    def vccUvHyst(self, value = None):
        value = dma_bits(0xE901, self.address, 6, 15, value)
        return(value)
    ## VIN low power mode enable
    def vinLowPwrEn(self, value = None):
        value = dma_bits(0xE901, self.address, 1, 14, value)
        return(value)
    ## Select filtered=1 or raw=0 TELVCC value
    def vccUvUseFilt(self, value = None):
        value = dma_bits(0xE901, self.address, 1, 13, value)
        return(value)
    ## Enable Vcc33 telemetry undervoltage fault checking
    def vccUvFltEn(self, value = None):
        value = dma_bits(0xE901, self.address, 1, 12, value)
        return(value)
    ## Vcc33 telemetry undervoltage fault limit
    def vccUvFltLmt(self, value = None):
        value = dma_bits(0xE901, self.address, 12, 0, value)
        return(value)

###################################################################
## Select Isen pins for open pin fault
###################################################################
class pinOpnEnableA_class(object):
    def __init__(self, address):
        self.interface = 'fltCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE902, value)
        return(value)


###################################################################
## Select Vsen pins for open pin fault
###################################################################
class pinOpnEnableB_class(object):
    def __init__(self, address):
        self.interface = 'fltCfg'
        self.address = address
        self.bits = 6

    def __call__(self, value = None):
        value = dma(self.address, 0xE903, value)
        return(value)


###################################################################
## Vdd1p8 telemetry undervoltage fault control
###################################################################
class vdd1p8FltCtrl_class(object):
    def __init__(self, address):
        self.interface = 'fltCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE904, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vdd1p8FltCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE904, None)
            self.vdd1p8Hyst = (self.reg_value >> 26) & 0x3F
            self.vdd1p8UseFilt = (self.reg_value >> 25) & 0x1
            self.vdd1p8FltEn = (self.reg_value >> 24) & 0x1
            self.vdd1p8UvFltLmt = (self.reg_value >> 12) & 0xFFF
            self.vdd1p8OvFltLmt = self.reg_value & 0xFFF

    def read_object(self):
        return(self.vdd1p8FltCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFF) + ((register_object.vdd1p8Hyst & 0x3F) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.vdd1p8UseFilt & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.vdd1p8FltEn & 0x1) << 24)
        reg = (reg & 0xFF000FFF) + ((register_object.vdd1p8UvFltLmt & 0xFFF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.vdd1p8OvFltLmt & 0xFFF)
        dma(self.address, 0xE904, reg)
    ## hysteresis for vdd1p8Uv
    def vdd1p8Hyst(self, value = None):
        value = dma_bits(0xE904, self.address, 6, 26, value)
        return(value)
    ## Select filtered=1 or raw=0 TELVDD1p8 value
    def vdd1p8UseFilt(self, value = None):
        value = dma_bits(0xE904, self.address, 1, 25, value)
        return(value)
    ## Enable Vdd1p8 telemetry under voltage fault checking
    def vdd1p8FltEn(self, value = None):
        value = dma_bits(0xE904, self.address, 1, 24, value)
        return(value)
    ## Vdd1p8 telemetry undervoltage fault limit
    def vdd1p8UvFltLmt(self, value = None):
        value = dma_bits(0xE904, self.address, 12, 12, value)
        return(value)
    ## Vdd1p8 telemetry undervoltage fault limit
    def vdd1p8OvFltLmt(self, value = None):
        value = dma_bits(0xE904, self.address, 12, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Controller A - RW  (see rUSRCTRLFLTEN for user config store)
###################################################################
class ctrlFltEnA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE910, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltEnA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE910, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltEnA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.pinOpen & 0x1) << 23)
        reg = (reg & 0xBFFFFF) + ((register_object.mcuDead & 0x1) << 22)
        reg = (reg & 0xDFFFFF) + ((register_object.pInAlert & 0x1) << 21)
        reg = (reg & 0xEFFFFF) + ((register_object.external & 0x1) << 20)
        reg = (reg & 0xF7FFFF) + ((register_object.tmonFlt2 & 0x1) << 19)
        reg = (reg & 0xFBFFFF) + ((register_object.underTempFlt2 & 0x1) << 18)
        reg = (reg & 0xFDFFFF) + ((register_object.overTempFlt2 & 0x1) << 17)
        reg = (reg & 0xFEFFFF) + ((register_object.tmonFlt1 & 0x1) << 16)
        reg = (reg & 0xFF7FFF) + ((register_object.underTempFlt1 & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.overTempFlt1 & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.tmonFlt0 & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.underTempFlt0 & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.overTempFlt0 & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.configLoad & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.diagFault & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.watchdog & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.intTemp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.vdd1p8OvTelFlt & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.avdd18ValidSyncZ & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.vdd1p8UvTelFlt & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.vddioUV & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.vdd12ValidZ & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.vdd33Brownout & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.vdd33ValidZ & 0x1)
        dma(self.address, 0xE910, reg)
    ## 23 - Open pin detected fault
    def pinOpen(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 23, value)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 22, value)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 21, value)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 20, value)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 19, value)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 18, value)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 17, value)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 16, value)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 15, value)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 14, value)
        return(value)
    ## 13 - SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 13, value)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 12, value)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 11, value)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 10, value)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 9, value)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 8, value)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 7, value)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 6, value)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 5, value)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 4, value)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 3, value)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 2, value)
        return(value)
    ## 1 - VCC supply brown out, from telemetry
    def vdd33Brownout(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 1, value)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self, value = None):
        value = dma_bits(0xE910, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Controller B - RW  (see rUSRCTRLFLTEN for user config store)
###################################################################
class ctrlFltEnB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE911, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltEnB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE911, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltEnB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.adcClkUnlockT & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.adcClkUnlockI & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.adcClkUnlockV & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.psysWarn2 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.psysWarn1 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.psysCrit & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.iinSense1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.iinSense0 & 0x1)
        dma(self.address, 0xE911, reg)
    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 7, value)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 6, value)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 5, value)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 4, value)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 3, value)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 2, value)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 1, value)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self, value = None):
        value = dma_bits(0xE911, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Rail 0 - RW
###################################################################
class railFltEn0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE912, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltEn0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE912, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltEn0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE912, reg)
    ## Spare fault 0
    def spareFlt(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 0
    def iinSupply(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 20, value)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 0
    def inputOCF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 0
    def outputUTW(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 0
    def outputUTF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 0
    def outputOTW(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 0
    def outputOTF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 0
    def inputOCW(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 0
    def outputOPF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE912, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Rail 1 - RW
###################################################################
class railFltEn1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE913, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltEn1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE913, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltEn1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE913, reg)
    ## Spare fault 1
    def spareFlt(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 1
    def iinSupply(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 20, value)
        return(value)
    ## SPS TMON1 fault signal on TEMP1
    def tmonFlt(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 1
    def inputOCF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 1
    def inputOCW(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 1
    def outputOPF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE913, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Rail 2 - RW
###################################################################
class railFltEn2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE914, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltEn2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE914, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltEn2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE914, reg)
    ## Spare fault 2
    def spareFlt(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 2
    def iinSupply(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 20, value)
        return(value)
    ## SPS TMON1 fault signal on TEMP2
    def tmonFlt(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 2
    def inputOCF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 2
    def inputOCW(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 2
    def outputOPF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE914, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Phase PeakUcFaults - RW
###################################################################
class phPeakUcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE915, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakUcFltEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE915, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakUcFltEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE915, reg)
    ## Peak negative undercurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 7, value)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 6, value)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 5, value)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 4, value)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 3, value)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 2, value)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 1, value)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE915, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Phase PeakOcFaults - RW
###################################################################
class phPeakOcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE916, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakOcFltEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE916, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakOcFltEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE916, reg)
    ## Peak negative overcurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 7, value)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 6, value)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 5, value)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 4, value)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 3, value)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 2, value)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 1, value)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE916, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Phase Current sense ADC under-current - RW
###################################################################
class phAdcUcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE917, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcUcFltEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE917, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcUcFltEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE917, reg)
    ## Current sense ADC undercurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 7, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 6, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 5, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 4, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 3, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 2, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 1, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE917, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Phase Current sense ADC over-current - RW
###################################################################
class phAdcOcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE918, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcOcFltEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE918, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcOcFltEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE918, reg)
    ## Current sense ADC over-current fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 7, value)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 6, value)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 5, value)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 4, value)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 3, value)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 2, value)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 1, value)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE918, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Enable Per-Phase Synthesizer current mistracking versus sensed - RW
###################################################################
class phiEstFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE919, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phiEstFltEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE919, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phiEstFltEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE919, reg)
    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 7, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 6, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 5, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 4, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 3, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 2, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 1, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE919, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Source Per-Controller A - RO
###################################################################
class ctrlFltSrcA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE920, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltSrcA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE920, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltSrcA_Object(self.address))

    ## 23 - Open pin detected fault
    def pinOpen(self):
        value = dma_bits(0xE920, self.address, 1, 23, None)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self):
        value = dma_bits(0xE920, self.address, 1, 22, None)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self):
        value = dma_bits(0xE920, self.address, 1, 21, None)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self):
        value = dma_bits(0xE920, self.address, 1, 20, None)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self):
        value = dma_bits(0xE920, self.address, 1, 19, None)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self):
        value = dma_bits(0xE920, self.address, 1, 18, None)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self):
        value = dma_bits(0xE920, self.address, 1, 17, None)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self):
        value = dma_bits(0xE920, self.address, 1, 16, None)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self):
        value = dma_bits(0xE920, self.address, 1, 15, None)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self):
        value = dma_bits(0xE920, self.address, 1, 14, None)
        return(value)
    ## 13 - SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self):
        value = dma_bits(0xE920, self.address, 1, 13, None)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self):
        value = dma_bits(0xE920, self.address, 1, 12, None)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self):
        value = dma_bits(0xE920, self.address, 1, 11, None)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self):
        value = dma_bits(0xE920, self.address, 1, 10, None)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self):
        value = dma_bits(0xE920, self.address, 1, 9, None)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self):
        value = dma_bits(0xE920, self.address, 1, 8, None)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self):
        value = dma_bits(0xE920, self.address, 1, 7, None)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self):
        value = dma_bits(0xE920, self.address, 1, 6, None)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self):
        value = dma_bits(0xE920, self.address, 1, 5, None)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self):
        value = dma_bits(0xE920, self.address, 1, 4, None)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self):
        value = dma_bits(0xE920, self.address, 1, 3, None)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self):
        value = dma_bits(0xE920, self.address, 1, 2, None)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self):
        value = dma_bits(0xE920, self.address, 1, 1, None)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self):
        value = dma_bits(0xE920, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Controller B - RO
###################################################################
class ctrlFltSrcB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE921, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltSrcB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE921, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltSrcB_Object(self.address))

    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self):
        value = dma_bits(0xE921, self.address, 1, 7, None)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self):
        value = dma_bits(0xE921, self.address, 1, 6, None)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self):
        value = dma_bits(0xE921, self.address, 1, 5, None)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self):
        value = dma_bits(0xE921, self.address, 1, 4, None)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self):
        value = dma_bits(0xE921, self.address, 1, 3, None)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self):
        value = dma_bits(0xE921, self.address, 1, 2, None)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self):
        value = dma_bits(0xE921, self.address, 1, 1, None)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self):
        value = dma_bits(0xE921, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Rail 0 - RO
###################################################################
class railFltSrc0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE922, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltSrc0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE922, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltSrc0_Object(self.address))

    ## Spare fault 0
    def spareFlt(self):
        value = dma_bits(0xE922, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 0
    def iinSupply(self):
        value = dma_bits(0xE922, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout(self):
        value = dma_bits(0xE922, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt(self):
        value = dma_bits(0xE922, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault(self):
        value = dma_bits(0xE922, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault(self):
        value = dma_bits(0xE922, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn(self):
        value = dma_bits(0xE922, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault(self):
        value = dma_bits(0xE922, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault(self):
        value = dma_bits(0xE922, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect(self):
        value = dma_bits(0xE922, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect(self):
        value = dma_bits(0xE922, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault(self):
        value = dma_bits(0xE922, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 0
    def inputOCF(self):
        value = dma_bits(0xE922, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 0
    def outputUTW(self):
        value = dma_bits(0xE922, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 0
    def outputUTF(self):
        value = dma_bits(0xE922, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 0
    def outputOTW(self):
        value = dma_bits(0xE922, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 0
    def outputOTF(self):
        value = dma_bits(0xE922, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 0
    def inputOCW(self):
        value = dma_bits(0xE922, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 0
    def outputOPF(self):
        value = dma_bits(0xE922, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW(self):
        value = dma_bits(0xE922, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW(self):
        value = dma_bits(0xE922, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF(self):
        value = dma_bits(0xE922, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF(self):
        value = dma_bits(0xE922, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Rail 1 - RO
###################################################################
class railFltSrc1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE923, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltSrc1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE923, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltSrc1_Object(self.address))

    ## Spare fault 1
    def spareFlt(self):
        value = dma_bits(0xE923, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 1
    def iinSupply(self):
        value = dma_bits(0xE923, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self):
        value = dma_bits(0xE923, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP1
    def tmonFlt(self):
        value = dma_bits(0xE923, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self):
        value = dma_bits(0xE923, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self):
        value = dma_bits(0xE923, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self):
        value = dma_bits(0xE923, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self):
        value = dma_bits(0xE923, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self):
        value = dma_bits(0xE923, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self):
        value = dma_bits(0xE923, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self):
        value = dma_bits(0xE923, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self):
        value = dma_bits(0xE923, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 1
    def inputOCF(self):
        value = dma_bits(0xE923, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self):
        value = dma_bits(0xE923, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self):
        value = dma_bits(0xE923, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self):
        value = dma_bits(0xE923, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self):
        value = dma_bits(0xE923, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 1
    def inputOCW(self):
        value = dma_bits(0xE923, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 1
    def outputOPF(self):
        value = dma_bits(0xE923, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self):
        value = dma_bits(0xE923, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self):
        value = dma_bits(0xE923, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self):
        value = dma_bits(0xE923, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self):
        value = dma_bits(0xE923, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Rail 2 - RO
###################################################################
class railFltSrc2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE924, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltSrc2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE924, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltSrc2_Object(self.address))

    ## Spare fault 2
    def spareFlt(self):
        value = dma_bits(0xE924, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 2
    def iinSupply(self):
        value = dma_bits(0xE924, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self):
        value = dma_bits(0xE924, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP2
    def tmonFlt(self):
        value = dma_bits(0xE924, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self):
        value = dma_bits(0xE924, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self):
        value = dma_bits(0xE924, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self):
        value = dma_bits(0xE924, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self):
        value = dma_bits(0xE924, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self):
        value = dma_bits(0xE924, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self):
        value = dma_bits(0xE924, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self):
        value = dma_bits(0xE924, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self):
        value = dma_bits(0xE924, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 2
    def inputOCF(self):
        value = dma_bits(0xE924, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self):
        value = dma_bits(0xE924, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self):
        value = dma_bits(0xE924, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self):
        value = dma_bits(0xE924, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self):
        value = dma_bits(0xE924, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 2
    def inputOCW(self):
        value = dma_bits(0xE924, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 2
    def outputOPF(self):
        value = dma_bits(0xE924, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self):
        value = dma_bits(0xE924, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self):
        value = dma_bits(0xE924, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self):
        value = dma_bits(0xE924, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self):
        value = dma_bits(0xE924, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase PeakUcFaults - RO
###################################################################
class phPeakUcFltSrc_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE925, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakUcFltSrc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE925, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakUcFltSrc_Object(self.address))

    ## Peak negative undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE925, self.address, 1, 7, None)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE925, self.address, 1, 6, None)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE925, self.address, 1, 5, None)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE925, self.address, 1, 4, None)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE925, self.address, 1, 3, None)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE925, self.address, 1, 2, None)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE925, self.address, 1, 1, None)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE925, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase PeakOcFaults - RO
###################################################################
class phPeakOcFltSrc_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE926, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakOcFltSrc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE926, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakOcFltSrc_Object(self.address))

    ## Peak negative overcurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE926, self.address, 1, 7, None)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE926, self.address, 1, 6, None)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE926, self.address, 1, 5, None)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE926, self.address, 1, 4, None)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE926, self.address, 1, 3, None)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE926, self.address, 1, 2, None)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE926, self.address, 1, 1, None)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE926, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase ADC under-current - RO
###################################################################
class phAdcUcFltSrc_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE927, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcUcFltSrc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE927, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcUcFltSrc_Object(self.address))

    ## Current sense ADC undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE927, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE927, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE927, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE927, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE927, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE927, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE927, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE927, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase ADC over-current  - RO
###################################################################
class phAdcOcFltSrc_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE928, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcOcFltSrc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE928, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcOcFltSrc_Object(self.address))

    ## Current sense ADC over-current fault phase 7
    def ph7(self):
        value = dma_bits(0xE928, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self):
        value = dma_bits(0xE928, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self):
        value = dma_bits(0xE928, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self):
        value = dma_bits(0xE928, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self):
        value = dma_bits(0xE928, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self):
        value = dma_bits(0xE928, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self):
        value = dma_bits(0xE928, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self):
        value = dma_bits(0xE928, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase Synthesizer current mistracking versus sensed - RO
###################################################################
class phiEstFltSrc_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE929, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phiEstFltSrc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE929, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phiEstFltSrc_Object(self.address))

    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self):
        value = dma_bits(0xE929, self.address, 1, 7, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self):
        value = dma_bits(0xE929, self.address, 1, 6, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self):
        value = dma_bits(0xE929, self.address, 1, 5, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self):
        value = dma_bits(0xE929, self.address, 1, 4, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self):
        value = dma_bits(0xE929, self.address, 1, 3, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self):
        value = dma_bits(0xE929, self.address, 1, 2, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self):
        value = dma_bits(0xE929, self.address, 1, 1, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self):
        value = dma_bits(0xE929, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Controller A - ROWC
###################################################################
class ctrlFltRegA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE930, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltRegA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE930, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltRegA_Object(self.address))

    ## 23 - Open pin detected fault
    def pinOpen(self):
        value = dma_bits(0xE930, self.address, 1, 23, None)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self):
        value = dma_bits(0xE930, self.address, 1, 22, None)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self):
        value = dma_bits(0xE930, self.address, 1, 21, None)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self):
        value = dma_bits(0xE930, self.address, 1, 20, None)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self):
        value = dma_bits(0xE930, self.address, 1, 19, None)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self):
        value = dma_bits(0xE930, self.address, 1, 18, None)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self):
        value = dma_bits(0xE930, self.address, 1, 17, None)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self):
        value = dma_bits(0xE930, self.address, 1, 16, None)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self):
        value = dma_bits(0xE930, self.address, 1, 15, None)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self):
        value = dma_bits(0xE930, self.address, 1, 14, None)
        return(value)
    ## 13 - SPctrlFltRegAlt signal on TEMP0
    def tmonFlt0(self):
        value = dma_bits(0xE930, self.address, 1, 13, None)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self):
        value = dma_bits(0xE930, self.address, 1, 12, None)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self):
        value = dma_bits(0xE930, self.address, 1, 11, None)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self):
        value = dma_bits(0xE930, self.address, 1, 10, None)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self):
        value = dma_bits(0xE930, self.address, 1, 9, None)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self):
        value = dma_bits(0xE930, self.address, 1, 8, None)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self):
        value = dma_bits(0xE930, self.address, 1, 7, None)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self):
        value = dma_bits(0xE930, self.address, 1, 6, None)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self):
        value = dma_bits(0xE930, self.address, 1, 5, None)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self):
        value = dma_bits(0xE930, self.address, 1, 4, None)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self):
        value = dma_bits(0xE930, self.address, 1, 3, None)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self):
        value = dma_bits(0xE930, self.address, 1, 2, None)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self):
        value = dma_bits(0xE930, self.address, 1, 1, None)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self):
        value = dma_bits(0xE930, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Controller B - ROWC
###################################################################
class ctrlFltRegB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE931, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltRegB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE931, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltRegB_Object(self.address))

    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self):
        value = dma_bits(0xE931, self.address, 1, 7, None)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self):
        value = dma_bits(0xE931, self.address, 1, 6, None)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self):
        value = dma_bits(0xE931, self.address, 1, 5, None)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self):
        value = dma_bits(0xE931, self.address, 1, 4, None)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self):
        value = dma_bits(0xE931, self.address, 1, 3, None)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self):
        value = dma_bits(0xE931, self.address, 1, 2, None)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self):
        value = dma_bits(0xE931, self.address, 1, 1, None)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self):
        value = dma_bits(0xE931, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Rail 0 - ROWC
###################################################################
class railFltReg0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE932, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltReg0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE932, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltReg0_Object(self.address))

    ## Spare fault 0
    def spareFlt(self):
        value = dma_bits(0xE932, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 0
    def iinSupply(self):
        value = dma_bits(0xE932, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout(self):
        value = dma_bits(0xE932, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt(self):
        value = dma_bits(0xE932, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault(self):
        value = dma_bits(0xE932, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault(self):
        value = dma_bits(0xE932, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn(self):
        value = dma_bits(0xE932, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault(self):
        value = dma_bits(0xE932, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault(self):
        value = dma_bits(0xE932, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect(self):
        value = dma_bits(0xE932, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect(self):
        value = dma_bits(0xE932, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault(self):
        value = dma_bits(0xE932, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 0
    def inputOCF(self):
        value = dma_bits(0xE932, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 0
    def outputUTW(self):
        value = dma_bits(0xE932, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 0
    def outputUTF(self):
        value = dma_bits(0xE932, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 0
    def outputOTW(self):
        value = dma_bits(0xE932, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 0
    def outputOTF(self):
        value = dma_bits(0xE932, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 0
    def inputOCW(self):
        value = dma_bits(0xE932, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 0
    def outputOPF(self):
        value = dma_bits(0xE932, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW(self):
        value = dma_bits(0xE932, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW(self):
        value = dma_bits(0xE932, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF(self):
        value = dma_bits(0xE932, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF(self):
        value = dma_bits(0xE932, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Rail 1 - ROWC
###################################################################
class railFltReg1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE933, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltReg1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE933, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltReg1_Object(self.address))

    ## Spare fault 1
    def spareFlt(self):
        value = dma_bits(0xE933, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 1
    def iinSupply(self):
        value = dma_bits(0xE933, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self):
        value = dma_bits(0xE933, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP1
    def tmonFlt(self):
        value = dma_bits(0xE933, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self):
        value = dma_bits(0xE933, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self):
        value = dma_bits(0xE933, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self):
        value = dma_bits(0xE933, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self):
        value = dma_bits(0xE933, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self):
        value = dma_bits(0xE933, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self):
        value = dma_bits(0xE933, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self):
        value = dma_bits(0xE933, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self):
        value = dma_bits(0xE933, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 1
    def inputOCF(self):
        value = dma_bits(0xE933, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self):
        value = dma_bits(0xE933, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self):
        value = dma_bits(0xE933, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self):
        value = dma_bits(0xE933, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self):
        value = dma_bits(0xE933, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 1
    def inputOCW(self):
        value = dma_bits(0xE933, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 1
    def outputOPF(self):
        value = dma_bits(0xE933, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self):
        value = dma_bits(0xE933, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self):
        value = dma_bits(0xE933, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self):
        value = dma_bits(0xE933, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self):
        value = dma_bits(0xE933, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Rail 2 - ROWC
###################################################################
class railFltReg2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE934, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltReg2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE934, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltReg2_Object(self.address))

    ## Spare fault 2
    def spareFlt(self):
        value = dma_bits(0xE934, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 2
    def iinSupply(self):
        value = dma_bits(0xE934, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self):
        value = dma_bits(0xE934, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP2
    def tmonFlt(self):
        value = dma_bits(0xE934, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self):
        value = dma_bits(0xE934, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self):
        value = dma_bits(0xE934, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self):
        value = dma_bits(0xE934, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self):
        value = dma_bits(0xE934, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self):
        value = dma_bits(0xE934, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self):
        value = dma_bits(0xE934, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self):
        value = dma_bits(0xE934, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self):
        value = dma_bits(0xE934, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 2
    def inputOCF(self):
        value = dma_bits(0xE934, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self):
        value = dma_bits(0xE934, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self):
        value = dma_bits(0xE934, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self):
        value = dma_bits(0xE934, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self):
        value = dma_bits(0xE934, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 2
    def inputOCW(self):
        value = dma_bits(0xE934, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 2
    def outputOPF(self):
        value = dma_bits(0xE934, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self):
        value = dma_bits(0xE934, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self):
        value = dma_bits(0xE934, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self):
        value = dma_bits(0xE934, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self):
        value = dma_bits(0xE934, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Phase PeakUcFaults - ROWC
###################################################################
class phPeakUcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE935, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakUcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE935, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakUcFltReg_Object(self.address))

    ## Peak negative undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE935, self.address, 1, 7, None)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE935, self.address, 1, 6, None)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE935, self.address, 1, 5, None)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE935, self.address, 1, 4, None)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE935, self.address, 1, 3, None)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE935, self.address, 1, 2, None)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE935, self.address, 1, 1, None)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE935, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Phase PeakOcFaults - ROWC
###################################################################
class phPeakOcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE936, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakOcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE936, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakOcFltReg_Object(self.address))

    ## Peak negative overcurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE936, self.address, 1, 7, None)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE936, self.address, 1, 6, None)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE936, self.address, 1, 5, None)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE936, self.address, 1, 4, None)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE936, self.address, 1, 3, None)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE936, self.address, 1, 2, None)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE936, self.address, 1, 1, None)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE936, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Latch Per-Phase ADC under-current - ROWC
###################################################################
class phAdcUcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE937, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcUcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE937, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcUcFltReg_Object(self.address))

    ## Current sense ADC undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE937, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE937, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE937, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE937, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE937, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE937, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE937, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE937, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase ADC over-current  - ROWC
###################################################################
class phAdcOcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE938, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcOcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE938, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcOcFltReg_Object(self.address))

    ## Current sense ADC over-current fault phase 7
    def ph7(self):
        value = dma_bits(0xE938, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self):
        value = dma_bits(0xE938, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self):
        value = dma_bits(0xE938, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self):
        value = dma_bits(0xE938, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self):
        value = dma_bits(0xE938, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self):
        value = dma_bits(0xE938, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self):
        value = dma_bits(0xE938, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self):
        value = dma_bits(0xE938, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Source Per-Phase Synthesizer current mistracking versus sensed - ROWC
###################################################################
class phiEstFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE939, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phiEstFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE939, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phiEstFltReg_Object(self.address))

    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self):
        value = dma_bits(0xE939, self.address, 1, 7, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self):
        value = dma_bits(0xE939, self.address, 1, 6, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self):
        value = dma_bits(0xE939, self.address, 1, 5, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self):
        value = dma_bits(0xE939, self.address, 1, 4, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self):
        value = dma_bits(0xE939, self.address, 1, 3, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self):
        value = dma_bits(0xE939, self.address, 1, 2, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self):
        value = dma_bits(0xE939, self.address, 1, 1, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self):
        value = dma_bits(0xE939, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Controller A - RO
###################################################################
class ctrlFltStatA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE940, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltStatA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE940, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltStatA_Object(self.address))

    ## 23 - Open pin detected fault
    def pinOpen(self):
        value = dma_bits(0xE940, self.address, 1, 23, None)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self):
        value = dma_bits(0xE940, self.address, 1, 22, None)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self):
        value = dma_bits(0xE940, self.address, 1, 21, None)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self):
        value = dma_bits(0xE940, self.address, 1, 20, None)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self):
        value = dma_bits(0xE940, self.address, 1, 19, None)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self):
        value = dma_bits(0xE940, self.address, 1, 18, None)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self):
        value = dma_bits(0xE940, self.address, 1, 17, None)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self):
        value = dma_bits(0xE940, self.address, 1, 16, None)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self):
        value = dma_bits(0xE940, self.address, 1, 15, None)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self):
        value = dma_bits(0xE940, self.address, 1, 14, None)
        return(value)
    ## 13 - SPctrlFltStatAlt signal on TEMP0
    def tmonFlt0(self):
        value = dma_bits(0xE940, self.address, 1, 13, None)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self):
        value = dma_bits(0xE940, self.address, 1, 12, None)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self):
        value = dma_bits(0xE940, self.address, 1, 11, None)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self):
        value = dma_bits(0xE940, self.address, 1, 10, None)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self):
        value = dma_bits(0xE940, self.address, 1, 9, None)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self):
        value = dma_bits(0xE940, self.address, 1, 8, None)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self):
        value = dma_bits(0xE940, self.address, 1, 7, None)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self):
        value = dma_bits(0xE940, self.address, 1, 6, None)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self):
        value = dma_bits(0xE940, self.address, 1, 5, None)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self):
        value = dma_bits(0xE940, self.address, 1, 4, None)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self):
        value = dma_bits(0xE940, self.address, 1, 3, None)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self):
        value = dma_bits(0xE940, self.address, 1, 2, None)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self):
        value = dma_bits(0xE940, self.address, 1, 1, None)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self):
        value = dma_bits(0xE940, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Controller B - RO
###################################################################
class ctrlFltStatB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE941, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltStatB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE941, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltStatB_Object(self.address))

    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self):
        value = dma_bits(0xE941, self.address, 1, 7, None)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self):
        value = dma_bits(0xE941, self.address, 1, 6, None)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self):
        value = dma_bits(0xE941, self.address, 1, 5, None)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self):
        value = dma_bits(0xE941, self.address, 1, 4, None)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self):
        value = dma_bits(0xE941, self.address, 1, 3, None)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self):
        value = dma_bits(0xE941, self.address, 1, 2, None)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self):
        value = dma_bits(0xE941, self.address, 1, 1, None)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self):
        value = dma_bits(0xE941, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Rail 0 - RO
###################################################################
class railFltStat0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE942, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltStat0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE942, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltStat0_Object(self.address))

    ## Spare fault 0
    def spareFlt(self):
        value = dma_bits(0xE942, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 0
    def iinSupply(self):
        value = dma_bits(0xE942, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout(self):
        value = dma_bits(0xE942, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt(self):
        value = dma_bits(0xE942, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault(self):
        value = dma_bits(0xE942, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault(self):
        value = dma_bits(0xE942, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn(self):
        value = dma_bits(0xE942, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault(self):
        value = dma_bits(0xE942, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault(self):
        value = dma_bits(0xE942, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect(self):
        value = dma_bits(0xE942, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect(self):
        value = dma_bits(0xE942, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault(self):
        value = dma_bits(0xE942, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 0
    def inputOCF(self):
        value = dma_bits(0xE942, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 0
    def outputUTW(self):
        value = dma_bits(0xE942, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 0
    def outputUTF(self):
        value = dma_bits(0xE942, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 0
    def outputOTW(self):
        value = dma_bits(0xE942, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 0
    def outputOTF(self):
        value = dma_bits(0xE942, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 0
    def inputOCW(self):
        value = dma_bits(0xE942, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 0
    def outputOPF(self):
        value = dma_bits(0xE942, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW(self):
        value = dma_bits(0xE942, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW(self):
        value = dma_bits(0xE942, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF(self):
        value = dma_bits(0xE942, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF(self):
        value = dma_bits(0xE942, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Rail 1 - RO
###################################################################
class railFltStat1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE943, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltStat1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE943, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltStat1_Object(self.address))

    ## Spare fault 1
    def spareFlt(self):
        value = dma_bits(0xE943, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 1
    def iinSupply(self):
        value = dma_bits(0xE943, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self):
        value = dma_bits(0xE943, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP1
    def tmonFlt(self):
        value = dma_bits(0xE943, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self):
        value = dma_bits(0xE943, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self):
        value = dma_bits(0xE943, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self):
        value = dma_bits(0xE943, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self):
        value = dma_bits(0xE943, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self):
        value = dma_bits(0xE943, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self):
        value = dma_bits(0xE943, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self):
        value = dma_bits(0xE943, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self):
        value = dma_bits(0xE943, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 1
    def inputOCF(self):
        value = dma_bits(0xE943, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self):
        value = dma_bits(0xE943, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self):
        value = dma_bits(0xE943, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self):
        value = dma_bits(0xE943, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self):
        value = dma_bits(0xE943, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 1
    def inputOCW(self):
        value = dma_bits(0xE943, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 1
    def outputOPF(self):
        value = dma_bits(0xE943, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self):
        value = dma_bits(0xE943, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self):
        value = dma_bits(0xE943, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self):
        value = dma_bits(0xE943, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self):
        value = dma_bits(0xE943, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Rail 2 - RO
###################################################################
class railFltStat2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE944, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltStat2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE944, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltStat2_Object(self.address))

    ## Spare fault 2
    def spareFlt(self):
        value = dma_bits(0xE944, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 2
    def iinSupply(self):
        value = dma_bits(0xE944, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self):
        value = dma_bits(0xE944, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP2
    def tmonFlt(self):
        value = dma_bits(0xE944, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self):
        value = dma_bits(0xE944, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self):
        value = dma_bits(0xE944, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self):
        value = dma_bits(0xE944, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self):
        value = dma_bits(0xE944, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self):
        value = dma_bits(0xE944, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self):
        value = dma_bits(0xE944, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self):
        value = dma_bits(0xE944, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self):
        value = dma_bits(0xE944, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 2
    def inputOCF(self):
        value = dma_bits(0xE944, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self):
        value = dma_bits(0xE944, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self):
        value = dma_bits(0xE944, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self):
        value = dma_bits(0xE944, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self):
        value = dma_bits(0xE944, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 2
    def inputOCW(self):
        value = dma_bits(0xE944, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 2
    def outputOPF(self):
        value = dma_bits(0xE944, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self):
        value = dma_bits(0xE944, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self):
        value = dma_bits(0xE944, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self):
        value = dma_bits(0xE944, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self):
        value = dma_bits(0xE944, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Phase PeakUcFaults - RO
###################################################################
class phPeakUcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE945, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakUcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE945, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakUcFltStat_Object(self.address))

    ## Peak negative undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE945, self.address, 1, 7, None)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE945, self.address, 1, 6, None)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE945, self.address, 1, 5, None)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE945, self.address, 1, 4, None)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE945, self.address, 1, 3, None)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE945, self.address, 1, 2, None)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE945, self.address, 1, 1, None)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE945, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Status Per-Phase PeakOcFaults - RO
###################################################################
class phPeakOcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE946, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakOcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE946, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakOcFltStat_Object(self.address))

    ## Peak negative overcurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE946, self.address, 1, 7, None)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE946, self.address, 1, 6, None)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE946, self.address, 1, 5, None)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE946, self.address, 1, 4, None)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE946, self.address, 1, 3, None)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE946, self.address, 1, 2, None)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE946, self.address, 1, 1, None)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE946, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Stat Per-Phase ADC under-current - RO
###################################################################
class phAdcUcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE947, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcUcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE947, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcUcFltStat_Object(self.address))

    ## Current sense ADC undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE947, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE947, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE947, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE947, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE947, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE947, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE947, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE947, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Stat Per-Phase ADC over-current  - RO
###################################################################
class phAdcOcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE948, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcOcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE948, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcOcFltStat_Object(self.address))

    ## Current sense ADC over-current fault phase 7
    def ph7(self):
        value = dma_bits(0xE948, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self):
        value = dma_bits(0xE948, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self):
        value = dma_bits(0xE948, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self):
        value = dma_bits(0xE948, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self):
        value = dma_bits(0xE948, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self):
        value = dma_bits(0xE948, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self):
        value = dma_bits(0xE948, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self):
        value = dma_bits(0xE948, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Stat Per-Phase Synthesizer current mistracking versus sensed - RO
###################################################################
class phiEstFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE949, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phiEstFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE949, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phiEstFltStat_Object(self.address))

    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self):
        value = dma_bits(0xE949, self.address, 1, 7, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self):
        value = dma_bits(0xE949, self.address, 1, 6, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self):
        value = dma_bits(0xE949, self.address, 1, 5, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self):
        value = dma_bits(0xE949, self.address, 1, 4, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self):
        value = dma_bits(0xE949, self.address, 1, 3, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self):
        value = dma_bits(0xE949, self.address, 1, 2, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self):
        value = dma_bits(0xE949, self.address, 1, 1, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self):
        value = dma_bits(0xE949, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault Test Per-Controller A - RW
###################################################################
class ctrlFltTestA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE950, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltTestA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE950, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltTestA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.pinOpen & 0x1) << 23)
        reg = (reg & 0xBFFFFF) + ((register_object.mcuDead & 0x1) << 22)
        reg = (reg & 0xDFFFFF) + ((register_object.pInAlert & 0x1) << 21)
        reg = (reg & 0xEFFFFF) + ((register_object.external & 0x1) << 20)
        reg = (reg & 0xF7FFFF) + ((register_object.tmonFlt2 & 0x1) << 19)
        reg = (reg & 0xFBFFFF) + ((register_object.underTempFlt2 & 0x1) << 18)
        reg = (reg & 0xFDFFFF) + ((register_object.overTempFlt2 & 0x1) << 17)
        reg = (reg & 0xFEFFFF) + ((register_object.tmonFlt1 & 0x1) << 16)
        reg = (reg & 0xFF7FFF) + ((register_object.underTempFlt1 & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.overTempFlt1 & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.tmonFlt0 & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.underTempFlt0 & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.overTempFlt0 & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.configLoad & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.diagFault & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.watchdog & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.intTemp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.vdd1p8OvTelFlt & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.avdd18ValidSyncZ & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.vdd1p8UvTelFlt & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.vddioUV & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.vdd12ValidZ & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.vdd33Brownout & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.vdd33ValidZ & 0x1)
        dma(self.address, 0xE950, reg)
    ## 23 - Open pin detected fault
    def pinOpen(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 23, value)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 22, value)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 21, value)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 20, value)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 19, value)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 18, value)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 17, value)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 16, value)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 15, value)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 14, value)
        return(value)
    ## 13 - SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 13, value)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 12, value)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 11, value)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 10, value)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 9, value)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 8, value)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 7, value)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 6, value)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 5, value)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 4, value)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 3, value)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 2, value)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 1, value)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self, value = None):
        value = dma_bits(0xE950, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Controller B - RW
###################################################################
class ctrlFltTestB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE951, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFltTestB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE951, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFltTestB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.adcClkUnlockT & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.adcClkUnlockI & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.adcClkUnlockV & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.psysWarn2 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.psysWarn1 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.psysCrit & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.iinSense1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.iinSense0 & 0x1)
        dma(self.address, 0xE951, reg)
    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 7, value)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 6, value)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 5, value)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 4, value)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 3, value)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 2, value)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 1, value)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self, value = None):
        value = dma_bits(0xE951, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Rail 0 - RW
###################################################################
class railFltTest0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE952, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltTest0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE952, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltTest0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE952, reg)
    ## Spare fault 0
    def spareFlt(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 0
    def iinSupply(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 20, value)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 0
    def inputOCF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 0
    def outputUTW(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 0
    def outputUTF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 0
    def outputOTW(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 0
    def outputOTF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 0
    def inputOCW(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 0
    def outputOPF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE952, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Rail 1 - RW
###################################################################
class railFltTest1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE953, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltTest1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE953, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltTest1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE953, reg)
    ## Spare fault 1
    def spareFlt(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 1
    def iinSupply(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 20, value)
        return(value)
    ## SPS TMON1 fault signal on TEMP1
    def tmonFlt(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 1
    def inputOCF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 1
    def inputOCW(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 1
    def outputOPF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE953, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Rail 2 - RW
###################################################################
class railFltTest2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE954, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFltTest2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE954, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFltTest2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spareFlt & 0x1) << 22)
        reg = (reg & 0x5FFFFF) + ((register_object.iinSupply & 0x1) << 21)
        reg = (reg & 0x6FFFFF) + ((register_object.vccUnderVout & 0x1) << 20)
        reg = (reg & 0x77FFFF) + ((register_object.tmonFlt & 0x1) << 19)
        reg = (reg & 0x7BFFFF) + ((register_object.oovFault & 0x1) << 18)
        reg = (reg & 0x7DFFFF) + ((register_object.ouvFault & 0x1) << 17)
        reg = (reg & 0x7EFFFF) + ((register_object.fastSumOcWarn & 0x1) << 16)
        reg = (reg & 0x7F7FFF) + ((register_object.slowSumOcFault & 0x1) << 15)
        reg = (reg & 0x7FBFFF) + ((register_object.fastSumOcFault & 0x1) << 14)
        reg = (reg & 0x7FDFFF) + ((register_object.slowSumOcDetect & 0x1) << 13)
        reg = (reg & 0x7FEFFF) + ((register_object.fastSumOcDetect & 0x1) << 12)
        reg = (reg & 0x7FF7FF) + ((register_object.currBalFault & 0x1) << 11)
        reg = (reg & 0x7FFBFF) + ((register_object.inputOCF & 0x1) << 10)
        reg = (reg & 0x7FFDFF) + ((register_object.outputUTW & 0x1) << 9)
        reg = (reg & 0x7FFEFF) + ((register_object.outputUTF & 0x1) << 8)
        reg = (reg & 0x7FFF7F) + ((register_object.outputOTW & 0x1) << 7)
        reg = (reg & 0x7FFFBF) + ((register_object.outputOTF & 0x1) << 6)
        reg = (reg & 0x7FFFDF) + ((register_object.inputOCW & 0x1) << 5)
        reg = (reg & 0x7FFFEF) + ((register_object.outputOPF & 0x1) << 4)
        reg = (reg & 0x7FFFF7) + ((register_object.vinUnderVoltW & 0x1) << 3)
        reg = (reg & 0x7FFFFB) + ((register_object.vinOverVoltW & 0x1) << 2)
        reg = (reg & 0x7FFFFD) + ((register_object.vinUnderVoltF & 0x1) << 1)
        reg = (reg & 0x7FFFFE) + (register_object.vinOverVoltF & 0x1)
        dma(self.address, 0xE954, reg)
    ## Spare fault 2
    def spareFlt(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 22, value)
        return(value)
    ## Input supply over current 2
    def iinSupply(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 21, value)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 20, value)
        return(value)
    ## SPS TMON1 fault signal on TEMP2
    def tmonFlt(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 19, value)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 18, value)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 17, value)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 16, value)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 15, value)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 14, value)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 13, value)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 12, value)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 11, value)
        return(value)
    ## Input over current fault 2
    def inputOCF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 10, value)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 9, value)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 8, value)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 7, value)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 6, value)
        return(value)
    ## Input over current warning 2
    def inputOCW(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 5, value)
        return(value)
    ## Output over power fault 2
    def outputOPF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 4, value)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 3, value)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 2, value)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 1, value)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self, value = None):
        value = dma_bits(0xE954, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Phase PeakUcFaults - RW
###################################################################
class phPeakUcFltTest_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE955, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakUcFltTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE955, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakUcFltTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE955, reg)
    ## Peak negative undercurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 7, value)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 6, value)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 5, value)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 4, value)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 3, value)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 2, value)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 1, value)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE955, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Phase PeakOcFaults - RW
###################################################################
class phPeakOcFltTest_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE956, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPeakOcFltTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE956, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phPeakOcFltTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE956, reg)
    ## Peak negative overcurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 7, value)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 6, value)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 5, value)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 4, value)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 3, value)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 2, value)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 1, value)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE956, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Phase ADC under-current - RW
###################################################################
class phAdcUcFltTest_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE957, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcUcFltTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE957, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcUcFltTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE957, reg)
    ## Current sense ADC undercurrent fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 7, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 6, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 5, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 4, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 3, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 2, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 1, value)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE957, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Phase ADC over-current  - RW
###################################################################
class phAdcOcFltTest_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE958, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phAdcOcFltTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE958, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phAdcOcFltTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE958, reg)
    ## Current sense ADC over-current fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 7, value)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 6, value)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 5, value)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 4, value)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 3, value)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 2, value)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 1, value)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE958, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault Test Per-Phase Synthesizer current mistracking versus sensed - RW
###################################################################
class phiEstFltTest_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE959, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phiEstFltTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE959, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.phiEstFltTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ph7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.ph6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.ph5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ph4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.ph3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.ph2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ph1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ph0 & 0x1)
        dma(self.address, 0xE959, reg)
    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 7, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 6, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 5, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 4, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 3, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 2, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 1, value)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self, value = None):
        value = dma_bits(0xE959, self.address, 1, 0, value)
        return(value)

###################################################################
## CFP Fault Enable Per-Controller A - RW
###################################################################
class cfpCtrlFltEnA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE960, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class cfpCtrlFltEnA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE960, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.cfpCtrlFltEnA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.pinOpen & 0x1) << 23)
        reg = (reg & 0xBFFFFF) + ((register_object.mcuDead & 0x1) << 22)
        reg = (reg & 0xDFFFFF) + ((register_object.pInAlert & 0x1) << 21)
        reg = (reg & 0xEFFFFF) + ((register_object.external & 0x1) << 20)
        reg = (reg & 0xF7FFFF) + ((register_object.tmonFlt2 & 0x1) << 19)
        reg = (reg & 0xFBFFFF) + ((register_object.underTempFlt2 & 0x1) << 18)
        reg = (reg & 0xFDFFFF) + ((register_object.overTempFlt2 & 0x1) << 17)
        reg = (reg & 0xFEFFFF) + ((register_object.tmonFlt1 & 0x1) << 16)
        reg = (reg & 0xFF7FFF) + ((register_object.underTempFlt1 & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.overTempFlt1 & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.tmonFlt0 & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.underTempFlt0 & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.overTempFlt0 & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.configLoad & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.diagFault & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.watchdog & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.intTemp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.vdd1p8OvTelFlt & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.avdd18ValidSyncZ & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.vdd1p8UvTelFlt & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.vddioUV & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.vdd12ValidZ & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.vdd33Brownout & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.vdd33ValidZ & 0x1)
        dma(self.address, 0xE960, reg)
    ## 23 - Open pin detected fault
    def pinOpen(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 23, value)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 22, value)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 21, value)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 20, value)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 19, value)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 18, value)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 17, value)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 16, value)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 15, value)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 14, value)
        return(value)
    ## 13 - SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 13, value)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 12, value)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 11, value)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 10, value)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 9, value)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 8, value)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 7, value)
        return(value)
    ## 6 - VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 6, value)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 5, value)
        return(value)
    ## 4 - VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 4, value)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 3, value)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 2, value)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 1, value)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self, value = None):
        value = dma_bits(0xE960, self.address, 1, 0, value)
        return(value)

###################################################################
## CFP Fault Enable Per-Controller B - RW
###################################################################
class cfpCtrlFltEnB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE961, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class cfpCtrlFltEnB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE961, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.cfpCtrlFltEnB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.adcClkUnlockT & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.adcClkUnlockI & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.adcClkUnlockV & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.psysWarn2 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.psysWarn1 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.psysCrit & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.iinSense1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.iinSense0 & 0x1)
        dma(self.address, 0xE961, reg)
    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 7, value)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 6, value)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 5, value)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 4, value)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 3, value)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 2, value)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 1, value)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self, value = None):
        value = dma_bits(0xE961, self.address, 1, 0, value)
        return(value)

###################################################################
## CFP Fault Enable Per-Rail 0 - RW
###################################################################
class cfpRailFltEn0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE962, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Rail 1 - RW
###################################################################
class cfpRailFltEn1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE963, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Rail 2 - RW
###################################################################
class cfpRailFltEn2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE964, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Phase PeakUcFaults - RW
###################################################################
class cfpPhPeakUcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE965, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Phase PeakOcFaults - RW
###################################################################
class cfpPhPeakOcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE966, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Phase ADC under-current - RW
###################################################################
class cfpPhAdcUcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE967, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Phase ADC over-current - RW
###################################################################
class cfpPhAdcOcFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE968, value)
        return(value)


###################################################################
## CFP Fault Enable Per-Phase Synthesizer current mistracking versus sensed - RW
###################################################################
class cfpPhiEstFltEn_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE969, value)
        return(value)


###################################################################
## CFP Fault Status Per-Controller A - RO
###################################################################
class cfpCtrlFltStatA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE96A, value)
        return(value)


###################################################################
## CFP Fault Status Per-Controller B - RO
###################################################################
class cfpCtrlFltStatB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE96B, value)
        return(value)


###################################################################
## CFP Fault Status Per-Rail 0 - RO
###################################################################
class cfpRailFltStat0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE96C, value)
        return(value)


###################################################################
## CFP Fault Status Per-Rail 1 - RO
###################################################################
class cfpRailFltStat1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE96D, value)
        return(value)


###################################################################
## CFP Fault Status Per-Rail 2 - RO
###################################################################
class cfpRailFltStat2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE96E, value)
        return(value)


###################################################################
## CFP Fault Status Per-Phase PeakUcFaults - RO
###################################################################
class cfpPhPeakUcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE96F, value)
        return(value)


###################################################################
## CFP Fault Status Per-Phase PeakOcFaults - RO
###################################################################
class cfpPhPeakOcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE970, value)
        return(value)


###################################################################
## CFP Fault Per-Phase ADC under-current - ROWC
###################################################################
class cfpPhAdcUcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE971, value)
        return(value)


###################################################################
## CFP Fault Status Per-Phase ADC over-current - ROWC
###################################################################
class cfpPhAdcOcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE972, value)
        return(value)


###################################################################
## CFP Fault Status Per-Phase Synthesizer current mistracking versus sensed - ROWC
###################################################################
class cfpPhiEstFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE973, value)
        return(value)


###################################################################
## Fault First Latch Per-Controller A - ROWC
###################################################################
class ctrlFirstFltRegA_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE974, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFirstFltRegA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE974, None)
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFirstFltRegA_Object(self.address))

    ## 23 - Open pin detected fault
    def pinOpen(self):
        value = dma_bits(0xE974, self.address, 1, 23, None)
        return(value)
    ## 22 - Hard Fault has occurred (memory bus violation)
    def mcuDead(self):
        value = dma_bits(0xE974, self.address, 1, 22, None)
        return(value)
    ## 21 - Input overcurrent fault
    def pInAlert(self):
        value = dma_bits(0xE974, self.address, 1, 21, None)
        return(value)
    ## 20 - External VTT input pin fault
    def external(self):
        value = dma_bits(0xE974, self.address, 1, 20, None)
        return(value)
    ## 19 - SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self):
        value = dma_bits(0xE974, self.address, 1, 19, None)
        return(value)
    ## 18 - Fault on TEMP2 data
    def underTempFlt2(self):
        value = dma_bits(0xE974, self.address, 1, 18, None)
        return(value)
    ## 17 - Fault on TEMP2 data
    def overTempFlt2(self):
        value = dma_bits(0xE974, self.address, 1, 17, None)
        return(value)
    ## 16 - SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self):
        value = dma_bits(0xE974, self.address, 1, 16, None)
        return(value)
    ## 15 - Fault on TEMP1 data
    def underTempFlt1(self):
        value = dma_bits(0xE974, self.address, 1, 15, None)
        return(value)
    ## 14 - Fault on TEMP1 data
    def overTempFlt1(self):
        value = dma_bits(0xE974, self.address, 1, 14, None)
        return(value)
    ## 13 - SPctrlFirstFltRegAlt signal on TEMP0
    def tmonFlt0(self):
        value = dma_bits(0xE974, self.address, 1, 13, None)
        return(value)
    ## 12 - Fault on TEMP0 data
    def underTempFlt0(self):
        value = dma_bits(0xE974, self.address, 1, 12, None)
        return(value)
    ## 11 - Fault on TEMP0 data
    def overTempFlt0(self):
        value = dma_bits(0xE974, self.address, 1, 11, None)
        return(value)
    ## 10 - Attempt to load user configuration failed
    def configLoad(self):
        value = dma_bits(0xE974, self.address, 1, 10, None)
        return(value)
    ## 9 -DIAGFTL bit 0 or 2 is active
    def diagFault(self):
        value = dma_bits(0xE974, self.address, 1, 9, None)
        return(value)
    ## 8 -Watchdog timer fault
    def watchdog(self):
        value = dma_bits(0xE974, self.address, 1, 8, None)
        return(value)
    ## 7 - Internal overtemperature fault
    def intTemp(self):
        value = dma_bits(0xE974, self.address, 1, 7, None)
        return(value)
    ## 6 - VDD1.8V over voltage faul
    def vdd1p8OvTelFlt(self):
        value = dma_bits(0xE974, self.address, 1, 6, None)
        return(value)
    ## 5 - VDD1.8 not valid fault
    def avdd18ValidSyncZ(self):
        value = dma_bits(0xE974, self.address, 1, 5, None)
        return(value)
    ## 4 - VDD1.8V under voltage faul
    def vdd1p8UvTelFlt(self):
        value = dma_bits(0xE974, self.address, 1, 4, None)
        return(value)
    ## 3 - VDDIO undervoltage fault
    def vddioUV(self):
        value = dma_bits(0xE974, self.address, 1, 3, None)
        return(value)
    ## 2 - VCCS undervoltage fault
    def vdd12ValidZ(self):
        value = dma_bits(0xE974, self.address, 1, 2, None)
        return(value)
    ## 1 - VCC supply brown out,from telemetry
    def vdd33Brownout(self):
        value = dma_bits(0xE974, self.address, 1, 1, None)
        return(value)
    ## 0 - VCC undervoltage fault
    def vdd33ValidZ(self):
        value = dma_bits(0xE974, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Controller B - ROWC
###################################################################
class ctrlFirstFltRegB_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE975, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlFirstFltRegB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE975, None)
            self.adcClkUnlockT = (self.reg_value >> 7) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 6) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 5) & 0x1
            self.psysWarn2 = (self.reg_value >> 4) & 0x1
            self.psysWarn1 = (self.reg_value >> 3) & 0x1
            self.psysCrit = (self.reg_value >> 2) & 0x1
            self.iinSense1 = (self.reg_value >> 1) & 0x1
            self.iinSense0 = self.reg_value & 0x1

    def read_object(self):
        return(self.ctrlFirstFltRegB_Object(self.address))

    ## Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self):
        value = dma_bits(0xE975, self.address, 1, 7, None)
        return(value)
    ## Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self):
        value = dma_bits(0xE975, self.address, 1, 6, None)
        return(value)
    ## Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self):
        value = dma_bits(0xE975, self.address, 1, 5, None)
        return(value)
    ## PSYS warning 2 level fault
    def psysWarn2(self):
        value = dma_bits(0xE975, self.address, 1, 4, None)
        return(value)
    ## PSYS warning 1 level fault
    def psysWarn1(self):
        value = dma_bits(0xE975, self.address, 1, 3, None)
        return(value)
    ## PSYS critical level fault
    def psysCrit(self):
        value = dma_bits(0xE975, self.address, 1, 2, None)
        return(value)
    ## IIN Sense 1 fault
    def iinSense1(self):
        value = dma_bits(0xE975, self.address, 1, 1, None)
        return(value)
    ## IIN Sense 0 fault
    def iinSense0(self):
        value = dma_bits(0xE975, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Rail 0 - ROWC
###################################################################
class railFirstFltReg0_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE976, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFirstFltReg0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE976, None)
            self.spareFlt0 = (self.reg_value >> 22) & 0x1
            self.iinSupply0 = (self.reg_value >> 21) & 0x1
            self.vccUnderVout0 = (self.reg_value >> 20) & 0x1
            self.tmonFlt0 = (self.reg_value >> 19) & 0x1
            self.oovFault0 = (self.reg_value >> 18) & 0x1
            self.ouvFault0 = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn0 = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault0 = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault0 = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect0 = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect0 = (self.reg_value >> 12) & 0x1
            self.currBalFault0 = (self.reg_value >> 11) & 0x1
            self.inputOCF0 = (self.reg_value >> 10) & 0x1
            self.outputUTW0 = (self.reg_value >> 9) & 0x1
            self.outputUTF0 = (self.reg_value >> 8) & 0x1
            self.outputOTW0 = (self.reg_value >> 7) & 0x1
            self.outputOTF0 = (self.reg_value >> 6) & 0x1
            self.inputOCW0 = (self.reg_value >> 5) & 0x1
            self.outputOPF0 = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW0 = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW0 = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF0 = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF0 = self.reg_value & 0x1

    def read_object(self):
        return(self.railFirstFltReg0_Object(self.address))

    ## Spare fault 0
    def spareFlt0(self):
        value = dma_bits(0xE976, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 0
    def iinSupply0(self):
        value = dma_bits(0xE976, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 0
    def vccUnderVout0(self):
        value = dma_bits(0xE976, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self):
        value = dma_bits(0xE976, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 0
    def oovFault0(self):
        value = dma_bits(0xE976, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 0
    def ouvFault0(self):
        value = dma_bits(0xE976, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 0
    def fastSumOcWarn0(self):
        value = dma_bits(0xE976, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 0
    def slowSumOcFault0(self):
        value = dma_bits(0xE976, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 0
    def fastSumOcFault0(self):
        value = dma_bits(0xE976, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 0
    def slowSumOcDetect0(self):
        value = dma_bits(0xE976, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 0
    def fastSumOcDetect0(self):
        value = dma_bits(0xE976, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 0
    def currBalFault0(self):
        value = dma_bits(0xE976, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 0
    def inputOCF0(self):
        value = dma_bits(0xE976, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 0
    def outputUTW0(self):
        value = dma_bits(0xE976, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 0
    def outputUTF0(self):
        value = dma_bits(0xE976, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 0
    def outputOTW0(self):
        value = dma_bits(0xE976, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 0
    def outputOTF0(self):
        value = dma_bits(0xE976, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 0
    def inputOCW0(self):
        value = dma_bits(0xE976, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 0
    def outputOPF0(self):
        value = dma_bits(0xE976, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 0
    def vinUnderVoltW0(self):
        value = dma_bits(0xE976, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 0
    def vinOverVoltW0(self):
        value = dma_bits(0xE976, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 0
    def vinUnderVoltF0(self):
        value = dma_bits(0xE976, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 0
    def vinOverVoltF0(self):
        value = dma_bits(0xE976, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Rail 1 - ROWC
###################################################################
class railFirstFltReg1_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE977, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFirstFltReg1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE977, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFirstFltReg1_Object(self.address))

    ## Spare fault 1
    def spareFlt(self):
        value = dma_bits(0xE977, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 1
    def iinSupply(self):
        value = dma_bits(0xE977, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 1
    def vccUnderVout(self):
        value = dma_bits(0xE977, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP1
    def tmonFlt(self):
        value = dma_bits(0xE977, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 1
    def oovFault(self):
        value = dma_bits(0xE977, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 1
    def ouvFault(self):
        value = dma_bits(0xE977, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 1
    def fastSumOcWarn(self):
        value = dma_bits(0xE977, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 1
    def slowSumOcFault(self):
        value = dma_bits(0xE977, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 1
    def fastSumOcFault(self):
        value = dma_bits(0xE977, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 1
    def slowSumOcDetect(self):
        value = dma_bits(0xE977, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 1
    def fastSumOcDetect(self):
        value = dma_bits(0xE977, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 1
    def currBalFault(self):
        value = dma_bits(0xE977, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 1
    def inputOCF(self):
        value = dma_bits(0xE977, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 1
    def outputUTW(self):
        value = dma_bits(0xE977, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 1
    def outputUTF(self):
        value = dma_bits(0xE977, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 1
    def outputOTW(self):
        value = dma_bits(0xE977, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 1
    def outputOTF(self):
        value = dma_bits(0xE977, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 1
    def inputOCW(self):
        value = dma_bits(0xE977, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 1
    def outputOPF(self):
        value = dma_bits(0xE977, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 1
    def vinUnderVoltW(self):
        value = dma_bits(0xE977, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 1
    def vinOverVoltW(self):
        value = dma_bits(0xE977, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 1
    def vinUnderVoltF(self):
        value = dma_bits(0xE977, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 1
    def vinOverVoltF(self):
        value = dma_bits(0xE977, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Rail 2 - ROWC
###################################################################
class railFirstFltReg2_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xE978, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class railFirstFltReg2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE978, None)
            self.spareFlt = (self.reg_value >> 22) & 0x1
            self.iinSupply = (self.reg_value >> 21) & 0x1
            self.vccUnderVout = (self.reg_value >> 20) & 0x1
            self.tmonFlt = (self.reg_value >> 19) & 0x1
            self.oovFault = (self.reg_value >> 18) & 0x1
            self.ouvFault = (self.reg_value >> 17) & 0x1
            self.fastSumOcWarn = (self.reg_value >> 16) & 0x1
            self.slowSumOcFault = (self.reg_value >> 15) & 0x1
            self.fastSumOcFault = (self.reg_value >> 14) & 0x1
            self.slowSumOcDetect = (self.reg_value >> 13) & 0x1
            self.fastSumOcDetect = (self.reg_value >> 12) & 0x1
            self.currBalFault = (self.reg_value >> 11) & 0x1
            self.inputOCF = (self.reg_value >> 10) & 0x1
            self.outputUTW = (self.reg_value >> 9) & 0x1
            self.outputUTF = (self.reg_value >> 8) & 0x1
            self.outputOTW = (self.reg_value >> 7) & 0x1
            self.outputOTF = (self.reg_value >> 6) & 0x1
            self.inputOCW = (self.reg_value >> 5) & 0x1
            self.outputOPF = (self.reg_value >> 4) & 0x1
            self.vinUnderVoltW = (self.reg_value >> 3) & 0x1
            self.vinOverVoltW = (self.reg_value >> 2) & 0x1
            self.vinUnderVoltF = (self.reg_value >> 1) & 0x1
            self.vinOverVoltF = self.reg_value & 0x1

    def read_object(self):
        return(self.railFirstFltReg2_Object(self.address))

    ## Spare fault 2
    def spareFlt(self):
        value = dma_bits(0xE978, self.address, 1, 22, None)
        return(value)
    ## Input supply over current 2
    def iinSupply(self):
        value = dma_bits(0xE978, self.address, 1, 21, None)
        return(value)
    ## VCC comparator at VOUT pin 2
    def vccUnderVout(self):
        value = dma_bits(0xE978, self.address, 1, 20, None)
        return(value)
    ## SPS TMON0 fault signal on TEMP2
    def tmonFlt(self):
        value = dma_bits(0xE978, self.address, 1, 19, None)
        return(value)
    ## Output overvoltage fault channel 2
    def oovFault(self):
        value = dma_bits(0xE978, self.address, 1, 18, None)
        return(value)
    ## Output undervoltage fault channel 2
    def ouvFault(self):
        value = dma_bits(0xE978, self.address, 1, 17, None)
        return(value)
    ## Fast response filtered total output overcurrent warning channel 2
    def fastSumOcWarn(self):
        value = dma_bits(0xE978, self.address, 1, 16, None)
        return(value)
    ## Slow response filtered total output overcurrent fault channel 2
    def slowSumOcFault(self):
        value = dma_bits(0xE978, self.address, 1, 15, None)
        return(value)
    ## Fast response filtered total output overcurrent fault channel 2
    def fastSumOcFault(self):
        value = dma_bits(0xE978, self.address, 1, 14, None)
        return(value)
    ## Slow response filtered total output overcurrent detection channel 2
    def slowSumOcDetect(self):
        value = dma_bits(0xE978, self.address, 1, 13, None)
        return(value)
    ## Fast response filtered total output overcurrent detection channel 2
    def fastSumOcDetect(self):
        value = dma_bits(0xE978, self.address, 1, 12, None)
        return(value)
    ## Current balance fault on channel 2
    def currBalFault(self):
        value = dma_bits(0xE978, self.address, 1, 11, None)
        return(value)
    ## Input over current fault 2
    def inputOCF(self):
        value = dma_bits(0xE978, self.address, 1, 10, None)
        return(value)
    ## Output under temperature warning 2
    def outputUTW(self):
        value = dma_bits(0xE978, self.address, 1, 9, None)
        return(value)
    ## Output under temperature fault 2
    def outputUTF(self):
        value = dma_bits(0xE978, self.address, 1, 8, None)
        return(value)
    ## Output over temperature warning 2
    def outputOTW(self):
        value = dma_bits(0xE978, self.address, 1, 7, None)
        return(value)
    ## Output over temperature fault 2
    def outputOTF(self):
        value = dma_bits(0xE978, self.address, 1, 6, None)
        return(value)
    ## Input over current warning 2
    def inputOCW(self):
        value = dma_bits(0xE978, self.address, 1, 5, None)
        return(value)
    ## Output over power fault 2
    def outputOPF(self):
        value = dma_bits(0xE978, self.address, 1, 4, None)
        return(value)
    ## Vin undervoltage warning 2
    def vinUnderVoltW(self):
        value = dma_bits(0xE978, self.address, 1, 3, None)
        return(value)
    ## Vin overvoltage warning 2
    def vinOverVoltW(self):
        value = dma_bits(0xE978, self.address, 1, 2, None)
        return(value)
    ## Vin undervoltage fault 2
    def vinUnderVoltF(self):
        value = dma_bits(0xE978, self.address, 1, 1, None)
        return(value)
    ## Vin overvoltage fault 2
    def vinOverVoltF(self):
        value = dma_bits(0xE978, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Phase PeakUcFaults - ROWC
###################################################################
class firstPhPeakUcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE979, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class firstPhPeakUcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE979, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.firstPhPeakUcFltReg_Object(self.address))

    ## Peak negative undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE979, self.address, 1, 7, None)
        return(value)
    ## Peak negative undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE979, self.address, 1, 6, None)
        return(value)
    ## Peak negative undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE979, self.address, 1, 5, None)
        return(value)
    ## Peak negative undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE979, self.address, 1, 4, None)
        return(value)
    ## Peak negative undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE979, self.address, 1, 3, None)
        return(value)
    ## Peak negative undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE979, self.address, 1, 2, None)
        return(value)
    ## Peak negative undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE979, self.address, 1, 1, None)
        return(value)
    ## Peak negative undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE979, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Phase PeakOcFaults - ROWC
###################################################################
class firstPhPeakOcFltReg_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE97A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class firstPhPeakOcFltReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE97A, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.firstPhPeakOcFltReg_Object(self.address))

    ## Peak negative overcurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE97A, self.address, 1, 7, None)
        return(value)
    ## Peak negative overcurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE97A, self.address, 1, 6, None)
        return(value)
    ## Peak negative overcurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE97A, self.address, 1, 5, None)
        return(value)
    ## Peak negative overcurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE97A, self.address, 1, 4, None)
        return(value)
    ## Peak negative overcurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE97A, self.address, 1, 3, None)
        return(value)
    ## Peak negative overcurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE97A, self.address, 1, 2, None)
        return(value)
    ## Peak negative overcurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE97A, self.address, 1, 1, None)
        return(value)
    ## Peak negative overcurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE97A, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Phase ADC under-current - ROWC
###################################################################
class firstPhAdcUcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE97B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class firstPhAdcUcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE97B, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.firstPhAdcUcFltStat_Object(self.address))

    ## Current sense ADC undercurrent fault phase 7
    def ph7(self):
        value = dma_bits(0xE97B, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 6
    def ph6(self):
        value = dma_bits(0xE97B, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 5
    def ph5(self):
        value = dma_bits(0xE97B, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 4
    def ph4(self):
        value = dma_bits(0xE97B, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 3
    def ph3(self):
        value = dma_bits(0xE97B, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 2
    def ph2(self):
        value = dma_bits(0xE97B, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 1
    def ph1(self):
        value = dma_bits(0xE97B, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC undercurrent fault phase 0
    def ph0(self):
        value = dma_bits(0xE97B, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Phase ADC over-current - ROWC
###################################################################
class firstPhAdcOcFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE97C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class firstPhAdcOcFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE97C, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.firstPhAdcOcFltStat_Object(self.address))

    ## Current sense ADC over-current fault phase 7
    def ph7(self):
        value = dma_bits(0xE97C, self.address, 1, 7, None)
        return(value)
    ## Current sense ADC over-current fault phase 6
    def ph6(self):
        value = dma_bits(0xE97C, self.address, 1, 6, None)
        return(value)
    ## Current sense ADC over-current fault phase 5
    def ph5(self):
        value = dma_bits(0xE97C, self.address, 1, 5, None)
        return(value)
    ## Current sense ADC over-current fault phase 4
    def ph4(self):
        value = dma_bits(0xE97C, self.address, 1, 4, None)
        return(value)
    ## Current sense ADC over-current fault phase 3
    def ph3(self):
        value = dma_bits(0xE97C, self.address, 1, 3, None)
        return(value)
    ## Current sense ADC over-current fault phase 2
    def ph2(self):
        value = dma_bits(0xE97C, self.address, 1, 2, None)
        return(value)
    ## Current sense ADC over-current fault phase 1
    def ph1(self):
        value = dma_bits(0xE97C, self.address, 1, 1, None)
        return(value)
    ## Current sense ADC over-current fault phase 0
    def ph0(self):
        value = dma_bits(0xE97C, self.address, 1, 0, None)
        return(value)

###################################################################
## Fault First Latch Per-Phase Synthesizer current mistracking versus sensed - ROWC
###################################################################
class firstPhiEstFltStat_class(object):
    def __init__(self, address):
        self.interface = 'fltGl'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE97D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class firstPhiEstFltStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE97D, None)
            self.ph7 = (self.reg_value >> 7) & 0x1
            self.ph6 = (self.reg_value >> 6) & 0x1
            self.ph5 = (self.reg_value >> 5) & 0x1
            self.ph4 = (self.reg_value >> 4) & 0x1
            self.ph3 = (self.reg_value >> 3) & 0x1
            self.ph2 = (self.reg_value >> 2) & 0x1
            self.ph1 = (self.reg_value >> 1) & 0x1
            self.ph0 = self.reg_value & 0x1

    def read_object(self):
        return(self.firstPhiEstFltStat_Object(self.address))

    ## Synthesizer current mistracking versus sensed fault phase 7
    def ph7(self):
        value = dma_bits(0xE97D, self.address, 1, 7, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 6
    def ph6(self):
        value = dma_bits(0xE97D, self.address, 1, 6, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 5
    def ph5(self):
        value = dma_bits(0xE97D, self.address, 1, 5, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 4
    def ph4(self):
        value = dma_bits(0xE97D, self.address, 1, 4, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 3
    def ph3(self):
        value = dma_bits(0xE97D, self.address, 1, 3, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 2
    def ph2(self):
        value = dma_bits(0xE97D, self.address, 1, 2, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 1
    def ph1(self):
        value = dma_bits(0xE97D, self.address, 1, 1, None)
        return(value)
    ## Synthesizer current mistracking versus sensed fault phase 0
    def ph0(self):
        value = dma_bits(0xE97D, self.address, 1, 0, None)
        return(value)

###################################################################
## Loop manager phase information MSBit
###################################################################
class lmpiAssoc2_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE990, value)
        return(value)


###################################################################
## Loop manager phase information LSBit
###################################################################
class lmpiAssoc_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE991, value)
        return(value)


###################################################################
## Loop manager phase information
###################################################################
class lmpiAvail_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE992, value)
        return(value)


###################################################################
## PWM output signal mapping to phases -- Ext<=Int
###################################################################
class phMapPwm_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE993, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phMapPwm_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE993, None)
            self.pwmH = (self.reg_value >> 21) & 0x7
            self.pwmG = (self.reg_value >> 18) & 0x7
            self.pwmF = (self.reg_value >> 15) & 0x7
            self.pwmE = (self.reg_value >> 12) & 0x7
            self.pwmD = (self.reg_value >> 9) & 0x7
            self.pwmC = (self.reg_value >> 6) & 0x7
            self.pwmB = (self.reg_value >> 3) & 0x7
            self.pwmA = self.reg_value & 0x7

    def read_object(self):
        return(self.phMapPwm_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.pwmH & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.pwmG & 0x7) << 18)
        reg = (reg & 0xFC7FFF) + ((register_object.pwmF & 0x7) << 15)
        reg = (reg & 0xFF8FFF) + ((register_object.pwmE & 0x7) << 12)
        reg = (reg & 0xFFF1FF) + ((register_object.pwmD & 0x7) << 9)
        reg = (reg & 0xFFFE3F) + ((register_object.pwmC & 0x7) << 6)
        reg = (reg & 0xFFFFC7) + ((register_object.pwmB & 0x7) << 3)
        reg = (reg & 0xFFFFF8) + (register_object.pwmA & 0x7)
        dma(self.address, 0xE993, reg)
    ## Pwm Pad H output comes from internal physical phase number 0-7
    def pwmH(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 21, value)
        return(value)
    ## Pwm Pad G output comes from internal physical phase number 0-7
    def pwmG(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 18, value)
        return(value)
    ## Pwm Pad F output comes from internal physical phase number 0-7
    def pwmF(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 15, value)
        return(value)
    ## Pwm Pad E output comes from internal physical phase number 0-7
    def pwmE(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 12, value)
        return(value)
    ## Pwm Pad D output comes from internal physical phase number 0-7
    def pwmD(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 9, value)
        return(value)
    ## Pwm Pad C output comes from internal physical phase number 0-7
    def pwmC(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 6, value)
        return(value)
    ## Pwm Pad B output comes from internal physical phase number 0-7
    def pwmB(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 3, value)
        return(value)
    ## Pwm Pad A output comes from internal physical phase number 0-7
    def pwmA(self, value = None):
        value = dma_bits(0xE993, self.address, 3, 0, value)
        return(value)

###################################################################
## Isen input signal mapping to phases -- Int<=Ext
###################################################################
class phMapIsen_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE994, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phMapIsen_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE994, None)
            self.isen7 = (self.reg_value >> 21) & 0x7
            self.isen6 = (self.reg_value >> 18) & 0x7
            self.isen5 = (self.reg_value >> 15) & 0x7
            self.isen4 = (self.reg_value >> 12) & 0x7
            self.isen3 = (self.reg_value >> 9) & 0x7
            self.isen2 = (self.reg_value >> 6) & 0x7
            self.isen1 = (self.reg_value >> 3) & 0x7
            self.isen0 = self.reg_value & 0x7

    def read_object(self):
        return(self.phMapIsen_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.isen7 & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.isen6 & 0x7) << 18)
        reg = (reg & 0xFC7FFF) + ((register_object.isen5 & 0x7) << 15)
        reg = (reg & 0xFF8FFF) + ((register_object.isen4 & 0x7) << 12)
        reg = (reg & 0xFFF1FF) + ((register_object.isen3 & 0x7) << 9)
        reg = (reg & 0xFFFE3F) + ((register_object.isen2 & 0x7) << 6)
        reg = (reg & 0xFFFFC7) + ((register_object.isen1 & 0x7) << 3)
        reg = (reg & 0xFFFFF8) + (register_object.isen0 & 0x7)
        dma(self.address, 0xE994, reg)
    ## Isen data for internal physical phase 7 comes from pad CS A-H
    def isen7(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 21, value)
        return(value)
    ## Isen data for internal physical phase 6 comes from pad CS A-H
    def isen6(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 18, value)
        return(value)
    ## Isen data for internal physical phase 5 comes from pad CS A-H
    def isen5(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 15, value)
        return(value)
    ## Isen data for internal physical phase 4 comes from pad CS A-H
    def isen4(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 12, value)
        return(value)
    ## Isen data for internal physical phase 3 comes from pad CS A-H
    def isen3(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 9, value)
        return(value)
    ## Isen data for internal physical phase 2 comes from pad CS A-H
    def isen2(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 6, value)
        return(value)
    ## Isen data for internal physical phase 1 comes from pad CS A-H
    def isen1(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 3, value)
        return(value)
    ## Isen data for internal physical phase 0 comes from pad CS A-H
    def isen0(self, value = None):
        value = dma_bits(0xE994, self.address, 3, 0, value)
        return(value)

###################################################################
## Loop manager boot select
###################################################################
class lmbs_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE995, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmbs_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE995, None)
            self.psCYA = (self.reg_value >> 7) & 0x1
            self.psIntEnable = (self.reg_value >> 6) & 0x1
            self.enIntEnable = (self.reg_value >> 5) & 0x1
            self.svidDebug = (self.reg_value >> 4) & 0x1
            self.bootReg = (self.reg_value >> 3) & 0x1
            self.bootVid = (self.reg_value >> 2) & 0x1
            self.bootSel = self.reg_value & 0x3

    def read_object(self):
        return(self.lmbs_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.psCYA & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.psIntEnable & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.enIntEnable & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.svidDebug & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.bootReg & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.bootVid & 0x1) << 2)
        reg = (reg & 0xFC) + (register_object.bootSel & 0x3)
        dma(self.address, 0xE995, reg)
    ## Disable PS4 shutdown feature in IMPV8 when 1
    def psCYA(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 7, value)
        return(value)
    ## Enable interrupts on change in power state when 1
    def psIntEnable(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 6, value)
        return(value)
    ## Enable interrupts on change in loop enables when 1
    def enIntEnable(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 5, value)
        return(value)
    ## Activate Intel svidDebug
    def svidDebug(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 4, value)
        return(value)
    ## Boot voltage : 0=normal (SVI2 pin-strap, pmBus BootData) 1=alternate (SVI2 BootData, pmbCh wait for voutcmd)
    def bootReg(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 3, value)
        return(value)
    ## BootData is VID code (1) or voltage in mv (0)
    def bootVid(self, value = None):
        value = dma_bits(0xE995, self.address, 1, 2, value)
        return(value)
    ## Not used
    def bootSel(self, value = None):
        value = dma_bits(0xE995, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class psysCfg_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE996, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class psysCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE996, None)
            self.c2cDownAlertHold = (self.reg_value >> 31) & 0x1
            self.c2cSetVidVrhotSet = (self.reg_value >> 30) & 0x1
            self.c2cUpAlertHold = (self.reg_value >> 29) & 0x1
            self.c2cSetVidClr = (self.reg_value >> 28) & 0x1
            self.useIMVP9P1Psys = (self.reg_value >> 27) & 0x1
            self.psRegDis = (self.reg_value >> 26) & 0x1
            self.auxImonSrc = (self.reg_value >> 22) & 0xF
            self.imvp9VccAuxEn = (self.reg_value >> 21) & 0x1
            self.zeroRdPs4 = (self.reg_value >> 20) & 0x1
            self.vinPs3Vid0En = (self.reg_value >> 19) & 0x1
            self.vinPs2Vid0En = (self.reg_value >> 18) & 0x1
            self.doCloseVid = (self.reg_value >> 17) & 0x1
            self.orHotPsys = (self.reg_value >> 16) & 0x1
            self.lastRead0D = (self.reg_value >> 15) & 0x1
            self.ps3CYA = (self.reg_value >> 14) & 0x1
            self.ps1CYA = (self.reg_value >> 13) & 0x1
            self.ps0CYA = (self.reg_value >> 12) & 0x1
            self.disable3 = (self.reg_value >> 11) & 0x1
            self.psysSrc = (self.reg_value >> 8) & 0x7
            self.isysSrc = (self.reg_value >> 5) & 0x7
            self.vsysSrc = (self.reg_value >> 2) & 0x7
            self.useVR14Psys = (self.reg_value >> 1) & 0x1
            self.psysEn = self.reg_value & 0x1

    def read_object(self):
        return(self.psysCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.c2cDownAlertHold & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.c2cSetVidVrhotSet & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.c2cUpAlertHold & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.c2cSetVidClr & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.useIMVP9P1Psys & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.psRegDis & 0x1) << 26)
        reg = (reg & 0xFC3FFFFF) + ((register_object.auxImonSrc & 0xF) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.imvp9VccAuxEn & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.zeroRdPs4 & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.vinPs3Vid0En & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.vinPs2Vid0En & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.doCloseVid & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.orHotPsys & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.lastRead0D & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ps3CYA & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.ps1CYA & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.ps0CYA & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.disable3 & 0x1) << 11)
        reg = (reg & 0xFFFFF8FF) + ((register_object.psysSrc & 0x7) << 8)
        reg = (reg & 0xFFFFFF1F) + ((register_object.isysSrc & 0x7) << 5)
        reg = (reg & 0xFFFFFFE3) + ((register_object.vsysSrc & 0x7) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useVR14Psys & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.psysEn & 0x1)
        dma(self.address, 0xE996, reg)
    ## Holdoff SVID alert when C2C nVRHOT is active and DVID is ramping down
    def c2cDownAlertHold(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 31, value)
        return(value)
    ## Set C2C nVRHOT while VID voltage change in C2C limiting mode
    def c2cSetVidVrhotSet(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 30, value)
        return(value)
    ## Holdoff SVID alert when C2C nVRHOT is active and DVID is ramping up
    def c2cUpAlertHold(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 29, value)
        return(value)
    ## Clear C2C nVRHOT on SetVid
    def c2cSetVidClr(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 28, value)
        return(value)
    ## Use IMVP9.1 mode Psys
    def useIMVP9P1Psys(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 27, value)
        return(value)
    ## Disable for Psys slave SVID Power State register
    def psRegDis(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 26, value)
        return(value)
    ## Ana source for auxiliary supply output current monitor: <br>   0=none,     1=VINSEN0,   2=IINSEN0, <br>   3=TEMP0,    4=TEMP1,    5=TEMP2, <br>   6=CONFIG, <br>   8=channel0, 9=channel1, 10=channel2, <br>   11=VOUT0,     12=VOUT,     13=VOUT2
    def auxImonSrc(self, value = None):
        value = dma_bits(0xE996, self.address, 4, 22, value)
        return(value)
    ## Enable IMVP9.1 VCCin_AUX feature registers on Psys slave - registers 0x15 and 0x21
    def imvp9VccAuxEn(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 21, value)
        return(value)
    ## GetReg Returns zero data in PS4 when active
    def zeroRdPs4(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 20, value)
        return(value)
    ## Ignore Vin dropping when at VID=0 in PS3, requires vccUvFltCtrl.vinLowPwrEn=1 also
    def vinPs3Vid0En(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 19, value)
        return(value)
    ## Ignore Vin dropping when at VID=0 in PS2, requires vccUvFltCtrl.vinLowPwrEn=1 also
    def vinPs2Vid0En(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 18, value)
        return(value)
    ## Enable +/-2 VID step as close VID if 1, else only same VID is immediate alert
    def doCloseVid(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 17, value)
        return(value)
    ## Enable logical OR of nVRHOT and PsysCrit alarms
    def orHotPsys(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 16, value)
        return(value)
    ## Enable Last Read register if 1
    def lastRead0D(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 15, value)
        return(value)
    ## In Power State 3 on SetVidDecay change to PS2 if 1
    def ps3CYA(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 14, value)
        return(value)
    ## In Power State 1 on SetVidDecay change to PS2 if 1
    def ps1CYA(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 13, value)
        return(value)
    ## In Power State 0 on SetVidDecay change to PS2 if 1
    def ps0CYA(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 12, value)
        return(value)
    ## Disable the SVID address 0x0D slave if 1
    def disable3(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 11, value)
        return(value)
    ## Ana source for system input power   -- 0=none, 1=VINSEN0, 2=IINSEN0, 3=TEMP0, 4=TEMP1, 5=TEMP2, 6=CONFIG, 7=Vsys*Isys
    def psysSrc(self, value = None):
        value = dma_bits(0xE996, self.address, 3, 8, value)
        return(value)
    ## Ana source for system input current -- 0=none, 1=VINSEN0, 2=IINSEN0, 3=TEMP0, 4=TEMP1, 5=TEMP2, 6=CONFIG, 7=none
    def isysSrc(self, value = None):
        value = dma_bits(0xE996, self.address, 3, 5, value)
        return(value)
    ## Ana source for system input voltage -- 0=none, 1=VINSEN0, 2=IINSEN0, 3=TEMP0, 4=TEMP1, 5=TEMP2, 6=CONFIG, 7=none
    def vsysSrc(self, value = None):
        value = dma_bits(0xE996, self.address, 3, 2, value)
        return(value)
    ## Use VR14 mode of comparators if 1, IMVP9 if 0
    def useVR14Psys(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 1, value)
        return(value)
    ## Enable Psys-related registers in 0Dh interface, activate counter hardware
    def psysEn(self, value = None):
        value = dma_bits(0xE996, self.address, 1, 0, value)
        return(value)

###################################################################
## SVID Design For Test Configuration
###################################################################
class dftCfg_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE997, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dftCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE997, None)
            self.expAcc0D = (self.reg_value >> 7) & 0x1
            self.digOutStat0D = (self.reg_value >> 6) & 0x1
            self.errEmu = (self.reg_value >> 5) & 0x1
            self.pktVrEvent = (self.reg_value >> 4) & 0x1
            self.pktBad = (self.reg_value >> 3) & 0x1
            self.pktAlert = (self.reg_value >> 2) & 0x1
            self.pktRecent = (self.reg_value >> 1) & 0x1
            self.dftEn = self.reg_value & 0x1

    def read_object(self):
        return(self.dftCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.expAcc0D & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.digOutStat0D & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.errEmu & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.pktVrEvent & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.pktBad & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.pktAlert & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.pktRecent & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.dftEn & 0x1)
        dma(self.address, 0xE997, reg)
    ## Expanded Accuracy Enable if 1
    def expAcc0D(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 7, value)
        return(value)
    ## Enable Digital Out Status if 1
    def digOutStat0D(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 6, value)
        return(value)
    ## Enable Error Emulation if 1
    def errEmu(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 5, value)
        return(value)
    ## Enable VR Event packet logging if 1
    def pktVrEvent(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 4, value)
        return(value)
    ## Enable Bad packet logging if 1
    def pktBad(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 3, value)
        return(value)
    ## Enable Alert packet logging if 1
    def pktAlert(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 2, value)
        return(value)
    ## Enable Recent packet logging if 1
    def pktRecent(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 1, value)
        return(value)
    ## SVID DFT Enable
    def dftEn(self, value = None):
        value = dma_bits(0xE997, self.address, 1, 0, value)
        return(value)

###################################################################
## Set Pin Alert threshold, signal source, and filtering
###################################################################
class pInAlert_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 5

    def __call__(self, value = None):
        value = dma(self.address, 0xE998, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pInAlert_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE998, None)
            self.repChan = (self.reg_value >> 3) & 0x3
            self.sumChan = self.reg_value & 0x7

    def read_object(self):
        return(self.pInAlert_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.repChan & 0x3) << 3)
        reg = (reg & 0x18) + (register_object.sumChan & 0x7)
        dma(self.address, 0xE998, reg)
    ## Channel to use for reporting Pin data and used for scaling. Setting this to 3 means self-reporting
    def repChan(self, value = None):
        value = dma_bits(0xE998, self.address, 2, 3, value)
        return(value)
    ## Mask of which channels pin to sum for alert checking
    def sumChan(self, value = None):
        value = dma_bits(0xE998, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class clickValues_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE999, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class clickValues_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE999, None)
            self.oscFreq = (self.reg_value >> 24) & 0xFF
            self.div250n = (self.reg_value >> 16) & 0xFF
            self.div100u = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.clickValues_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.oscFreq & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.div250n & 0xFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.div100u & 0xFFFF)
        dma(self.address, 0xE999, reg)
    ## Oscillator frequency in MHz
    def oscFreq(self, value = None):
        value = dma_bits(0xE999, self.address, 8, 24, value)
        return(value)
    ## direct map from configs,  math done in configs
    def div250n(self, value = None):
        value = dma_bits(0xE999, self.address, 8, 16, value)
        return(value)
    ## direct map from configs,  math done in configs
    def div100u(self, value = None):
        value = dma_bits(0xE999, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class adcConfig_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 2

    def __call__(self, value = None):
        value = dma(self.address, 0xE99A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class adcConfig_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99A, None)
            self.lfsrEnZ = (self.reg_value >> 1) & 0x1
            self.lfsrRunZ = self.reg_value & 0x1

    def read_object(self):
        return(self.adcConfig_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1) + ((register_object.lfsrEnZ & 0x1) << 1)
        reg = (reg & 0x2) + (register_object.lfsrRunZ & 0x1)
        dma(self.address, 0xE99A, reg)
    ## LFSR enable active low:  0=run, 1=halt and reset
    def lfsrEnZ(self, value = None):
        value = dma_bits(0xE99A, self.address, 1, 1, value)
        return(value)
    ## LFSR run active low: 0=run, 1=stop and hold
    def lfsrRunZ(self, value = None):
        value = dma_bits(0xE99A, self.address, 1, 0, value)
        return(value)

###################################################################
## User PWM mid drive and termination control
###################################################################
class midDriveCtrl_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xE99B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class midDriveCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99B, None)
            self.pwmLowStby = (self.reg_value >> 9) & 0x1
            self.enPwmTerm = (self.reg_value >> 8) & 0x1
            self.enLowImpdnc = (self.reg_value >> 7) & 0x1
            self.en1p8vDrv = (self.reg_value >> 6) & 0x1
            self.midDrTrim = (self.reg_value >> 4) & 0x3
            self.midDrWidth = (self.reg_value >> 1) & 0x7
            self.midDrEn = self.reg_value & 0x1

    def read_object(self):
        return(self.midDriveCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FF) + ((register_object.pwmLowStby & 0x1) << 9)
        reg = (reg & 0x2FF) + ((register_object.enPwmTerm & 0x1) << 8)
        reg = (reg & 0x37F) + ((register_object.enLowImpdnc & 0x1) << 7)
        reg = (reg & 0x3BF) + ((register_object.en1p8vDrv & 0x1) << 6)
        reg = (reg & 0x3CF) + ((register_object.midDrTrim & 0x3) << 4)
        reg = (reg & 0x3F1) + ((register_object.midDrWidth & 0x7) << 1)
        reg = (reg & 0x3FE) + (register_object.midDrEn & 0x1)
        dma(self.address, 0xE99B, reg)
    ## Drive PWM low when in lowest power state (needPwmTerm=0) to keep pin from floating
    def pwmLowStby(self, value = None):
        value = dma_bits(0xE99B, self.address, 1, 9, value)
        return(value)
    ## Activate midDrive whenever PWM is hi-Z to hold voltage
    def enPwmTerm(self, value = None):
        value = dma_bits(0xE99B, self.address, 1, 8, value)
        return(value)
    ## When using push-pull this enables a lower impedance drive
    def enLowImpdnc(self, value = None):
        value = dma_bits(0xE99B, self.address, 1, 7, value)
        return(value)
    ## When midDrive signal active, switch to 1.8V supply if 1, else use push-pull with trim
    def en1p8vDrv(self, value = None):
        value = dma_bits(0xE99B, self.address, 1, 6, value)
        return(value)
    ## PWM Mid-level Drive Trim 0=nom 1=+100mv 2=-100mv 3=+50mv
    def midDrTrim(self, value = None):
        value = dma_bits(0xE99B, self.address, 2, 4, value)
        return(value)
    ## PWM Mid-level Drive Width in clkTs cycles -- 0=2, 1=3, 2=4, 3=5, >=4=6
    def midDrWidth(self, value = None):
        value = dma_bits(0xE99B, self.address, 3, 1, value)
        return(value)
    ## Enable midDrive pulses
    def midDrEn(self, value = None):
        value = dma_bits(0xE99B, self.address, 1, 0, value)
        return(value)

###################################################################
## User system power management configuration
###################################################################
class sysPwrMgtEn_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE99C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sysPwrMgtEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99C, None)
            self.autoVinIinCtl = (self.reg_value >> 11) & 0x1
            self.autoTmonFltCtl = (self.reg_value >> 10) & 0x1
            self.autoDllCtl = (self.reg_value >> 9) & 0x1
            self.autoBgCtl = (self.reg_value >> 8) & 0x1
            self.autoOscCtl = (self.reg_value >> 7) & 0x1
            self.autoVsenAdcCtl2 = (self.reg_value >> 6) & 0x1
            self.autoVsenAdcCtl1 = (self.reg_value >> 5) & 0x1
            self.autoVsenAdcCtl0 = (self.reg_value >> 4) & 0x1
            self.autoIsenAdcCtl = (self.reg_value >> 3) & 0x1
            self.autoTelAdcCtl = (self.reg_value >> 2) & 0x1
            self.autoSysPwrCtl = (self.reg_value >> 1) & 0x1
            self.fwSysPwrCtl = self.reg_value & 0x1

    def read_object(self):
        return(self.sysPwrMgtEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF7FF) + ((register_object.autoVinIinCtl & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.autoTmonFltCtl & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.autoDllCtl & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.autoBgCtl & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.autoOscCtl & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.autoVsenAdcCtl2 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.autoVsenAdcCtl1 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.autoVsenAdcCtl0 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.autoIsenAdcCtl & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.autoTelAdcCtl & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.autoSysPwrCtl & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.fwSysPwrCtl & 0x1)
        dma(self.address, 0xE99C, reg)
    ## Enable auto power control of Vin and Iin buffers when tel active
    def autoVinIinCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 11, value)
        return(value)
    ## Enable auto power control of TMON fault detectors when ch active
    def autoTmonFltCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 10, value)
        return(value)
    ## Enable auto power control of DLL if 1, use chXCtl if 0
    def autoDllCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 9, value)
        return(value)
    ## Enable auto power control of Switch Cap Bandgap if 1, use chXCtl if 0
    def autoBgCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 8, value)
        return(value)
    ## Enable auto power control of Oscillator if 1, use chXCtl if 0
    def autoOscCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 7, value)
        return(value)
    ## Enable auto power control of Vsen2 ADC if 1, use chXCtl if 0
    def autoVsenAdcCtl2(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 6, value)
        return(value)
    ## Enable auto power control of Vsen1 ADC if 1, use chXCtl if 0
    def autoVsenAdcCtl1(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 5, value)
        return(value)
    ## Enable auto power control of Vsen0 ADC if 1, use chXCtl if 0
    def autoVsenAdcCtl0(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 4, value)
        return(value)
    ## Enable auto power control of Isen ADCs if 1, use chXCtl if 0
    def autoIsenAdcCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 3, value)
        return(value)
    ## Enable auto power control of Telemetry ADC if 1, use chXCtl if 0
    def autoTelAdcCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 2, value)
        return(value)
    ## Enable auto system power control if 1, use manual controls if 0
    def autoSysPwrCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 1, value)
        return(value)
    ## Enable firmware system power control if 1, use auto or manual controls if 0
    def fwSysPwrCtl(self, value = None):
        value = dma_bits(0xE99C, self.address, 1, 0, value)
        return(value)

###################################################################
## Vsen pin comparator global settings
###################################################################
class vsenFltCtrlGl_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xE99D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vsenFltCtrlGl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99D, None)
            self.maxVoutLpm = (self.reg_value >> 14) & 0xFF
            self.vsenCompTime = (self.reg_value >> 8) & 0x3F
            self.trimVccUv = (self.reg_value >> 5) & 0x7
            self.trimOpn = (self.reg_value >> 2) & 0x7
            self.pullUpOov = (self.reg_value >> 1) & 0x1
            self.pullUpOpn = self.reg_value & 0x1

    def read_object(self):
        return(self.vsenFltCtrlGl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFF) + ((register_object.maxVoutLpm & 0xFF) << 14)
        reg = (reg & 0x3FC0FF) + ((register_object.vsenCompTime & 0x3F) << 8)
        reg = (reg & 0x3FFF1F) + ((register_object.trimVccUv & 0x7) << 5)
        reg = (reg & 0x3FFFE3) + ((register_object.trimOpn & 0x7) << 2)
        reg = (reg & 0x3FFFFD) + ((register_object.pullUpOov & 0x1) << 1)
        reg = (reg & 0x3FFFFE) + (register_object.pullUpOpn & 0x1)
        dma(self.address, 0xE99D, reg)
    ## Output voltage must be below this for power down (use Vsen pin OOV)
    def maxVoutLpm(self, value = None):
        value = dma_bits(0xE99D, self.address, 8, 14, value)
        return(value)
    ## Time for Vsen pin comparator to switch modes
    def vsenCompTime(self, value = None):
        value = dma_bits(0xE99D, self.address, 6, 8, value)
        return(value)
    ## Trim used for VccUc 0-7: Vsen > Vcc+(0.0:0.05:0.35)
    def trimVccUv(self, value = None):
        value = dma_bits(0xE99D, self.address, 3, 5, value)
        return(value)
    ## Trim used for pin opn 0-7: Vsen > Vccs+(0.0:0.25:1.75) V
    def trimOpn(self, value = None):
        value = dma_bits(0xE99D, self.address, 3, 2, value)
        return(value)
    ## Enable VSEN pullup during OOV checking
    def pullUpOov(self, value = None):
        value = dma_bits(0xE99D, self.address, 1, 1, value)
        return(value)
    ## Enable VSEN pullup during init pin-open test
    def pullUpOpn(self, value = None):
        value = dma_bits(0xE99D, self.address, 1, 0, value)
        return(value)

###################################################################
## Test phase power management (SDIF), use with chPwrTest
###################################################################
class phPwrTest_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE99E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPwrTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99E, None)
            self.ccmLoHiSent = (self.reg_value >> 8) & 0xFF
            self.needIsen = self.reg_value & 0xFF

    def read_object(self):
        return(self.phPwrTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.ccmLoHiSent & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.needIsen & 0xFF)
        dma(self.address, 0xE99E, reg)
    ## Generate artificial signal indicating a lo-hi PWM pulse (wake up) has been sent by loop
    def ccmLoHiSent(self, value = None):
        value = dma_bits(0xE99E, self.address, 8, 8, value)
        return(value)
    ## Artificial signal indicating phase is active needing current sense data
    def needIsen(self, value = None):
        value = dma_bits(0xE99E, self.address, 8, 0, value)
        return(value)

###################################################################
## Configure details of channel power state UCFG (system is unconfigured)
###################################################################
class chPwrStUCFG_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE99F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStUCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE99F, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStUCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE99F, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE99F, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE99F, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE99F, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state NON (channel has no assigned phases)
###################################################################
class chPwrStNON_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStNON_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A0, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStNON_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A0, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A0, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A0, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A0, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state FLT (channel is in fault shutdown)
###################################################################
class chPwrStFLT_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStFLT_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A1, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStFLT_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A1, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A1, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A1, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A1, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state DIS (channel is not enabled)
###################################################################
class chPwrStDIS_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStDIS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A2, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStDIS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A2, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A2, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A2, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A2, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state PRE (channel is enabled but waiting for VinOn)
###################################################################
class chPwrStPRI_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStPRI_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A3, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStPRI_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A3, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A3, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A3, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A3, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state ACT (full active mode with phase add/drop, optional DCM)
###################################################################
class chPwrStACT_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStACT_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A4, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStACT_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A4, reg)
    ## Desired SPS power mode for phase group all or all-but-base or DROPPED PHASES
    def needChDM(self, value = None):
        value = dma_bits(0xE9A4, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A4, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A4, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state ONE (one phase only operation, no auto phase adding)
###################################################################
class chPwrStONE_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStONE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A5, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStONE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A5, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A5, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A5, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A5, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state DCM (DCM-only - possibly multiphase - with controller low FET timing control)
###################################################################
class chPwrStDCM_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStDCM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A6, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStDCM_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A6, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A6, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A6, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A6, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state DZC (one phase DCM-only - possibly multiphase - with driver zero-cross low FET control in base phase)
###################################################################
class chPwrStDZC_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStDZC_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A7, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStDZC_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A7, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A7, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A7, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A7, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state ZVF (zero VID fast start, PS0/1/boot)
###################################################################
class chPwrStZVF_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStZVF_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A8, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStZVF_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A8, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A8, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A8, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A8, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state ZVM (zero VID medium start, PS2)
###################################################################
class chPwrStZVM_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9A9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStZVM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9A9, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStZVM_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9A9, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9A9, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9A9, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9A9, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state ZVS (zero VID slow start, PS3)
###################################################################
class chPwrStZVS_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStZVS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AA, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStZVS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9AA, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9AA, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9AA, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9AA, self.address, 1, 0, value)
        return(value)

###################################################################
## Configure details of channel power state STBY (PS4 standby, minimum power)
###################################################################
class chPwrStSTBY_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStSTBY_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AB, None)
            self.needChDM = (self.reg_value >> 21) & 0x7
            self.needPh1DM = (self.reg_value >> 18) & 0x7
            self.asleep = (self.reg_value >> 15) & 0x1
            self.setButDM = (self.reg_value >> 14) & 0x1
            self.setAllDM = (self.reg_value >> 13) & 0x1
            self.needVccUv = (self.reg_value >> 12) & 0x1
            self.needOov = (self.reg_value >> 11) & 0x1
            self.needPwmTerm = (self.reg_value >> 10) & 0x1
            self.needRch = (self.reg_value >> 9) & 0x1
            self.needIadc = (self.reg_value >> 8) & 0x1
            self.needVcomp = (self.reg_value >> 7) & 0x1
            self.needFastV = (self.reg_value >> 6) & 0x1
            self.needVadc = (self.reg_value >> 5) & 0x1
            self.needPsys = (self.reg_value >> 4) & 0x1
            self.needTelemFast = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStSTBY_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.needChDM & 0x7) << 21)
        reg = (reg & 0xE3FFFF) + ((register_object.needPh1DM & 0x7) << 18)
        reg = (reg & 0xFF7FFF) + ((register_object.asleep & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.setButDM & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.setAllDM & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.needVccUv & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.needOov & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.needPwmTerm & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.needRch & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.needIadc & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.needVcomp & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.needFastV & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.needVadc & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.needPsys & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.needTelemFast & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.needTelem & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.needBg & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.needOsc & 0x1)
        dma(self.address, 0xE9AB, reg)
    ## Desired SPS power mode for phase group all or all-but-base
    def needChDM(self, value = None):
        value = dma_bits(0xE9AB, self.address, 3, 21, value)
        return(value)
    ## Desired SPS power mode for base phase
    def needPh1DM(self, value = None):
        value = dma_bits(0xE9AB, self.address, 3, 18, value)
        return(value)
    ## Expect driver to be asleep (not following PWM) and needing Z-Hi wakeup
    def asleep(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 15, value)
        return(value)
    ## Set driver power mode for all but base phase to needChDM
    def setButDM(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 14, value)
        return(value)
    ## Set driver power mode for all phases to needChDM
    def setAllDM(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 13, value)
        return(value)
    ## Switch VSEN pin comparator to Vcc undervolt vs VSEN
    def needVccUv(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 12, value)
        return(value)
    ## Switch VSEN pin comparator to output overvoltage mode
    def needOov(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 11, value)
        return(value)
    ## Activate PWM termination resistors
    def needPwmTerm(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 10, value)
        return(value)
    ## Signal loop to recharge phases before re-activating them
    def needRch(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 9, value)
        return(value)
    ## Require current sense ADCs to be active
    def needIadc(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 8, value)
        return(value)
    ## Switch Vsen ADC to comparator mode
    def needVcomp(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 7, value)
        return(value)
    ## Switch Vsen ADC to full ADC mode
    def needFastV(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 6, value)
        return(value)
    ## Power up Vsen ADC into fast standby mode or activate per FastV or Vcomp
    def needVadc(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 5, value)
        return(value)
    ## Require fast Psys comparators
    def needPsys(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 4, value)
        return(value)
    ## Require telemetry at faster rate
    def needTelemFast(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 3, value)
        return(value)
    ## Require VIN and loop telemetry
    def needTelem(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 2, value)
        return(value)
    ## Require bandgap to be active
    def needBg(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 1, value)
        return(value)
    ## Require oscillator to be active
    def needOsc(self, value = None):
        value = dma_bits(0xE9AB, self.address, 1, 0, value)
        return(value)

###################################################################
## Bandgap power change sequence step 0, off
###################################################################
class bgPwrSeq0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class bgPwrSeq0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AC, None)
            self.swCBgEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.bgPwrSeq0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.swCBgEn & 0x1) << 16)
        reg = (reg & 0x100FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x1FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9AC, reg)
    ## enable switched cap bandgap
    def swCBgEn(self, value = None):
        value = dma_bits(0xE9AC, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9AC, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9AC, self.address, 8, 0, value)
        return(value)

###################################################################
## Bandgap power change sequence step 1, on
###################################################################
class bgPwrSeq1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class bgPwrSeq1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AD, None)
            self.swCBgEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.bgPwrSeq1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.swCBgEn & 0x1) << 16)
        reg = (reg & 0x100FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x1FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9AD, reg)
    ## enable switched cap bandgap
    def swCBgEn(self, value = None):
        value = dma_bits(0xE9AD, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9AD, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9AD, self.address, 8, 0, value)
        return(value)

###################################################################
## DLL power change sequence step 0, off
###################################################################
class dllPwrSeq0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dllPwrSeq0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AE, None)
            self.dllEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.dllPwrSeq0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.dllEn & 0x1) << 16)
        reg = (reg & 0x100FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x1FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9AE, reg)
    ## enable DLL
    def dllEn(self, value = None):
        value = dma_bits(0xE9AE, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9AE, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9AE, self.address, 8, 0, value)
        return(value)

###################################################################
## DLL power change sequence step 1, on
###################################################################
class dllPwrSeq1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE9AF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dllPwrSeq1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9AF, None)
            self.dllEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.dllPwrSeq1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.dllEn & 0x1) << 16)
        reg = (reg & 0x100FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x1FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9AF, reg)
    ## enable DLL
    def dllEn(self, value = None):
        value = dma_bits(0xE9AF, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9AF, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9AF, self.address, 8, 0, value)
        return(value)

###################################################################
## Vsen ADC power change sequence step 0, off
###################################################################
class vsenPwrSeq0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vsenPwrSeq0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B0, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.vsenPwrSeq0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B0, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B0, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B0, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B0, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B0, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B0, self.address, 8, 0, value)
        return(value)

###################################################################
## Vsen ADC power change sequence step 1, almost off
###################################################################
class vsenPwrSeq1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vsenPwrSeq1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B1, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.vsenPwrSeq1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B1, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B1, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B1, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B1, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B1, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B1, self.address, 8, 0, value)
        return(value)

###################################################################
## Vsen ADC power change sequence step 2, almost on
###################################################################
class vsenPwrSeq2_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vsenPwrSeq2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B2, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.vsenPwrSeq2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B2, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B2, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B2, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B2, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B2, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B2, self.address, 8, 0, value)
        return(value)

###################################################################
## Vsen ADC power change sequence step 3, on
###################################################################
class vsenPwrSeq3_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vsenPwrSeq3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B3, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.vsenPwrSeq3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B3, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B3, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B3, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B3, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B3, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B3, self.address, 8, 0, value)
        return(value)

###################################################################
## Isen ADC power change sequence step 0, off
###################################################################
class isenPwrSeq0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class isenPwrSeq0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B4, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.isenPwrSeq0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B4, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B4, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B4, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B4, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B4, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B4, self.address, 8, 0, value)
        return(value)

###################################################################
## Isen ADC power change sequence step 1, almost on
###################################################################
class isenPwrSeq1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class isenPwrSeq1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B5, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.isenPwrSeq1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B5, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B5, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B5, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B5, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B5, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B5, self.address, 8, 0, value)
        return(value)

###################################################################
## Isen ADC power change sequence step 2, on
###################################################################
class isenPwrSeq2_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class isenPwrSeq2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B6, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.isenPwrSeq2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B6, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B6, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B6, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B6, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B6, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B6, self.address, 8, 0, value)
        return(value)

###################################################################
## tel ADC power change sequence step 0, off
###################################################################
class telPwrSeq0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telPwrSeq0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B7, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.telPwrSeq0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B7, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B7, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B7, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B7, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B7, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B7, self.address, 8, 0, value)
        return(value)

###################################################################
## tel ADC power change sequence step 1, almost on
###################################################################
class telPwrSeq1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telPwrSeq1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B8, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.telPwrSeq1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B8, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B8, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B8, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B8, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B8, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B8, self.address, 8, 0, value)
        return(value)

###################################################################
## tel ADC power change sequence step 2, on
###################################################################
class telPwrSeq2_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xE9B9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class telPwrSeq2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9B9, None)
            self.digEn = (self.reg_value >> 18) & 0x1
            self.compEn = (self.reg_value >> 17) & 0x1
            self.adcEn = (self.reg_value >> 16) & 0x1
            self.upDelay = (self.reg_value >> 8) & 0xFF
            self.dnDelay = self.reg_value & 0xFF

    def read_object(self):
        return(self.telPwrSeq2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.digEn & 0x1) << 18)
        reg = (reg & 0x5FFFF) + ((register_object.compEn & 0x1) << 17)
        reg = (reg & 0x6FFFF) + ((register_object.adcEn & 0x1) << 16)
        reg = (reg & 0x700FF) + ((register_object.upDelay & 0xFF) << 8)
        reg = (reg & 0x7FF00) + (register_object.dnDelay & 0xFF)
        dma(self.address, 0xE9B9, reg)
    ## enable adc digital
    def digEn(self, value = None):
        value = dma_bits(0xE9B9, self.address, 1, 18, value)
        return(value)
    ## enable adc comparator
    def compEn(self, value = None):
        value = dma_bits(0xE9B9, self.address, 1, 17, value)
        return(value)
    ## enable adc analog
    def adcEn(self, value = None):
        value = dma_bits(0xE9B9, self.address, 1, 16, value)
        return(value)
    ## Delay for turn on
    def upDelay(self, value = None):
        value = dma_bits(0xE9B9, self.address, 8, 8, value)
        return(value)
    ## Delay for turn off
    def dnDelay(self, value = None):
        value = dma_bits(0xE9B9, self.address, 8, 0, value)
        return(value)

###################################################################
## Oscillator power mgt
###################################################################
class oscPwrMgt_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class oscPwrMgt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BA, None)
            self.oscStopHold = (self.reg_value >> 12) & 0xFFF
            self.oscStartHold = self.reg_value & 0xFFF

    def read_object(self):
        return(self.oscPwrMgt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.oscStopHold & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.oscStartHold & 0xFFF)
        dma(self.address, 0xE9BA, reg)
    ## Oscilator should run this many clocks after all need signals fall
    def oscStopHold(self, value = None):
        value = dma_bits(0xE9BA, self.address, 12, 12, value)
        return(value)
    ## Oscillator should run this many clocks when reawakened
    def oscStartHold(self, value = None):
        value = dma_bits(0xE9BA, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 1 register
###################################################################
class phase1AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase1AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BB, None)
            self.add12 = (self.reg_value >> 12) & 0xFFF
            self.drop21 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase1AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add12 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop21 & 0xFFF)
        dma(self.address, 0xE9BB, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add12(self, value = None):
        value = dma_bits(0xE9BB, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop21(self, value = None):
        value = dma_bits(0xE9BB, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 2 register
###################################################################
class phase2AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase2AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BC, None)
            self.add23 = (self.reg_value >> 12) & 0xFFF
            self.drop32 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase2AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add23 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop32 & 0xFFF)
        dma(self.address, 0xE9BC, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add23(self, value = None):
        value = dma_bits(0xE9BC, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop32(self, value = None):
        value = dma_bits(0xE9BC, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 3 register
###################################################################
class phase3AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase3AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BD, None)
            self.add34 = (self.reg_value >> 12) & 0xFFF
            self.drop43 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase3AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add34 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop43 & 0xFFF)
        dma(self.address, 0xE9BD, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add34(self, value = None):
        value = dma_bits(0xE9BD, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop43(self, value = None):
        value = dma_bits(0xE9BD, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 4 register
###################################################################
class phase4AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase4AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BE, None)
            self.add45 = (self.reg_value >> 12) & 0xFFF
            self.drop54 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase4AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add45 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop54 & 0xFFF)
        dma(self.address, 0xE9BE, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add45(self, value = None):
        value = dma_bits(0xE9BE, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop54(self, value = None):
        value = dma_bits(0xE9BE, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 5 register
###################################################################
class phase5AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9BF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase5AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9BF, None)
            self.add56 = (self.reg_value >> 12) & 0xFFF
            self.drop65 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase5AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add56 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop65 & 0xFFF)
        dma(self.address, 0xE9BF, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add56(self, value = None):
        value = dma_bits(0xE9BF, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop65(self, value = None):
        value = dma_bits(0xE9BF, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 6 register
###################################################################
class phase6AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase6AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C0, None)
            self.add67 = (self.reg_value >> 12) & 0xFFF
            self.drop76 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase6AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add67 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop76 & 0xFFF)
        dma(self.address, 0xE9C0, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add67(self, value = None):
        value = dma_bits(0xE9C0, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop76(self, value = None):
        value = dma_bits(0xE9C0, self.address, 12, 0, value)
        return(value)

###################################################################
## Add/Drop table slot 7 register
###################################################################
class phase7AddDrop_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phase7AddDrop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C1, None)
            self.add78 = (self.reg_value >> 12) & 0xFFF
            self.drop87 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.phase7AddDrop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.add78 & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.drop87 & 0xFFF)
        dma(self.address, 0xE9C1, reg)
    ## Add next phase when (total current)/(full-scale for one phase) exceeds this
    def add78(self, value = None):
        value = dma_bits(0xE9C1, self.address, 12, 12, value)
        return(value)
    ## Drop this phase when (total current)/full-scale for one phase) is less than this
    def drop87(self, value = None):
        value = dma_bits(0xE9C1, self.address, 12, 0, value)
        return(value)

###################################################################
## Flexible loop manager interrupt -- define contributors to anded bit
###################################################################
class lmgrIntAnd_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmgrIntAnd_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C2, None)
            self.anded = (self.reg_value >> 31) & 0x1
            self.loopSettled = (self.reg_value >> 29) & 0x1
            self.pwrGd = (self.reg_value >> 28) & 0x1
            self.phEnDisdeactive = (self.reg_value >> 27) & 0x1
            self.goCh = (self.reg_value >> 26) & 0x1
            self.runLoop = (self.reg_value >> 25) & 0x1
            self.bootMode = (self.reg_value >> 24) & 0x1
            self.chPwrOk = (self.reg_value >> 23) & 0x1
            self.sysPwrOk = (self.reg_value >> 22) & 0x1
            self.inputUnderVoltZ = (self.reg_value >> 21) & 0x1
            self.tOffDlyDone = (self.reg_value >> 20) & 0x1
            self.tOnDlyDone = (self.reg_value >> 19) & 0x1
            self.onOffCases = (self.reg_value >> 18) & 0x1
            self.availPhases = (self.reg_value >> 17) & 0x1
            self.shtDwnFltZ = (self.reg_value >> 16) & 0x1
            self.runClocksDel = (self.reg_value >> 15) & 0x1
            self.diagComplete = (self.reg_value >> 14) & 0x1
            self.ps03ExitZ = (self.reg_value >> 13) & 0x1
            self.ps04ExitZ = (self.reg_value >> 12) & 0x1
            self.psExitWaitZ = (self.reg_value >> 11) & 0x1
            self.reEnDelayZ = (self.reg_value >> 10) & 0x1
            self.vidShutDownZ = (self.reg_value >> 9) & 0x1
            self.secOn = (self.reg_value >> 8) & 0x1
            self.priOn = (self.reg_value >> 7) & 0x1
            self.onOffState = self.reg_value & 0x7F

    def read_object(self):
        return(self.lmgrIntAnd_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.anded & 0x1) << 31)
        reg = (reg & 0xDFFFFFFF) + ((register_object.loopSettled & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.pwrGd & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.phEnDisdeactive & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.goCh & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.runLoop & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.bootMode & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.chPwrOk & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.sysPwrOk & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.inputUnderVoltZ & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.tOffDlyDone & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.tOnDlyDone & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.onOffCases & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.availPhases & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.shtDwnFltZ & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.runClocksDel & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.diagComplete & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.ps03ExitZ & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.ps04ExitZ & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.psExitWaitZ & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.reEnDelayZ & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vidShutDownZ & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.secOn & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.priOn & 0x1) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.onOffState & 0x7F)
        dma(self.address, 0xE9C2, reg)
    ## ignored here
    def anded(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 31, value)
        return(value)
    ## Loop settled at target voltage
    def loopSettled(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 29, value)
        return(value)
    ## Power good output bit is on
    def pwrGd(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 28, value)
        return(value)
    ## Phase enable disable signal
    def phEnDisdeactive(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 27, value)
        return(value)
    ## goCh combination signal is high
    def goCh(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 26, value)
        return(value)
    ## loop is regulating
    def runLoop(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 25, value)
        return(value)
    ## In boot mode
    def bootMode(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 24, value)
        return(value)
    ## channel power is up
    def chPwrOk(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 23, value)
        return(value)
    ## MCU set system power OK
    def sysPwrOk(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 22, value)
        return(value)
    ## High if input volt and vddMon volt are high enough
    def inputUnderVoltZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 21, value)
        return(value)
    ## Turn off delay done
    def tOffDlyDone(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 20, value)
        return(value)
    ## Turn on delay done
    def tOnDlyDone(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 19, value)
        return(value)
    ## High if ONOFF configured EN and OPER conditions met for running
    def onOffCases(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 18, value)
        return(value)
    ## This rail has good phases available
    def availPhases(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 17, value)
        return(value)
    ## High if not shut down for fault
    def shtDwnFltZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 16, value)
        return(value)
    ## Clocks running on PLL
    def runClocksDel(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 15, value)
        return(value)
    ## MCU has set mculpc.diagDone
    def diagComplete(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 14, value)
        return(value)
    ## high if not in PS3 or not waiting for PS3 exit
    def ps03ExitZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 13, value)
        return(value)
    ## high if not in PS4 or not waiting for PS4 exit
    def ps04ExitZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 12, value)
        return(value)
    ## high if not waiting for power state exit
    def psExitWaitZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 11, value)
        return(value)
    ## high if not waiting for re-enable delay
    def reEnDelayZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 10, value)
        return(value)
    ## high if not at VID=0 shutdown
    def vidShutDownZ(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 9, value)
        return(value)
    ## Meets secondary turn on conditions
    def secOn(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 8, value)
        return(value)
    ## Meets primary turn on conditions (enable/oper command)
    def priOn(self, value = None):
        value = dma_bits(0xE9C2, self.address, 1, 7, value)
        return(value)
    ## Bits: SETTLE, RAMPDN, ON, PRE, OFF, INIT, RESET
    def onOffState(self, value = None):
        value = dma_bits(0xE9C2, self.address, 7, 0, value)
        return(value)

###################################################################
## Flexible loop manager interrupt -- interrupt on rising edge of these signals
###################################################################
class lmgrIntRE_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmgrIntRE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C3, None)
            self.anded = (self.reg_value >> 31) & 0x1
            self.loopSettled = (self.reg_value >> 29) & 0x1
            self.pwrGd = (self.reg_value >> 28) & 0x1
            self.phEnDisdeactive = (self.reg_value >> 27) & 0x1
            self.goCh = (self.reg_value >> 26) & 0x1
            self.runLoop = (self.reg_value >> 25) & 0x1
            self.bootMode = (self.reg_value >> 24) & 0x1
            self.chPwrOk = (self.reg_value >> 23) & 0x1
            self.sysPwrOk = (self.reg_value >> 22) & 0x1
            self.inputUnderVoltZ = (self.reg_value >> 21) & 0x1
            self.tOffDlyDone = (self.reg_value >> 20) & 0x1
            self.tOnDlyDone = (self.reg_value >> 19) & 0x1
            self.onOffCases = (self.reg_value >> 18) & 0x1
            self.availPhases = (self.reg_value >> 17) & 0x1
            self.shtDwnFltZ = (self.reg_value >> 16) & 0x1
            self.runClocksDel = (self.reg_value >> 15) & 0x1
            self.diagComplete = (self.reg_value >> 14) & 0x1
            self.ps03ExitZ = (self.reg_value >> 13) & 0x1
            self.ps04ExitZ = (self.reg_value >> 12) & 0x1
            self.psExitWaitZ = (self.reg_value >> 11) & 0x1
            self.reEnDelayZ = (self.reg_value >> 10) & 0x1
            self.vidShutDownZ = (self.reg_value >> 9) & 0x1
            self.secOn = (self.reg_value >> 8) & 0x1
            self.priOn = (self.reg_value >> 7) & 0x1
            self.onOffState = self.reg_value & 0x7F

    def read_object(self):
        return(self.lmgrIntRE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.anded & 0x1) << 31)
        reg = (reg & 0xDFFFFFFF) + ((register_object.loopSettled & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.pwrGd & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.phEnDisdeactive & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.goCh & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.runLoop & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.bootMode & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.chPwrOk & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.sysPwrOk & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.inputUnderVoltZ & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.tOffDlyDone & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.tOnDlyDone & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.onOffCases & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.availPhases & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.shtDwnFltZ & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.runClocksDel & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.diagComplete & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.ps03ExitZ & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.ps04ExitZ & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.psExitWaitZ & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.reEnDelayZ & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vidShutDownZ & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.secOn & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.priOn & 0x1) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.onOffState & 0x7F)
        dma(self.address, 0xE9C3, reg)
    ## All of the anded bits have just gone high
    def anded(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 31, value)
        return(value)
    ## Loop settled at target voltage
    def loopSettled(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 29, value)
        return(value)
    ## Power good output bit is on
    def pwrGd(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 28, value)
        return(value)
    ## Phase enable disable signal
    def phEnDisdeactive(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 27, value)
        return(value)
    ## goCh combination signal is high
    def goCh(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 26, value)
        return(value)
    ## loop is regulating
    def runLoop(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 25, value)
        return(value)
    ## In boot mode
    def bootMode(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 24, value)
        return(value)
    ## channel power is up
    def chPwrOk(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 23, value)
        return(value)
    ## MCU set system power OK
    def sysPwrOk(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 22, value)
        return(value)
    ## High if input volt and vddMon volt are high enough
    def inputUnderVoltZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 21, value)
        return(value)
    ## Turn off delay done
    def tOffDlyDone(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 20, value)
        return(value)
    ## Turn on delay done
    def tOnDlyDone(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 19, value)
        return(value)
    ## High if ONOFF configured EN and OPER conditions met for running
    def onOffCases(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 18, value)
        return(value)
    ## This rail has good phases available
    def availPhases(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 17, value)
        return(value)
    ## High if not shut down for fault
    def shtDwnFltZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 16, value)
        return(value)
    ## Clocks running on PLL
    def runClocksDel(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 15, value)
        return(value)
    ## MCU has set mculpc.diagDone
    def diagComplete(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 14, value)
        return(value)
    ## high if not in PS3 or not waiting for PS3 exit
    def ps03ExitZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 13, value)
        return(value)
    ## high if not in PS4 or not waiting for PS4 exit
    def ps04ExitZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 12, value)
        return(value)
    ## high if not waiting for power state exit
    def psExitWaitZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 11, value)
        return(value)
    ## high if not waiting for re-enable delay
    def reEnDelayZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 10, value)
        return(value)
    ## high if not at VID=0 shutdown
    def vidShutDownZ(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 9, value)
        return(value)
    ## Meets secondary turn on conditions
    def secOn(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 8, value)
        return(value)
    ## Meets primary turn on conditions (enable/oper command)
    def priOn(self, value = None):
        value = dma_bits(0xE9C3, self.address, 1, 7, value)
        return(value)
    ## Bits: SETTLE, RAMPDN, ON, PRE, OFF, INIT, RESET
    def onOffState(self, value = None):
        value = dma_bits(0xE9C3, self.address, 7, 0, value)
        return(value)

###################################################################
## Flexible loop manager interrupt -- interrupt on falling edge of these signals
###################################################################
class lmgrIntFE_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmgrIntFE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C4, None)
            self.anded = (self.reg_value >> 31) & 0x1
            self.loopSettled = (self.reg_value >> 29) & 0x1
            self.pwrGd = (self.reg_value >> 28) & 0x1
            self.phEnDisdeactive = (self.reg_value >> 27) & 0x1
            self.goCh = (self.reg_value >> 26) & 0x1
            self.runLoop = (self.reg_value >> 25) & 0x1
            self.bootMode = (self.reg_value >> 24) & 0x1
            self.chPwrOk = (self.reg_value >> 23) & 0x1
            self.sysPwrOk = (self.reg_value >> 22) & 0x1
            self.inputUnderVoltZ = (self.reg_value >> 21) & 0x1
            self.tOffDlyDone = (self.reg_value >> 20) & 0x1
            self.tOnDlyDone = (self.reg_value >> 19) & 0x1
            self.onOffCases = (self.reg_value >> 18) & 0x1
            self.availPhases = (self.reg_value >> 17) & 0x1
            self.shtDwnFltZ = (self.reg_value >> 16) & 0x1
            self.runClocksDel = (self.reg_value >> 15) & 0x1
            self.diagComplete = (self.reg_value >> 14) & 0x1
            self.ps03ExitZ = (self.reg_value >> 13) & 0x1
            self.ps04ExitZ = (self.reg_value >> 12) & 0x1
            self.psExitWaitZ = (self.reg_value >> 11) & 0x1
            self.reEnDelayZ = (self.reg_value >> 10) & 0x1
            self.vidShutDownZ = (self.reg_value >> 9) & 0x1
            self.secOn = (self.reg_value >> 8) & 0x1
            self.priOn = (self.reg_value >> 7) & 0x1
            self.onOffState = self.reg_value & 0x7F

    def read_object(self):
        return(self.lmgrIntFE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.anded & 0x1) << 31)
        reg = (reg & 0xDFFFFFFF) + ((register_object.loopSettled & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.pwrGd & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.phEnDisdeactive & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.goCh & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.runLoop & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.bootMode & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.chPwrOk & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.sysPwrOk & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.inputUnderVoltZ & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.tOffDlyDone & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.tOnDlyDone & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.onOffCases & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.availPhases & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.shtDwnFltZ & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.runClocksDel & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.diagComplete & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.ps03ExitZ & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.ps04ExitZ & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.psExitWaitZ & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.reEnDelayZ & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vidShutDownZ & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.secOn & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.priOn & 0x1) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.onOffState & 0x7F)
        dma(self.address, 0xE9C4, reg)
    ## One of the anded bits has just gone low
    def anded(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 31, value)
        return(value)
    ## Loop settled at target voltage
    def loopSettled(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 29, value)
        return(value)
    ## Power good output bit is on
    def pwrGd(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 28, value)
        return(value)
    ## Phase enable disable signal
    def phEnDisdeactive(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 27, value)
        return(value)
    ## goCh combination signal is high
    def goCh(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 26, value)
        return(value)
    ## loop is regulating
    def runLoop(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 25, value)
        return(value)
    ## In boot mode
    def bootMode(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 24, value)
        return(value)
    ## channel power is up
    def chPwrOk(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 23, value)
        return(value)
    ## MCU set system power OK
    def sysPwrOk(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 22, value)
        return(value)
    ## High if input volt and vddMon volt are high enough
    def inputUnderVoltZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 21, value)
        return(value)
    ## Turn off delay done
    def tOffDlyDone(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 20, value)
        return(value)
    ## Turn on delay done
    def tOnDlyDone(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 19, value)
        return(value)
    ## High if ONOFF configured EN and OPER conditions met for running
    def onOffCases(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 18, value)
        return(value)
    ## This rail has good phases available
    def availPhases(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 17, value)
        return(value)
    ## High if not shut down for fault
    def shtDwnFltZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 16, value)
        return(value)
    ## Clocks running on PLL
    def runClocksDel(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 15, value)
        return(value)
    ## MCU has set mculpc.diagDone
    def diagComplete(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 14, value)
        return(value)
    ## high if not in PS3 or not waiting for PS3 exit
    def ps03ExitZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 13, value)
        return(value)
    ## high if not in PS4 or not waiting for PS4 exit
    def ps04ExitZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 12, value)
        return(value)
    ## high if not waiting for power state exit
    def psExitWaitZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 11, value)
        return(value)
    ## high if not waiting for re-enable delay
    def reEnDelayZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 10, value)
        return(value)
    ## high if not at VID=0 shutdown
    def vidShutDownZ(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 9, value)
        return(value)
    ## Meets secondary turn on conditions
    def secOn(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 8, value)
        return(value)
    ## Meets primary turn on conditions (enable/oper command)
    def priOn(self, value = None):
        value = dma_bits(0xE9C4, self.address, 1, 7, value)
        return(value)
    ## Bits: SETTLE, RAMPDN, ON, PRE, OFF, INIT, RESET
    def onOffState(self, value = None):
        value = dma_bits(0xE9C4, self.address, 7, 0, value)
        return(value)

###################################################################
## See comments in lpf2ndOrderFilter.v for how to program
###################################################################
class compFilt0A_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class compFilt0A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C5, None)
            self.firLen = (self.reg_value >> 30) & 0x3
            self.coefNZ = (self.reg_value >> 24) & 0x3F
            self.coefB1 = (self.reg_value >> 19) & 0x1F
            self.coefA1 = (self.reg_value >> 12) & 0x7F
            self.coefB0 = (self.reg_value >> 7) & 0x1F
            self.coefA0 = self.reg_value & 0x7F

    def read_object(self):
        return(self.compFilt0A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.firLen & 0x3) << 30)
        reg = (reg & 0xC0FFFFFF) + ((register_object.coefNZ & 0x3F) << 24)
        reg = (reg & 0xFF07FFFF) + ((register_object.coefB1 & 0x1F) << 19)
        reg = (reg & 0xFFF80FFF) + ((register_object.coefA1 & 0x7F) << 12)
        reg = (reg & 0xFFFFF07F) + ((register_object.coefB0 & 0x1F) << 7)
        reg = (reg & 0xFFFFFF80) + (register_object.coefA0 & 0x7F)
        dma(self.address, 0xE9C5, reg)
    ## FIR filter length b0-Filt1 z-1  b1-Filt2 z-1  b2-Filt2 z-2
    def firLen(self, value = None):
        value = dma_bits(0xE9C5, self.address, 2, 30, value)
        return(value)
    ## Num zero coef <BR>  NumA = 1 + 0*z^-1 + firLen(0)*z^-2 <BR> NumB = 1 + (Nz)*z^-1 + firLen(1)*z^-2
    def coefNZ(self, value = None):
        value = dma_bits(0xE9C5, self.address, 6, 24, value)
        return(value)
    ## Filt = 1/(1 + Bz^-1 + Az^-2)
    def coefB1(self, value = None):
        value = dma_bits(0xE9C5, self.address, 5, 19, value)
        return(value)
    ## Value should be 0 or negative
    def coefA1(self, value = None):
        value = dma_bits(0xE9C5, self.address, 7, 12, value)
        return(value)
    ## Filt = 1/(1 + Bz^-1 + Az^-2)
    def coefB0(self, value = None):
        value = dma_bits(0xE9C5, self.address, 5, 7, value)
        return(value)
    ## Value should be 0 or negative
    def coefA0(self, value = None):
        value = dma_bits(0xE9C5, self.address, 7, 0, value)
        return(value)

###################################################################
## See comments in lpf2ndOrderFilter.v for how to program
###################################################################
class compFilt0B_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C6, value)
        return(value)


###################################################################
## Fast V-Mode high current non-lilnear load line control for more info see:<BR> \\ausfile1\group\Zilker\Engineering\Mockingbird\Design Docs\MbirdNlllFeatureDescription.pptx <BR> Also see: MBIRD-1971
###################################################################
class hcNlll0_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class hcNlll0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C7, None)
            self.hcLevel = (self.reg_value >> 15) & 0x1FFF
            self.hcShift = (self.reg_value >> 11) & 0xF
            self.hcGain = (self.reg_value >> 7) & 0xF
            self.hcSat = (self.reg_value >> 2) & 0x1F
            self.hcFilt = self.reg_value & 0x3

    def read_object(self):
        return(self.hcNlll0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.hcLevel & 0x1FFF) << 15)
        reg = (reg & 0xFFF87FF) + ((register_object.hcShift & 0xF) << 11)
        reg = (reg & 0xFFFF87F) + ((register_object.hcGain & 0xF) << 7)
        reg = (reg & 0xFFFFF83) + ((register_object.hcSat & 0x1F) << 2)
        reg = (reg & 0xFFFFFFC) + (register_object.hcFilt & 0x3)
        dma(self.address, 0xE9C7, reg)
    ## Current <= which dcDroop=0 subtracts (dcSat/(128.0)*`AFE_IADCRANGE0)Amps from sum current for dc droop
    def hcLevel(self, value = None):
        value = dma_bits(0xE9C7, self.address, 13, 15, value)
        return(value)
    ## Shift for high current non-linear loadline ... <br>To get from hcGain/hcShift to ohms:  <br> Loadine adder above hcLevel in ohms: hcNlll.hcGain*2.0^(hcNlll.hcShift-16.0) * (`AFE_VSENRANGE/`AFE_IADCRANGE0)
    def hcShift(self, value = None):
        value = dma_bits(0xE9C7, self.address, 4, 11, value)
        return(value)
    ## Gain for high current non-linear loadline added to dc Droop beyond the level indicated by dcSat
    def hcGain(self, value = None):
        value = dma_bits(0xE9C7, self.address, 4, 7, value)
        return(value)
    ## Max additional droop voltage subtracted from the loadline due to hcNlll function    LSB is 7.8125mV; max setting of 31 is 242mV; above this limit
    def hcSat(self, value = None):
        value = dma_bits(0xE9C7, self.address, 5, 2, value)
        return(value)
    ## Shift for high current non-linear loadline
    def hcFilt(self, value = None):
        value = dma_bits(0xE9C7, self.address, 2, 0, value)
        return(value)

###################################################################
## See comments in lpf2ndOrderFilter.v for how to program
###################################################################
class compFilt1B_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C8, value)
        return(value)


###################################################################
## Fast V-Mode high current non-lilnear load line control for more info see:<BR> \\ausfile1\group\Zilker\Engineering\Mockingbird\Design Docs\MbirdNlllFeatureDescription.pptx <BR> Also see: MBIRD-1971
###################################################################
class hcNlll1_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE9C9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class hcNlll1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9C9, None)
            self.hcLevel = (self.reg_value >> 15) & 0x1FFF
            self.hcShift = (self.reg_value >> 11) & 0xF
            self.hcGain = (self.reg_value >> 7) & 0xF
            self.hcSat = (self.reg_value >> 2) & 0x1F
            self.hcFilt = self.reg_value & 0x3

    def read_object(self):
        return(self.hcNlll1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.hcLevel & 0x1FFF) << 15)
        reg = (reg & 0xFFF87FF) + ((register_object.hcShift & 0xF) << 11)
        reg = (reg & 0xFFFF87F) + ((register_object.hcGain & 0xF) << 7)
        reg = (reg & 0xFFFFF83) + ((register_object.hcSat & 0x1F) << 2)
        reg = (reg & 0xFFFFFFC) + (register_object.hcFilt & 0x3)
        dma(self.address, 0xE9C9, reg)
    ## Current <= which dcDroop=0 subtracts (dcSat/(128.0)*`AFE_IADCRANGE0)Amps from sum current for dc droop
    def hcLevel(self, value = None):
        value = dma_bits(0xE9C9, self.address, 13, 15, value)
        return(value)
    ## Shift for high current non-linear loadline ... <br>To get from hcGain/hcShift to ohms:  <br> Loadine adder above hcLevel in ohms: hcNlll.hcGain*2.0^(hcNlll.hcShift-16.0) * (`AFE_VSENRANGE/`AFE_IADCRANGE0)
    def hcShift(self, value = None):
        value = dma_bits(0xE9C9, self.address, 4, 11, value)
        return(value)
    ## Gain for high current non-linear loadline added to dc Droop beyond the level indicated by dcSat
    def hcGain(self, value = None):
        value = dma_bits(0xE9C9, self.address, 4, 7, value)
        return(value)
    ## Max additional droop voltage subtracted from the loadline due to hcNlll function    LSB is 7.8125mV; max setting of 31 is 242mV; above this limit
    def hcSat(self, value = None):
        value = dma_bits(0xE9C9, self.address, 5, 2, value)
        return(value)
    ## Shift for high current non-linear loadline
    def hcFilt(self, value = None):
        value = dma_bits(0xE9C9, self.address, 2, 0, value)
        return(value)

###################################################################
## See comments in lpf2ndOrderFilter.v for how to program
###################################################################
class compFilt2B_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CA, value)
        return(value)


###################################################################
## Fast V-Mode high current non-lilnear load line control for more info see:<BR> \\ausfile1\group\Zilker\Engineering\Mockingbird\Design Docs\MbirdNlllFeatureDescription.pptx <BR> Also see: MBIRD-1971
###################################################################
class hcNlll2_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class hcNlll2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9CB, None)
            self.hcLevel = (self.reg_value >> 15) & 0x1FFF
            self.hcShift = (self.reg_value >> 11) & 0xF
            self.hcGain = (self.reg_value >> 7) & 0xF
            self.hcSat = (self.reg_value >> 2) & 0x1F
            self.hcFilt = self.reg_value & 0x3

    def read_object(self):
        return(self.hcNlll2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.hcLevel & 0x1FFF) << 15)
        reg = (reg & 0xFFF87FF) + ((register_object.hcShift & 0xF) << 11)
        reg = (reg & 0xFFFF87F) + ((register_object.hcGain & 0xF) << 7)
        reg = (reg & 0xFFFFF83) + ((register_object.hcSat & 0x1F) << 2)
        reg = (reg & 0xFFFFFFC) + (register_object.hcFilt & 0x3)
        dma(self.address, 0xE9CB, reg)
    ## Current <= which dcDroop=0 subtracts (dcSat/(128.0)*`AFE_IADCRANGE0)Amps from sum current for dc droop
    def hcLevel(self, value = None):
        value = dma_bits(0xE9CB, self.address, 13, 15, value)
        return(value)
    ## Shift for high current non-linear loadline ... <br>To get from hcGain/hcShift to ohms:  <br> Loadine adder above hcLevel in ohms: hcNlll.hcGain*2.0^(hcNlll.hcShift-16.0) * (`AFE_VSENRANGE/`AFE_IADCRANGE0)
    def hcShift(self, value = None):
        value = dma_bits(0xE9CB, self.address, 4, 11, value)
        return(value)
    ## Gain for high current non-linear loadline added to dc Droop beyond the level indicated by dcSat
    def hcGain(self, value = None):
        value = dma_bits(0xE9CB, self.address, 4, 7, value)
        return(value)
    ## Max additional droop voltage subtracted from the loadline due to hcNlll function    LSB is 7.8125mV; max setting of 31 is 242mV; above this limit
    def hcSat(self, value = None):
        value = dma_bits(0xE9CB, self.address, 5, 2, value)
        return(value)
    ## Shift for high current non-linear loadline
    def hcFilt(self, value = None):
        value = dma_bits(0xE9CB, self.address, 2, 0, value)
        return(value)

###################################################################
## See comments in lpf2ndOrderFilter.v for how to program
###################################################################
class compFilt3B_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CC, value)
        return(value)


###################################################################
## Global estimator sequencer configuration
###################################################################
class estSeq_class(object):
    def __init__(self, address):
        self.interface = 'cFiltBus'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estSeq_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9CD, None)
            self.skipDisabled = (self.reg_value >> 16) & 0x1
            self.sel7 = (self.reg_value >> 14) & 0x3
            self.sel6 = (self.reg_value >> 12) & 0x3
            self.sel5 = (self.reg_value >> 10) & 0x3
            self.sel4 = (self.reg_value >> 8) & 0x3
            self.sel3 = (self.reg_value >> 6) & 0x3
            self.sel2 = (self.reg_value >> 4) & 0x3
            self.sel1 = (self.reg_value >> 2) & 0x3
            self.sel0 = self.reg_value & 0x3

    def read_object(self):
        return(self.estSeq_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.skipDisabled & 0x1) << 16)
        reg = (reg & 0x13FFF) + ((register_object.sel7 & 0x3) << 14)
        reg = (reg & 0x1CFFF) + ((register_object.sel6 & 0x3) << 12)
        reg = (reg & 0x1F3FF) + ((register_object.sel5 & 0x3) << 10)
        reg = (reg & 0x1FCFF) + ((register_object.sel4 & 0x3) << 8)
        reg = (reg & 0x1FF3F) + ((register_object.sel3 & 0x3) << 6)
        reg = (reg & 0x1FFCF) + ((register_object.sel2 & 0x3) << 4)
        reg = (reg & 0x1FFF3) + ((register_object.sel1 & 0x3) << 2)
        reg = (reg & 0x1FFFC) + (register_object.sel0 & 0x3)
        dma(self.address, 0xE9CD, reg)
    ## If set, skip disabled phases in sequence
    def skipDisabled(self, value = None):
        value = dma_bits(0xE9CD, self.address, 1, 16, value)
        return(value)
    ## 8th phase selection
    def sel7(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 14, value)
        return(value)
    ## 7th phase selection
    def sel6(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 12, value)
        return(value)
    ## 6th phase selection
    def sel5(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 10, value)
        return(value)
    ## 5th phase selection
    def sel4(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 8, value)
        return(value)
    ## 4th phase selection
    def sel3(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 6, value)
        return(value)
    ## 3rd phase selection
    def sel2(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 4, value)
        return(value)
    ## 2nd phase selection
    def sel1(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 2, value)
        return(value)
    ## 1st phase selection
    def sel0(self, value = None):
        value = dma_bits(0xE9CD, self.address, 2, 0, value)
        return(value)

###################################################################
## Phase association with CSRTN_0
###################################################################
class phAssocRtn0_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CE, value)
        return(value)


###################################################################
## Phase association with CSRTN_1
###################################################################
class phAssocRtn1_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE9CF, value)
        return(value)


###################################################################
## Phase association with internal VCCS
###################################################################
class phAssocRtnInternal_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xE9D0, value)
        return(value)


###################################################################
## Asynchronous Wake Up Source Enable
###################################################################
class asyncWakeCtrl_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xE9D1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class asyncWakeCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9D1, None)
            self.gpioWakeEn = (self.reg_value >> 8) & 0xFF
            self.lp2OovWakeEn = (self.reg_value >> 7) & 0x1
            self.lp1OovWakeEn = (self.reg_value >> 6) & 0x1
            self.lp0OovWakeEn = (self.reg_value >> 5) & 0x1
            self.pmbWakeEn = (self.reg_value >> 4) & 0x1
            self.vddioWakeEn = (self.reg_value >> 3) & 0x1
            self.en2WakeEn = (self.reg_value >> 2) & 0x1
            self.en1WakeEn = (self.reg_value >> 1) & 0x1
            self.en0WakeEn = self.reg_value & 0x1

    def read_object(self):
        return(self.asyncWakeCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.gpioWakeEn & 0xFF) << 8)
        reg = (reg & 0xFF7F) + ((register_object.lp2OovWakeEn & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.lp1OovWakeEn & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.lp0OovWakeEn & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.pmbWakeEn & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.vddioWakeEn & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.en2WakeEn & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.en1WakeEn & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.en0WakeEn & 0x1)
        dma(self.address, 0xE9D1, reg)
    ## Enable GPIO input pin Activity Async wake up (including RESET_L in SVI3 mode)
    def gpioWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 8, 8, value)
        return(value)
    ## Enable Loop2 OOV Async wake up
    def lp2OovWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 7, value)
        return(value)
    ## Enable Loop1 OOV Async wake up
    def lp1OovWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 6, value)
        return(value)
    ## Enable Loop0 OOV Async wake up
    def lp0OovWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 5, value)
        return(value)
    ## Enable PMBus pin activity Async wake up
    def pmbWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 4, value)
        return(value)
    ## Enable Vddio Valid pin comparator Async wake up
    def vddioWakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 3, value)
        return(value)
    ## Enable enable2 pin Async wake up
    def en2WakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 2, value)
        return(value)
    ## Enable enable1 pin Async wake up
    def en1WakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 1, value)
        return(value)
    ## Enable enable0 pin Async wake up
    def en0WakeEn(self, value = None):
        value = dma_bits(0xE9D1, self.address, 1, 0, value)
        return(value)

###################################################################
## Device serial number
###################################################################
class serialNum_class(object):
    def __init__(self, address):
        self.interface = 'lmCfg'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9FF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class serialNum_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9FF, None)
            self.uniqueSerNum = (self.reg_value >> 15) & 0x1FFFF
            self.testYear = (self.reg_value >> 12) & 0x7
            self.testMonth = (self.reg_value >> 8) & 0xF
            self.testDay = (self.reg_value >> 3) & 0x1F
            self.testHour = self.reg_value & 0x7

    def read_object(self):
        return(self.serialNum_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.uniqueSerNum & 0x1FFFF) << 15)
        reg = (reg & 0xFFFF8FFF) + ((register_object.testYear & 0x7) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.testMonth & 0xF) << 8)
        reg = (reg & 0xFFFFFF07) + ((register_object.testDay & 0x1F) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.testHour & 0x7)
        dma(self.address, 0xE9FF, reg)
    ## Unique serial number
    def uniqueSerNum(self, value = None):
        value = dma_bits(0xE9FF, self.address, 17, 15, value)
        return(value)
    ## Test year
    def testYear(self, value = None):
        value = dma_bits(0xE9FF, self.address, 3, 12, value)
        return(value)
    ## Test month
    def testMonth(self, value = None):
        value = dma_bits(0xE9FF, self.address, 4, 8, value)
        return(value)
    ## Test day
    def testDay(self, value = None):
        value = dma_bits(0xE9FF, self.address, 5, 3, value)
        return(value)
    ## Test hour (lower 3 bits)
    def testHour(self, value = None):
        value = dma_bits(0xE9FF, self.address, 3, 0, value)
        return(value)

###################################################################
## Prop/Diff Filter selection and configuration
###################################################################
class compFiltPDSel_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xEA00, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class compFiltPDSel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA00, None)
            self.zeroGt6ph = (self.reg_value >> 12) & 0x1
            self.selGt6ph = (self.reg_value >> 10) & 0x3
            self.zero3to6ph = (self.reg_value >> 9) & 0x1
            self.sel3to6ph = (self.reg_value >> 7) & 0x3
            self.zero2ph = (self.reg_value >> 6) & 0x1
            self.sel2ph = (self.reg_value >> 4) & 0x3
            self.zero1ph = (self.reg_value >> 3) & 0x1
            self.sel1ph = (self.reg_value >> 1) & 0x3
            self.zeroStep = self.reg_value & 0x1

    def read_object(self):
        return(self.compFiltPDSel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.zeroGt6ph & 0x1) << 12)
        reg = (reg & 0x13FF) + ((register_object.selGt6ph & 0x3) << 10)
        reg = (reg & 0x1DFF) + ((register_object.zero3to6ph & 0x1) << 9)
        reg = (reg & 0x1E7F) + ((register_object.sel3to6ph & 0x3) << 7)
        reg = (reg & 0x1FBF) + ((register_object.zero2ph & 0x1) << 6)
        reg = (reg & 0x1FCF) + ((register_object.sel2ph & 0x3) << 4)
        reg = (reg & 0x1FF7) + ((register_object.zero1ph & 0x1) << 3)
        reg = (reg & 0x1FF9) + ((register_object.sel1ph & 0x3) << 1)
        reg = (reg & 0x1FFE) + (register_object.zeroStep & 0x1)
        dma(self.address, 0xEA00, reg)
    ## Select compFiltCoef=0 for numPh >6
    def zeroGt6ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 1, 12, value)
        return(value)
    ## Select compFilt0-3 for numPh >6
    def selGt6ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 2, 10, value)
        return(value)
    ## Select compFiltCoef=0 for numPh 3-6
    def zero3to6ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 1, 9, value)
        return(value)
    ## Select compFilt0-3 for numPh 3-6
    def sel3to6ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 2, 7, value)
        return(value)
    ## Select compFiltCoef=0 for numPh ==2
    def zero2ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 1, 6, value)
        return(value)
    ## Select compFilt0-3 for numPh ==2
    def sel2ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 2, 4, value)
        return(value)
    ## Select compFiltCoef=0 for numPh ==1
    def zero1ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 1, 3, value)
        return(value)
    ## Select compFilt0-3 for numPh ==1
    def sel1ph(self, value = None):
        value = dma_bits(0xEA00, self.address, 2, 1, value)
        return(value)
    ## Zero coeficients before filter change
    def zeroStep(self, value = None):
        value = dma_bits(0xEA00, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class integratorLimits_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA01, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class integratorLimits_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA01, None)
            self.integInMin = (self.reg_value >> 24) & 0xFF
            self.integInMax = (self.reg_value >> 16) & 0xFF
            self.integOutMin = (self.reg_value >> 8) & 0xFF
            self.integOutMax = self.reg_value & 0xFF

    def read_object(self):
        return(self.integratorLimits_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.integInMin & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.integInMax & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.integOutMin & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.integOutMax & 0xFF)
        dma(self.address, 0xEA01, reg)
    ## Limit error voltage into integrator to be >= min
    def integInMin(self, value = None):
        value = dma_bits(0xEA01, self.address, 8, 24, value)
        return(value)
    ## - - - - and < max
    def integInMax(self, value = None):
        value = dma_bits(0xEA01, self.address, 8, 16, value)
        return(value)
    ## Limit integrator output to be >= min
    def integOutMin(self, value = None):
        value = dma_bits(0xEA01, self.address, 8, 8, value)
        return(value)
    ## - - - - and < max
    def integOutMax(self, value = None):
        value = dma_bits(0xEA01, self.address, 8, 0, value)
        return(value)

###################################################################
## Compensator integrator configuration
###################################################################
class integCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEA02, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class integCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA02, None)
            self.ignoreDcm = (self.reg_value >> 22) & 0x1
            self.ignoreDecayEnd = (self.reg_value >> 21) & 0x1
            self.ignoreDecay = (self.reg_value >> 20) & 0x1
            self.integDbgSel = (self.reg_value >> 18) & 0x3
            self.ignorePhChange = (self.reg_value >> 17) & 0x1
            self.divByClkCnt = (self.reg_value >> 16) & 0x1
            self.maxOffAbsThres = (self.reg_value >> 8) & 0xFF
            self.maxOnAbsThres = self.reg_value & 0xFF

    def read_object(self):
        return(self.integCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xBFFFFF) + ((register_object.ignoreDcm & 0x1) << 22)
        reg = (reg & 0xDFFFFF) + ((register_object.ignoreDecayEnd & 0x1) << 21)
        reg = (reg & 0xEFFFFF) + ((register_object.ignoreDecay & 0x1) << 20)
        reg = (reg & 0xF3FFFF) + ((register_object.integDbgSel & 0x3) << 18)
        reg = (reg & 0xFDFFFF) + ((register_object.ignorePhChange & 0x1) << 17)
        reg = (reg & 0xFEFFFF) + ((register_object.divByClkCnt & 0x1) << 16)
        reg = (reg & 0xFF00FF) + ((register_object.maxOffAbsThres & 0xFF) << 8)
        reg = (reg & 0xFFFF00) + (register_object.maxOnAbsThres & 0xFF)
        dma(self.address, 0xEA02, reg)
    ## If set, don't change gains when phases are all in DCM (pwmEn is 0)
    def ignoreDcm(self, value = None):
        value = dma_bits(0xEA02, self.address, 1, 22, value)
        return(value)
    ## If set, don't change gains when decay ends
    def ignoreDecayEnd(self, value = None):
        value = dma_bits(0xEA02, self.address, 1, 21, value)
        return(value)
    ## If set, don't block gain changes during decay
    def ignoreDecay(self, value = None):
        value = dma_bits(0xEA02, self.address, 1, 20, value)
        return(value)
    ## sel what is seen when compI is selected 0-integOut 1-shiftAbsInteg 2-signChange 3-satAbsInteg
    def integDbgSel(self, value = None):
        value = dma_bits(0xEA02, self.address, 2, 18, value)
        return(value)
    ## If set, don't change gains on phase change
    def ignorePhChange(self, value = None):
        value = dma_bits(0xEA02, self.address, 1, 17, value)
        return(value)
    ## If set, dynamically divide integ term by clkCount before comparing to thresholds
    def divByClkCnt(self, value = None):
        value = dma_bits(0xEA02, self.address, 1, 16, value)
        return(value)
    ## Abs value of threshold used to detect end of Integ movement and disable max Integ shift
    def maxOffAbsThres(self, value = None):
        value = dma_bits(0xEA02, self.address, 8, 8, value)
        return(value)
    ## Abs value of threshold used to detect Integ movement and enable max Integ shift
    def maxOnAbsThres(self, value = None):
        value = dma_bits(0xEA02, self.address, 8, 0, value)
        return(value)

###################################################################
## Droop hardware value, scaled by firmware from PMBus DROOP register
###################################################################
class digDroop_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA03, value)
        return(value)


###################################################################
## Pulse advance non-linear curve
###################################################################
class pulseAdvance_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA04, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pulseAdvance_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA04, None)
            self.advGain = (self.reg_value >> 30) & 0x3
            self.advThr = (self.reg_value >> 16) & 0x3FFF
            self.advGain1ph = (self.reg_value >> 14) & 0x3
            self.advThr1ph = self.reg_value & 0x3FFF

    def read_object(self):
        return(self.pulseAdvance_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.advGain & 0x3) << 30)
        reg = (reg & 0xC000FFFF) + ((register_object.advThr & 0x3FFF) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.advGain1ph & 0x3) << 14)
        reg = (reg & 0xFFFFC000) + (register_object.advThr1ph & 0x3FFF)
        dma(self.address, 0xEA04, reg)
    ## Advance gain 2+ phases (0=none, 1=1x, 2=2x, 3=4x)
    def advGain(self, value = None):
        value = dma_bits(0xEA04, self.address, 2, 30, value)
        return(value)
    ## Advance breakpoint 2+ phases (0-1)
    def advThr(self, value = None):
        value = dma_bits(0xEA04, self.address, 14, 16, value)
        return(value)
    ## Advance gain 1 phase (0=none, 1=1x, 2=2x, 3=4x)
    def advGain1ph(self, value = None):
        value = dma_bits(0xEA04, self.address, 2, 14, value)
        return(value)
    ## Advance breakpoint 1 phase (0-1)
    def advThr1ph(self, value = None):
        value = dma_bits(0xEA04, self.address, 14, 0, value)
        return(value)

###################################################################
## Target phase current limits
###################################################################
class targCurr_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA05, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class targCurr_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA05, None)
            self.jTargMax = (self.reg_value >> 16) & 0xFFFF
            self.jTargMin = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.targCurr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.jTargMax & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.jTargMin & 0xFFFF)
        dma(self.address, 0xEA05, reg)
    ## Limit target phase current <= this value (amps/full-scale)
    def jTargMax(self, value = None):
        value = dma_bits(0xEA05, self.address, 16, 16, value)
        return(value)
    ## Limit target phase current >= this value (amps/full-scale)
    def jTargMin(self, value = None):
        value = dma_bits(0xEA05, self.address, 16, 0, value)
        return(value)

###################################################################
## Calculation current limits (amps/full-scale)
###################################################################
class clipCurr_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA06, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class clipCurr_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA06, None)
            self.jClipMin = (self.reg_value >> 16) & 0xFFFF
            self.jClipMax = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.clipCurr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.jClipMin & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.jClipMax & 0xFFFF)
        dma(self.address, 0xEA06, reg)
    ## Calculation lower current limit (amps/full-scale)
    def jClipMin(self, value = None):
        value = dma_bits(0xEA06, self.address, 16, 16, value)
        return(value)
    ## Calculation upper current limit (amps/full-scale)
    def jClipMax(self, value = None):
        value = dma_bits(0xEA06, self.address, 16, 0, value)
        return(value)

###################################################################
## Diode braking configuration 1
###################################################################
class brakeA_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA07, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class brakeA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA07, None)
            self.brakeCurrCnt = (self.reg_value >> 24) & 0xFF
            self.brakeFreqCnt = (self.reg_value >> 16) & 0xFF
            self.useClamp = (self.reg_value >> 15) & 0x1
            self.disableFinePeakOc = (self.reg_value >> 14) & 0x1
            self.brakeCurrFilt = (self.reg_value >> 10) & 0x3
            self.brakeVoltFilt = (self.reg_value >> 8) & 0x3
            self.waitForDvidUpSettle = (self.reg_value >> 7) & 0x1
            self.brakeDoesRecharge = (self.reg_value >> 6) & 0x1
            self.useVerr = (self.reg_value >> 5) & 0x1
            self.mayBrakeIfDem = (self.reg_value >> 4) & 0x1
            self.pwmMayFire = (self.reg_value >> 3) & 0x1
            self.contAnyHigh = (self.reg_value >> 2) & 0x1
            self.startAnyHigh = (self.reg_value >> 1) & 0x1
            self.brakeEn = self.reg_value & 0x1

    def read_object(self):
        return(self.brakeA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.brakeCurrCnt & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.brakeFreqCnt & 0xFF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.useClamp & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.disableFinePeakOc & 0x1) << 14)
        reg = (reg & 0xFFFFF3FF) + ((register_object.brakeCurrFilt & 0x3) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.brakeVoltFilt & 0x3) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.waitForDvidUpSettle & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.brakeDoesRecharge & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.useVerr & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.mayBrakeIfDem & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.pwmMayFire & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.contAnyHigh & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.startAnyHigh & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.brakeEn & 0x1)
        dma(self.address, 0xEA07, reg)
    ## Hold off braking after current rise for this time in clkTs
    def brakeCurrCnt(self, value = None):
        value = dma_bits(0xEA07, self.address, 8, 24, value)
        return(value)
    ## Hold off braking for this long after previous possible voltage trigger, in 4*clkTs
    def brakeFreqCnt(self, value = None):
        value = dma_bits(0xEA07, self.address, 8, 16, value)
        return(value)
    ## Use negative clamp on voltage filter to speed up detection with high freq loads
    def useClamp(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 15, value)
        return(value)
    ## Disable fine time control on peak OC limiting
    def disableFinePeakOc(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 14, value)
        return(value)
    ## Braking current low-pass filter coef 0-3
    def brakeCurrFilt(self, value = None):
        value = dma_bits(0xEA07, self.address, 2, 10, value)
        return(value)
    ## Braking voltage high-pass filter coef 0-3
    def brakeVoltFilt(self, value = None):
        value = dma_bits(0xEA07, self.address, 2, 8, value)
        return(value)
    ## Wait for settling time after Dvid up before braking, if 1 -- uses ovFaultCtrl.upSettleCnt
    def waitForDvidUpSettle(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 7, value)
        return(value)
    ## Diode braking also recharges boot cap if 1
    def brakeDoesRecharge(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 6, value)
        return(value)
    ## Trigger on falls of Verror if 1, or rises in Vout if 0
    def useVerr(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 5, value)
        return(value)
    ## Braking is allowed if in diode-emulation mode (phase count and low-power)
    def mayBrakeIfDem(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 4, value)
        return(value)
    ## PWM may fire during braking if 1
    def pwmMayFire(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 3, value)
        return(value)
    ## Continue braking if any PWM fires if 1
    def contAnyHigh(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 2, value)
        return(value)
    ## Braking may start if any PWM high if 1
    def startAnyHigh(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 1, value)
        return(value)
    ## Enable diode braking if 1
    def brakeEn(self, value = None):
        value = dma_bits(0xEA07, self.address, 1, 0, value)
        return(value)

###################################################################
## Diode braking configuration 2
###################################################################
class brakeB_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 25

    def __call__(self, value = None):
        value = dma(self.address, 0xEA08, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class brakeB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA08, None)
            self.noCurrBal = (self.reg_value >> 24) & 0x1
            self.brakeEnCurr = (self.reg_value >> 16) & 0xFF
            self.brakeStopCurr = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.brakeB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.noCurrBal & 0x1) << 24)
        reg = (reg & 0x100FFFF) + ((register_object.brakeEnCurr & 0xFF) << 16)
        reg = (reg & 0x1FF0000) + (register_object.brakeStopCurr & 0xFFFF)
        dma(self.address, 0xEA08, reg)
    ## Remove current balance feedback for open-loop test if 1, normal = 0
    def noCurrBal(self, value = None):
        value = dma_bits(0xEA08, self.address, 1, 24, value)
        return(value)
    ## Hold off braking when HPF current rise greater than this
    def brakeEnCurr(self, value = None):
        value = dma_bits(0xEA08, self.address, 8, 16, value)
        return(value)
    ## Stop braking phase when its current drops below this
    def brakeStopCurr(self, value = None):
        value = dma_bits(0xEA08, self.address, 16, 0, value)
        return(value)

###################################################################
## Diode braking configuration 3
###################################################################
class brakeC_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA09, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class brakeC_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA09, None)
            self.voutLowThresh = (self.reg_value >> 28) & 0xF
            self.brakeVoltStop = (self.reg_value >> 12) & 0xFFF
            self.brakeVoltStart = self.reg_value & 0xFFF

    def read_object(self):
        return(self.brakeC_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.voutLowThresh & 0xF) << 28)
        reg = (reg & 0xFF000FFF) + ((register_object.brakeVoltStop & 0xFFF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.brakeVoltStart & 0xFFF)
        dma(self.address, 0xEA09, reg)
    ## Disable integrator updates if output voltage below this voltage full-scale
    def voutLowThresh(self, value = None):
        value = dma_bits(0xEA09, self.address, 4, 28, value)
        return(value)
    ## Stop braking if high-pass voltage drops below this voltage (signed)
    def brakeVoltStop(self, value = None):
        value = dma_bits(0xEA09, self.address, 12, 12, value)
        return(value)
    ## Start braking if high-pass voltage rises above this voltage (signed)
    def brakeVoltStart(self, value = None):
        value = dma_bits(0xEA09, self.address, 12, 0, value)
        return(value)

###################################################################
## Diode braking configuration 4
###################################################################
class brakeD_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class brakeD_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0A, None)
            self.lfaVoltStop = (self.reg_value >> 12) & 0xFFF
            self.lfaVoltStart = self.reg_value & 0xFFF

    def read_object(self):
        return(self.brakeD_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.lfaVoltStop & 0xFFF) << 12)
        reg = (reg & 0xFFF000) + (register_object.lfaVoltStart & 0xFFF)
        dma(self.address, 0xEA0A, reg)
    ## Stop LFA load step detector if high-pass voltage drops below this voltage (signed)
    def lfaVoltStop(self, value = None):
        value = dma_bits(0xEA0A, self.address, 12, 12, value)
        return(value)
    ## Trigger LFA load step detector if high-pass voltage rises above this voltage (signed)
    def lfaVoltStart(self, value = None):
        value = dma_bits(0xEA0A, self.address, 12, 0, value)
        return(value)

###################################################################
## Dynamic droop control
###################################################################
class dynDroop_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 30

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dynDroop_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0B, None)
            self.hcNlllEn = (self.reg_value >> 29) & 0x1
            self.largeDroop = (self.reg_value >> 28) & 0x1
            self.dcSatSign = (self.reg_value >> 27) & 0x1
            self.dcSatEn = (self.reg_value >> 26) & 0x1
            self.dcSat = (self.reg_value >> 14) & 0xFFF
            self.manDroopAdj = (self.reg_value >> 5) & 0x1FF
            self.dynCfbShift = (self.reg_value >> 3) & 0x3
            self.useDynCfb = (self.reg_value >> 2) & 0x1
            self.useDynDroop = self.reg_value & 0x3

    def read_object(self):
        return(self.dynDroop_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.hcNlllEn & 0x1) << 29)
        reg = (reg & 0x2FFFFFFF) + ((register_object.largeDroop & 0x1) << 28)
        reg = (reg & 0x37FFFFFF) + ((register_object.dcSatSign & 0x1) << 27)
        reg = (reg & 0x3BFFFFFF) + ((register_object.dcSatEn & 0x1) << 26)
        reg = (reg & 0x3C003FFF) + ((register_object.dcSat & 0xFFF) << 14)
        reg = (reg & 0x3FFFC01F) + ((register_object.manDroopAdj & 0x1FF) << 5)
        reg = (reg & 0x3FFFFFE7) + ((register_object.dynCfbShift & 0x3) << 3)
        reg = (reg & 0x3FFFFFFB) + ((register_object.useDynCfb & 0x1) << 2)
        reg = (reg & 0x3FFFFFFC) + (register_object.useDynDroop & 0x3)
        dma(self.address, 0xEA0B, reg)
    ## dcDroop = jEstSum and additional dcDroop = hcNLLLgain*2^(hcNLLLshift-16) for all jEstSum>dcSat
    def hcNlllEn(self, value = None):
        value = dma_bits(0xEA0B, self.address, 1, 29, value)
        return(value)
    ## Use 8x shift for larger droop gains
    def largeDroop(self, value = None):
        value = dma_bits(0xEA0B, self.address, 1, 28, value)
        return(value)
    def dcSatSign(self, value = None):
        value = dma_bits(0xEA0B, self.address, 1, 27, value)
        return(value)
    ## If set, dcDroop = jEstSum-dcSat (sat at 0) and acDroop = jEstSum sat at dcSat
    def dcSatEn(self, value = None):
        value = dma_bits(0xEA0B, self.address, 1, 26, value)
        return(value)
    ## Current <= which dcDroop=0 subtracts (dcSat/(128.0)*`AFE_IADCRANGE0)Amps from sum current for dc droop
    def dcSat(self, value = None):
        value = dma_bits(0xEA0B, self.address, 12, 14, value)
        return(value)
    ## Manual (firmware) droop scale setting (128=100% of nominal), may be converting droopAdj
    def manDroopAdj(self, value = None):
        value = dma_bits(0xEA0B, self.address, 9, 5, value)
        return(value)
    ## Scale dynamic droop AC current feedback to fade to 0 at 100% / 2^shift
    def dynCfbShift(self, value = None):
        value = dma_bits(0xEA0B, self.address, 2, 3, value)
        return(value)
    ## Use AC feedback at low dynamic droop gains if 1
    def useDynCfb(self, value = None):
        value = dma_bits(0xEA0B, self.address, 1, 2, value)
        return(value)
    ## Enable dynamic droop 0=none, 1=orig Dell LUT, 2=new Dell LUT, 3=manDroopAdj, AMD active 1-3 using standard table
    def useDynDroop(self, value = None):
        value = dma_bits(0xEA0B, self.address, 2, 0, value)
        return(value)

###################################################################
## Fast phase add and trigger control
###################################################################
class fastAddCtrl_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class fastAddCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0C, None)
            self.currLpf1ph = (self.reg_value >> 26) & 0x3
            self.voltHpf1ph = (self.reg_value >> 24) & 0x3
            self.jAddAll = (self.reg_value >> 8) & 0x7FFF
            self.currLpf = (self.reg_value >> 6) & 0x3
            self.voltHpf = (self.reg_value >> 4) & 0x3
            self.enVmode = (self.reg_value >> 2) & 0x1
            self.enAddAll = (self.reg_value >> 1) & 0x1
            self.useIntlvFire = self.reg_value & 0x1

    def read_object(self):
        return(self.fastAddCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFF) + ((register_object.currLpf1ph & 0x3) << 26)
        reg = (reg & 0xCFFFFFF) + ((register_object.voltHpf1ph & 0x3) << 24)
        reg = (reg & 0xF8000FF) + ((register_object.jAddAll & 0x7FFF) << 8)
        reg = (reg & 0xFFFFF3F) + ((register_object.currLpf & 0x3) << 6)
        reg = (reg & 0xFFFFFCF) + ((register_object.voltHpf & 0x3) << 4)
        reg = (reg & 0xFFFFFFB) + ((register_object.enVmode & 0x1) << 2)
        reg = (reg & 0xFFFFFFD) + ((register_object.enAddAll & 0x1) << 1)
        reg = (reg & 0xFFFFFFE) + (register_object.useIntlvFire & 0x1)
        dma(self.address, 0xEA0C, reg)
    ## One phase Current smoothing low-pass filter (0=none,2^-2,2^-4,2^-6)
    def currLpf1ph(self, value = None):
        value = dma_bits(0xEA0C, self.address, 2, 26, value)
        return(value)
    ## One phase Voltage high-pass filter coef (0-3 = 2^-4 to 2^-7)
    def voltHpf1ph(self, value = None):
        value = dma_bits(0xEA0C, self.address, 2, 24, value)
        return(value)
    ## Auto-add all avail phases when per-phase full-scale current is >= this (amps/full-scale)
    def jAddAll(self, value = None):
        value = dma_bits(0xEA0C, self.address, 15, 8, value)
        return(value)
    ## Current smoothing low-pass filter (0=none,2^-2,2^-4,2^-6)
    def currLpf(self, value = None):
        value = dma_bits(0xEA0C, self.address, 2, 6, value)
        return(value)
    ## Voltage high-pass filter coef (0-3 = 2^-4 to 2^-7)
    def voltHpf(self, value = None):
        value = dma_bits(0xEA0C, self.address, 2, 4, value)
        return(value)
    ## Enable voltage-only mode
    def enVmode(self, value = None):
        value = dma_bits(0xEA0C, self.address, 1, 2, value)
        return(value)
    ## Enable fast add all phases
    def enAddAll(self, value = None):
        value = dma_bits(0xEA0C, self.address, 1, 1, value)
        return(value)
    ## Use interleaved firing order (adjacent pairs 180 degrees)
    def useIntlvFire(self, value = None):
        value = dma_bits(0xEA0C, self.address, 1, 0, value)
        return(value)

###################################################################
## Settings for DCM-only modulator mode, single phase
###################################################################
class dcmOnlyCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcmOnlyCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0D, None)
            self.vadcFilt = (self.reg_value >> 28) & 0xF
            self.useVadcIirFilt = (self.reg_value >> 27) & 0x1
            self.useVadcFirFilt = (self.reg_value >> 26) & 0x1
            self.minDcmOnlyCnt = (self.reg_value >> 20) & 0x3F
            self.maxFastCnt = (self.reg_value >> 16) & 0xF
            self.maxLowVoltPulse = (self.reg_value >> 8) & 0xFF
            self.minHiZEntry = self.reg_value & 0xFF

    def read_object(self):
        return(self.dcmOnlyCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.vadcFilt & 0xF) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.useVadcIirFilt & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.useVadcFirFilt & 0x1) << 26)
        reg = (reg & 0xFC0FFFFF) + ((register_object.minDcmOnlyCnt & 0x3F) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.maxFastCnt & 0xF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.maxLowVoltPulse & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.minHiZEntry & 0xFF)
        dma(self.address, 0xEA0D, reg)
    ## Vadc Comp filter coef
    def vadcFilt(self, value = None):
        value = dma_bits(0xEA0D, self.address, 4, 28, value)
        return(value)
    ## Use IIR filter for vAdcComp
    def useVadcIirFilt(self, value = None):
        value = dma_bits(0xEA0D, self.address, 1, 27, value)
        return(value)
    ## Use FIR filter for vAdcComp
    def useVadcFirFilt(self, value = None):
        value = dma_bits(0xEA0D, self.address, 1, 26, value)
        return(value)
    ## Can enter DCM-only mode after this many normal DCM pulses
    def minDcmOnlyCnt(self, value = None):
        value = dma_bits(0xEA0D, self.address, 6, 20, value)
        return(value)
    ## End DCM-only if this many fast pulses occur in a row
    def maxFastCnt(self, value = None):
        value = dma_bits(0xEA0D, self.address, 4, 16, value)
        return(value)
    ## End DCM-only if low voltage comparator activates for this many clocks
    def maxLowVoltPulse(self, value = None):
        value = dma_bits(0xEA0D, self.address, 8, 8, value)
        return(value)
    ## Minimum PWM hiZ time between pulses to enter DCM-only from ripple-reg
    def minHiZEntry(self, value = None):
        value = dma_bits(0xEA0D, self.address, 8, 0, value)
        return(value)

###################################################################
## More Settings for DCM-only modulator mode, single phase
###################################################################
class dcmOnlyCfgB_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcmOnlyCfgB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0E, None)
            self.maxZcdTol = (self.reg_value >> 24) & 0xFF
            self.minZcdTol = (self.reg_value >> 16) & 0xFF
            self.minHiZRecov = (self.reg_value >> 8) & 0xFF
            self.trigHoldoff = self.reg_value & 0xFF

    def read_object(self):
        return(self.dcmOnlyCfgB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.maxZcdTol & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.minZcdTol & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.minHiZRecov & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.trigHoldoff & 0xFF)
        dma(self.address, 0xEA0E, reg)
    ## Late tolerance for zero-cross detector pulses relative to typical time, in clkTs
    def maxZcdTol(self, value = None):
        value = dma_bits(0xEA0E, self.address, 8, 24, value)
        return(value)
    ## Early tolerance for zero-cross detector pulses relative to typical time, in clkTs
    def minZcdTol(self, value = None):
        value = dma_bits(0xEA0E, self.address, 8, 16, value)
        return(value)
    ## Enforced minimum PWM hiZ time for phase current recovery
    def minHiZRecov(self, value = None):
        value = dma_bits(0xEA0E, self.address, 8, 8, value)
        return(value)
    ## Minimum time between comparator pulse triggers (multiphase DCM)
    def trigHoldoff(self, value = None):
        value = dma_bits(0xEA0E, self.address, 8, 0, value)
        return(value)

###################################################################
## Options for power reduction in single-phase at lower power states
###################################################################
class onePhCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA0F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class onePhCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA0F, None)
            self.testVcompFilt = (self.reg_value >> 31) & 0x1
            self.estIoutFilt = (self.reg_value >> 28) & 0x7
            self.estIoutDcmOnly = (self.reg_value >> 27) & 0x1
            self.compFilter = (self.reg_value >> 23) & 0xF
            self.loHiTimeFilter = (self.reg_value >> 21) & 0x3
            self.typInvalCount = (self.reg_value >> 17) & 0xF
            self.typValCount = (self.reg_value >> 13) & 0xF
            self.typHyst = (self.reg_value >> 9) & 0xF
            self.useTypHiTime = (self.reg_value >> 8) & 0x1
            self.forceDcmOnly = (self.reg_value >> 7) & 0x1
            self.ps2OnePhOnly = (self.reg_value >> 6) & 0x1
            self.ps2UseZcd = (self.reg_value >> 5) & 0x1
            self.ps2MultiDcmOnly = (self.reg_value >> 4) & 0x1
            self.ps2DcmOnly = (self.reg_value >> 3) & 0x1
            self.ps3OnePhOnly = (self.reg_value >> 2) & 0x1
            self.ps3UseZcd = (self.reg_value >> 1) & 0x1
            self.ps3DcmOnly = self.reg_value & 0x1

    def read_object(self):
        return(self.onePhCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.testVcompFilt & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.estIoutFilt & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.estIoutDcmOnly & 0x1) << 27)
        reg = (reg & 0xF87FFFFF) + ((register_object.compFilter & 0xF) << 23)
        reg = (reg & 0xFF9FFFFF) + ((register_object.loHiTimeFilter & 0x3) << 21)
        reg = (reg & 0xFFE1FFFF) + ((register_object.typInvalCount & 0xF) << 17)
        reg = (reg & 0xFFFE1FFF) + ((register_object.typValCount & 0xF) << 13)
        reg = (reg & 0xFFFFE1FF) + ((register_object.typHyst & 0xF) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.useTypHiTime & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.forceDcmOnly & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.ps2OnePhOnly & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.ps2UseZcd & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.ps2MultiDcmOnly & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ps2DcmOnly & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ps3OnePhOnly & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.ps3UseZcd & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.ps3DcmOnly & 0x1)
        dma(self.address, 0xEA0F, reg)
    ## Enable vSen Comp Filter in iDcmOnlyCtrl for ATE testing also enables required clocks
    def testVcompFilt(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 31, value)
        return(value)
    ## Filter for estimating Iout -- 2^-(n+2)  Should not be slower than minDcmOnlyCnt
    def estIoutFilt(self, value = None):
        value = dma_bits(0xEA0F, self.address, 3, 28, value)
        return(value)
    ## Estimate Iout for telemetry in DCM only. Does not do droop, since we cannot shift threshold of comparator
    def estIoutDcmOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 27, value)
        return(value)
    ## Sets minimum DCM only comp pulse width to trigger a high pulse
    def compFilter(self, value = None):
        value = dma_bits(0xEA0F, self.address, 4, 23, value)
        return(value)
    ## Set PWM hi/lo time filter rate, used for typHiTime, dcmOnly (0=1/2, 3=1/16)
    def loHiTimeFilter(self, value = None):
        value = dma_bits(0xEA0F, self.address, 2, 21, value)
        return(value)
    ## Stop typical pulse mode if good count drops below this
    def typInvalCount(self, value = None):
        value = dma_bits(0xEA0F, self.address, 4, 17, value)
        return(value)
    ## How many pulses with close widths needed to enter typical pulse mode
    def typValCount(self, value = None):
        value = dma_bits(0xEA0F, self.address, 4, 13, value)
        return(value)
    ## Sets typical pulse hi time +/- tolerance window
    def typHyst(self, value = None):
        value = dma_bits(0xEA0F, self.address, 4, 9, value)
        return(value)
    ## Will try to set high time equal to recent average high time
    def useTypHiTime(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 8, value)
        return(value)
    ## DEBUG -- switches to dcmOnly modulator, COT only, no ripple-reg CCM (very low curr)
    def forceDcmOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 7, value)
        return(value)
    ## In SVID PS2/SVI3 PSI3 drop to one phase and prevent phase adds
    def ps2OnePhOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 6, value)
        return(value)
    ## In SVID PS2/SVI3 PSI3 when in dcmOnly driver does zero-cross detect, low FET control
    def ps2UseZcd(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 5, value)
        return(value)
    ## In SVID PS2/SVI3 PSI3 discontinuous conduction only using all phases
    def ps2MultiDcmOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 4, value)
        return(value)
    ## In SVID PS2/SVI3 PSI3 discontinuous conduction only
    def ps2DcmOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 3, value)
        return(value)
    ## In SVID PS3/SVI3 PSI4 drop to one phase and prevent phase adds
    def ps3OnePhOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 2, value)
        return(value)
    ## In SVID PS3/SVI3 PSI4 when in dcmOnly driver does zero-cross detect, low FET control
    def ps3UseZcd(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 1, value)
        return(value)
    ## In SVID PS3/SVI3 PSI4 discontinuous conduction only
    def ps3DcmOnly(self, value = None):
        value = dma_bits(0xEA0F, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class modCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA10, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class modCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA10, None)
            self.numRapidPulses = (self.reg_value >> 29) & 0x7
            self.useVUnderTarg = (self.reg_value >> 28) & 0x1
            self.useLongEnough = (self.reg_value >> 27) & 0x1
            self.dcmExitHyst = (self.reg_value >> 25) & 0x3
            self.rrSlopeAdj = (self.reg_value >> 20) & 0x1F
            self.rrLossShift = (self.reg_value >> 17) & 0x7
            self.forceLsbVal = (self.reg_value >> 16) & 0x1
            self.forceLsbEn = (self.reg_value >> 15) & 0x1
            self.limAtPeak = (self.reg_value >> 14) & 0x1
            self.negRchEndSel = (self.reg_value >> 13) & 0x1
            self.targLpfShift = (self.reg_value >> 10) & 0x7
            self.useTargLpf = (self.reg_value >> 9) & 0x1
            self.forceDcmEn = (self.reg_value >> 8) & 0x1
            self.noPredRamp = (self.reg_value >> 7) & 0x1
            self.trimOnlyAll = (self.reg_value >> 6) & 0x1
            self.trimOn = (self.reg_value >> 5) & 0x1
            self.allowNegRch = (self.reg_value >> 4) & 0x1
            self.useMinPeak = (self.reg_value >> 3) & 0x1
            self.useMeasPeak = (self.reg_value >> 2) & 0x1
            self.rrEn = (self.reg_value >> 1) & 0x1
            self.forceWidthEn = self.reg_value & 0x1

    def read_object(self):
        return(self.modCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.numRapidPulses & 0x7) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.useVUnderTarg & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.useLongEnough & 0x1) << 27)
        reg = (reg & 0xF9FFFFFF) + ((register_object.dcmExitHyst & 0x3) << 25)
        reg = (reg & 0xFE0FFFFF) + ((register_object.rrSlopeAdj & 0x1F) << 20)
        reg = (reg & 0xFFF1FFFF) + ((register_object.rrLossShift & 0x7) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.forceLsbVal & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.forceLsbEn & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.limAtPeak & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.negRchEndSel & 0x1) << 13)
        reg = (reg & 0xFFFFE3FF) + ((register_object.targLpfShift & 0x7) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.useTargLpf & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.forceDcmEn & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.noPredRamp & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.trimOnlyAll & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.trimOn & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.allowNegRch & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.useMinPeak & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.useMeasPeak & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.rrEn & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.forceWidthEn & 0x1)
        dma(self.address, 0xEA10, reg)
    ## Single-phase CCM -- number of rapid pulses allowed before limiting switch freq via minOffTimeCcm
    def numRapidPulses(self, value = None):
        value = dma_bits(0xEA10, self.address, 3, 29, value)
        return(value)
    ## Single-phase DCM -- Hold off pulse firing if Vout is over target and past normal firing time
    def useVUnderTarg(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 28, value)
        return(value)
    ## Single-phase DCM -- Hold off pulse firing if demand is low (width less than minOn) and past normal firing time
    def useLongEnough(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 27, value)
        return(value)
    ## Make pulse following a DCM pulse more likely to also be DCM by adding 0,25,50,100% extra width threshold
    def dcmExitHyst(self, value = None):
        value = dma_bits(0xEA10, self.address, 2, 25, value)
        return(value)
    ## downslope adjust rate to zero current
    def rrSlopeAdj(self, value = None):
        value = dma_bits(0xEA10, self.address, 5, 20, value)
        return(value)
    ## Loss shift for DC restore rate in rrSynth (larger=slower)
    def rrLossShift(self, value = None):
        value = dma_bits(0xEA10, self.address, 3, 17, value)
        return(value)
    ## DEPRECATED? -- value LSB of delay is set to if forceLsbEn is set
    def forceLsbVal(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 16, value)
        return(value)
    ## DEPRECATED? -- enable setting of LSB of delay to fixed value
    def forceLsbEn(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 15, value)
        return(value)
    ## At very low current, clip ripple reg hi limit at jMinPeak if 1, jMinOn if 0
    def limAtPeak(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 14, value)
        return(value)
    ## End long recharge pulses on min on (0) or min peak (1, pulls down harder)
    def negRchEndSel(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 13, value)
        return(value)
    ## Target low-pass filter time constant exponent -- larger is slower
    def targLpfShift(self, value = None):
        value = dma_bits(0xEA10, self.address, 3, 10, value)
        return(value)
    ## Use a low-pass filtered version of phase-averaged current for target if 1
    def useTargLpf(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 9, value)
        return(value)
    ## Enable fixed DCM operation (jDemCurr hiZ time before end of switch cycle, not counting hi time)
    def forceDcmEn(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 8, value)
        return(value)
    ## Disable ramp on jPred if 1
    def noPredRamp(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 7, value)
        return(value)
    ## Enable trim only when all phases active if 1, always if 0
    def trimOnlyAll(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 6, value)
        return(value)
    ## Enable phase current balance trim if 1, always if 0
    def trimOn(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 5, value)
        return(value)
    ## Allows long recharge pulses to sink current in DCM if 1
    def allowNegRch(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 4, value)
        return(value)
    ## Compute min pulse width in DCM to meet min peak curr if 1, or minOnTime if 0
    def useMinPeak(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 3, value)
        return(value)
    ## Use peak value read in CCM when running in DCM if 1, else try useMinPeak
    def useMeasPeak(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 2, value)
        return(value)
    def rrEn(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 1, value)
        return(value)
    ## Enable fixed with PWM when 1
    def forceWidthEn(self, value = None):
        value = dma_bits(0xEA10, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rrCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA11, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rrCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA11, None)
            self.lfaTol = (self.reg_value >> 29) & 0x7
            self.lfaRate = (self.reg_value >> 26) & 0x7
            self.setDirHi = (self.reg_value >> 25) & 0x1
            self.zeroDis = (self.reg_value >> 24) & 0x1
            self.flipDis = (self.reg_value >> 23) & 0x1
            self.enLFA = (self.reg_value >> 22) & 0x1
            self.usePredFade = (self.reg_value >> 21) & 0x1
            self.useFade = (self.reg_value >> 20) & 0x1
            self.freezeTime = (self.reg_value >> 16) & 0xF
            self.zeroNotValid = (self.reg_value >> 15) & 0x1
            self.lockNotDcm = (self.reg_value >> 14) & 0x1
            self.keepFllLocked = (self.reg_value >> 13) & 0x1
            self.disableFll = (self.reg_value >> 12) & 0x1
            self.largeShift = (self.reg_value >> 9) & 0x7
            self.smallShift = (self.reg_value >> 6) & 0x7
            self.ocRrLim = (self.reg_value >> 3) & 0x7
            self.minSpreadFac = self.reg_value & 0x7

    def read_object(self):
        return(self.rrCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.lfaTol & 0x7) << 29)
        reg = (reg & 0xE3FFFFFF) + ((register_object.lfaRate & 0x7) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.setDirHi & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.zeroDis & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.flipDis & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.enLFA & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.usePredFade & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.useFade & 0x1) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.freezeTime & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.zeroNotValid & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.lockNotDcm & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.keepFllLocked & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.disableFll & 0x1) << 12)
        reg = (reg & 0xFFFFF1FF) + ((register_object.largeShift & 0x7) << 9)
        reg = (reg & 0xFFFFFE3F) + ((register_object.smallShift & 0x7) << 6)
        reg = (reg & 0xFFFFFFC7) + ((register_object.ocRrLim & 0x7) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.minSpreadFac & 0x7)
        dma(self.address, 0xEA11, reg)
    ## Frequency adjustment range (exponent, larger is less change allowed)
    def lfaTol(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 29, value)
        return(value)
    ## Frequency shifting rate (exponent, larger is faster)
    def lfaRate(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 26, value)
        return(value)
    ## Always shift direction of period shift to high (slower)
    def setDirHi(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 25, value)
        return(value)
    ## Disable zeroing of period shift on direction flip
    def zeroDis(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 24, value)
        return(value)
    ## Disable reversal of period shift
    def flipDis(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 23, value)
        return(value)
    ## Enable load frequency avoidance to reduce beat frequencies
    def enLFA(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 22, value)
        return(value)
    ## Fade predOff adjustment in or out in DCM
    def usePredFade(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 21, value)
        return(value)
    ## Fade diode emulation in and out as current changes
    def useFade(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 20, value)
        return(value)
    ## Number of consecutive invalid period cycles before freezing FLL
    def freezeTime(self, value = None):
        value = dma_bits(0xEA11, self.address, 4, 16, value)
        return(value)
    ## When pulse period not valid, decay FLL correction back to zero, use calculated spread
    def zeroNotValid(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 15, value)
        return(value)
    ## Lock FLL when in continuous conduction (not DCM with diode emulation)
    def lockNotDcm(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 14, value)
        return(value)
    ## Lock FLL in all modes
    def keepFllLocked(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 13, value)
        return(value)
    ## Disable the FLL and use the computed window value
    def disableFll(self, value = None):
        value = dma_bits(0xEA11, self.address, 1, 12, value)
        return(value)
    ## Large correction is the current period shifted right by 2+n
    def largeShift(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 9, value)
        return(value)
    ## Small correction is the current period shifted right by 4+n
    def smallShift(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 6, value)
        return(value)
    ## When peak OC limited in ripple-reg mode, set min off time to N/8*swPer, or minOffTime if 0
    def ocRrLim(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 3, value)
        return(value)
    ## Size of minimum current window as a function of Min On Time (+/- this times MinOnTime)
    def minSpreadFac(self, value = None):
        value = dma_bits(0xEA11, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class fllWindow_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA12, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class fllWindow_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA12, None)
            self.vSlowPer = (self.reg_value >> 24) & 0xFF
            self.slowPer = (self.reg_value >> 16) & 0xFF
            self.fastPer = (self.reg_value >> 8) & 0xFF
            self.vFastPer = self.reg_value & 0xFF

    def read_object(self):
        return(self.fllWindow_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.vSlowPer & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slowPer & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.fastPer & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.vFastPer & 0xFF)
        dma(self.address, 0xEA12, reg)
    ## If target - measured period is less than this negative value, apply large correction
    def vSlowPer(self, value = None):
        value = dma_bits(0xEA12, self.address, 8, 24, value)
        return(value)
    ## If target - measured period is less than this negative value, apply small correction
    def slowPer(self, value = None):
        value = dma_bits(0xEA12, self.address, 8, 16, value)
        return(value)
    ## If target - measured period is more than this positive value, apply small correction
    def fastPer(self, value = None):
        value = dma_bits(0xEA12, self.address, 8, 8, value)
        return(value)
    ## If target - measured period is more than this positive value, apply large correction
    def vFastPer(self, value = None):
        value = dma_bits(0xEA12, self.address, 8, 0, value)
        return(value)

###################################################################
## Limit switching too fast for current sense updates
###################################################################
class maxSwPer_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xEA13, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class maxSwPer_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA13, None)
            self.enoughFilt = (self.reg_value >> 8) & 0x3
            self.tooFewFilt = (self.reg_value >> 6) & 0x3
            self.numAllow = (self.reg_value >> 3) & 0x7
            self.minValidCnt = self.reg_value & 0x7

    def read_object(self):
        return(self.maxSwPer_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xCFF) + ((register_object.enoughFilt & 0x3) << 8)
        reg = (reg & 0xF3F) + ((register_object.tooFewFilt & 0x3) << 6)
        reg = (reg & 0xFC7) + ((register_object.numAllow & 0x7) << 3)
        reg = (reg & 0xFF8) + (register_object.minValidCnt & 0x7)
        dma(self.address, 0xEA13, reg)
    ## Rate for decreasing holdoff when more than enough valid samples
    def enoughFilt(self, value = None):
        value = dma_bits(0xEA13, self.address, 2, 8, value)
        return(value)
    ## Rate for increasing holdoff when not enough valid samples
    def tooFewFilt(self, value = None):
        value = dma_bits(0xEA13, self.address, 2, 6, value)
        return(value)
    ## Allow several pulses without enough valid samples before limiting
    def numAllow(self, value = None):
        value = dma_bits(0xEA13, self.address, 3, 3, value)
        return(value)
    ## Minimum number of valid current sense samples per switch cycle for good operation
    def minValidCnt(self, value = None):
        value = dma_bits(0xEA13, self.address, 3, 0, value)
        return(value)

###################################################################
## Calculate peak on time for DCM from normal duty high time
###################################################################
class peakTimeCalc_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 5

    def __call__(self, value = None):
        value = dma(self.address, 0xEA14, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class peakTimeCalc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA14, None)
            self.calcPeakOn = (self.reg_value >> 4) & 0x1
            self.peakOnRatioDuty = self.reg_value & 0xF

    def read_object(self):
        return(self.peakTimeCalc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.calcPeakOn & 0x1) << 4)
        reg = (reg & 0x10) + (register_object.peakOnRatioDuty & 0xF)
        dma(self.address, 0xEA14, reg)
    ## Calculate minPeakOnTime from Vout/Vin*Tsw, replace user setting when 1
    def calcPeakOn(self, value = None):
        value = dma_bits(0xEA14, self.address, 1, 4, value)
        return(value)
    ## Calculated peak on time is duty high time times this scaler 0-1.9x
    def peakOnRatioDuty(self, value = None):
        value = dma_bits(0xEA14, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class minPeakOnTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA15, value)
        return(value)


###################################################################
## 
###################################################################
class minNegTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA16, value)
        return(value)


###################################################################
## 
###################################################################
class minOnTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA17, value)
        return(value)


###################################################################
## 
###################################################################
class maxOnTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA18, value)
        return(value)


###################################################################
## 
###################################################################
class minOffTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA19, value)
        return(value)


###################################################################
## 
###################################################################
class minOffTimeCcm_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1A, value)
        return(value)


###################################################################
## 
###################################################################
class minOffTimeZcd_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1B, value)
        return(value)


###################################################################
## 
###################################################################
class minHiZTime_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1C, value)
        return(value)


###################################################################
## 
###################################################################
class earlyFinish_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1D, value)
        return(value)


###################################################################
## 
###################################################################
class minOnTimeLate_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1E, value)
        return(value)


###################################################################
## 
###################################################################
class phaseTurnOff_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEA1F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phaseTurnOff_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA1F, None)
            self.immedOffFault = (self.reg_value >> 7) & 0x1
            self.phaseOffDelay = (self.reg_value >> 4) & 0x7
            self.longLowTime = self.reg_value & 0x7

    def read_object(self):
        return(self.phaseTurnOff_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.immedOffFault & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.phaseOffDelay & 0x7) << 4)
        reg = (reg & 0xF8) + (register_object.longLowTime & 0x7)
        dma(self.address, 0xEA1F, reg)
    ## PWM shutdown control: [7] immed on fault
    def immedOffFault(self, value = None):
        value = dma_bits(0xEA1F, self.address, 1, 7, value)
        return(value)
    ## PWM shutdown control: [6:4] timeout 2^(8-n) clkTs
    def phaseOffDelay(self, value = None):
        value = dma_bits(0xEA1F, self.address, 3, 4, value)
        return(value)
    ## Low too long count 2^(8-n) clkTs
    def longLowTime(self, value = None):
        value = dma_bits(0xEA1F, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dcrFstSetup_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xEA20, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcrFstSetup_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA20, None)
            self.gainABVal = (self.reg_value >> 16) & 0xF
            self.gainABShift = (self.reg_value >> 12) & 0xF
            self.dcrTcBfrac = (self.reg_value >> 9) & 0x7
            self.dcrTcBshift = (self.reg_value >> 6) & 0x7
            self.dcrTcAfrac = (self.reg_value >> 3) & 0x7
            self.dcrTcAshift = self.reg_value & 0x7

    def read_object(self):
        return(self.dcrFstSetup_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gainABVal & 0xF) << 16)
        reg = (reg & 0xF0FFF) + ((register_object.gainABShift & 0xF) << 12)
        reg = (reg & 0xFF1FF) + ((register_object.dcrTcBfrac & 0x7) << 9)
        reg = (reg & 0xFFE3F) + ((register_object.dcrTcBshift & 0x7) << 6)
        reg = (reg & 0xFFFC7) + ((register_object.dcrTcAfrac & 0x7) << 3)
        reg = (reg & 0xFFFF8) + (register_object.dcrTcAshift & 0x7)
        dma(self.address, 0xEA20, reg)
    ## gain value
    def gainABVal(self, value = None):
        value = dma_bits(0xEA20, self.address, 4, 16, value)
        return(value)
    ## gain shift Val*2^Shift
    def gainABShift(self, value = None):
        value = dma_bits(0xEA20, self.address, 4, 12, value)
        return(value)
    ## time constant frac (8+frac)*2^shift for B (diff=A-B)
    def dcrTcBfrac(self, value = None):
        value = dma_bits(0xEA20, self.address, 3, 9, value)
        return(value)
    ## time constant shift (8+frac)*2^shift for B (diff=A-B)
    def dcrTcBshift(self, value = None):
        value = dma_bits(0xEA20, self.address, 3, 6, value)
        return(value)
    ## time constant frac (8+frac)*2^shift for A (diff=A-B)
    def dcrTcAfrac(self, value = None):
        value = dma_bits(0xEA20, self.address, 3, 3, value)
        return(value)
    ## time constant shift (8+frac)*2^shift for A (diff=A-B)
    def dcrTcAshift(self, value = None):
        value = dma_bits(0xEA20, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dcrSetup_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA21, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcrSetup_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA21, None)
            self.dcrFiltEn = (self.reg_value >> 31) & 0x1
            self.telVal = (self.reg_value >> 26) & 0x1F
            self.telShift = (self.reg_value >> 22) & 0xF
            self.gainCDVal = (self.reg_value >> 18) & 0xF
            self.gainCDShift = (self.reg_value >> 14) & 0xF
            self.dcrTcDfrac = (self.reg_value >> 11) & 0x7
            self.dcrTcDshift = (self.reg_value >> 7) & 0xF
            self.dcrTcCfrac = (self.reg_value >> 4) & 0x7
            self.dcrTcCshift = self.reg_value & 0xF

    def read_object(self):
        return(self.dcrSetup_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.dcrFiltEn & 0x1) << 31)
        reg = (reg & 0x83FFFFFF) + ((register_object.telVal & 0x1F) << 26)
        reg = (reg & 0xFC3FFFFF) + ((register_object.telShift & 0xF) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.gainCDVal & 0xF) << 18)
        reg = (reg & 0xFFFC3FFF) + ((register_object.gainCDShift & 0xF) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.dcrTcDfrac & 0x7) << 11)
        reg = (reg & 0xFFFFF87F) + ((register_object.dcrTcDshift & 0xF) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.dcrTcCfrac & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.dcrTcCshift & 0xF)
        dma(self.address, 0xEA21, reg)
    ## enable DCR TC filter
    def dcrFiltEn(self, value = None):
        value = dma_bits(0xEA21, self.address, 1, 31, value)
        return(value)
    ## gain value
    def telVal(self, value = None):
        value = dma_bits(0xEA21, self.address, 5, 26, value)
        return(value)
    ## gain shift Val*2^Shift
    def telShift(self, value = None):
        value = dma_bits(0xEA21, self.address, 4, 22, value)
        return(value)
    ## gain value  <BR>  For dcSat function, gainCDVal=3 and gainCDShift=12 is equiv to digDroopDac[13:0]=14'h0300
    def gainCDVal(self, value = None):
        value = dma_bits(0xEA21, self.address, 4, 18, value)
        return(value)
    ## gain shift Val*2^Shift
    def gainCDShift(self, value = None):
        value = dma_bits(0xEA21, self.address, 4, 14, value)
        return(value)
    ## time constant frac (8+frac)*2^shift for B (diff=A-B)
    def dcrTcDfrac(self, value = None):
        value = dma_bits(0xEA21, self.address, 3, 11, value)
        return(value)
    ## time constant shift (8+frac)*2^shift for B (diff=A-B) <BR> For dcSat function w/gainCDVal=0, Cshift > Dshift because filter is added before droop multiplier <BR> For dcSat function using gainCDVal, Dshift > Cshift because AC filter is added to negative of multiplied value
    def dcrTcDshift(self, value = None):
        value = dma_bits(0xEA21, self.address, 4, 7, value)
        return(value)
    ## time constant frac (8+frac)*2^shift for A (diff=A-B)
    def dcrTcCfrac(self, value = None):
        value = dma_bits(0xEA21, self.address, 3, 4, value)
        return(value)
    ## time constant shift (8+frac)*2^shift for A (diff=A-B)
    def dcrTcCshift(self, value = None):
        value = dma_bits(0xEA21, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class diodeEmuDelay_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA22, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class diodeEmuDelay_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA22, None)
            self.zcdTrainCnt = (self.reg_value >> 23) & 0x3F
            self.fadeAfterDcmOnly = (self.reg_value >> 22) & 0x1
            self.demStartDelay = (self.reg_value >> 16) & 0x3F
            self.demPropDelay = self.reg_value & 0x7FFF

    def read_object(self):
        return(self.diodeEmuDelay_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xE07FFFFF) + ((register_object.zcdTrainCnt & 0x3F) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.fadeAfterDcmOnly & 0x1) << 22)
        reg = (reg & 0xFFC0FFFF) + ((register_object.demStartDelay & 0x3F) << 16)
        reg = (reg & 0xFFFF8000) + (register_object.demPropDelay & 0x7FFF)
        dma(self.address, 0xEA22, reg)
    ## ZCD pulse width training time in PWM pulses
    def zcdTrainCnt(self, value = None):
        value = dma_bits(0xEA22, self.address, 6, 23, value)
        return(value)
    ## Start DCM fade when ending dcmOnly operation
    def fadeAfterDcmOnly(self, value = None):
        value = dma_bits(0xEA22, self.address, 1, 22, value)
        return(value)
    ## [DEPRECATED] Delay rising SMOD this much after rising PWM
    def demStartDelay(self, value = None):
        value = dma_bits(0xEA22, self.address, 6, 16, value)
        return(value)
    ## Chip + driver delay for diode emulation (signed)
    def demPropDelay(self, value = None):
        value = dma_bits(0xEA22, self.address, 15, 0, value)
        return(value)

###################################################################
## 
###################################################################
class diodeEmulation_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA23, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class diodeEmulation_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA23, None)
            self.dcmFadeCnt = (self.reg_value >> 28) & 0xF
            self.fadeOut = (self.reg_value >> 24) & 0xF
            self.fadeIn = (self.reg_value >> 20) & 0xF
            self.fadeMax = (self.reg_value >> 16) & 0xF
            self.jDemCurr = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.diodeEmulation_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.dcmFadeCnt & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.fadeOut & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.fadeIn & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.fadeMax & 0xF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.jDemCurr & 0xFFFF)
        dma(self.address, 0xEA23, reg)
    ## Hold off of DCM after DVID or high current
    def dcmFadeCnt(self, value = None):
        value = dma_bits(0xEA23, self.address, 4, 28, value)
        return(value)
    ## Diode emulation fade out rate shift when current low, larger is slower NOT REALLY RATIO
    def fadeOut(self, value = None):
        value = dma_bits(0xEA23, self.address, 4, 24, value)
        return(value)
    ## Diode emulation fade in rate shift when current high, larger is slower NOT REALLY RATIO
    def fadeIn(self, value = None):
        value = dma_bits(0xEA23, self.address, 4, 20, value)
        return(value)
    ## Diode emulation maximum fade ratio of predSwing
    def fadeMax(self, value = None):
        value = dma_bits(0xEA23, self.address, 4, 16, value)
        return(value)
    ## Turn off Low Fet when it reaches this full-scale current
    def jDemCurr(self, value = None):
        value = dma_bits(0xEA23, self.address, 16, 0, value)
        return(value)

###################################################################
## PS2 Exit voltage ramp speed up to make up for exit latency delay
###################################################################
class ps2ExitSpeedUp_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEA24, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ps2ExitSpeedUp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA24, None)
            self.zcdStartDly = (self.reg_value >> 19) & 0x1F
            self.speedUpFrac = (self.reg_value >> 16) & 0x7
            self.maxSpeedUpRate = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.ps2ExitSpeedUp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFF) + ((register_object.zcdStartDly & 0x1F) << 19)
        reg = (reg & 0xF8FFFF) + ((register_object.speedUpFrac & 0x7) << 16)
        reg = (reg & 0xFF0000) + (register_object.maxSpeedUpRate & 0xFFFF)
        dma(self.address, 0xEA24, reg)
    ## Startup delay for ZCD in SPS
    def zcdStartDly(self, value = None):
        value = dma_bits(0xEA24, self.address, 5, 19, value)
        return(value)
    ## Increase slew rate by n/8*vrefRate
    def speedUpFrac(self, value = None):
        value = dma_bits(0xEA24, self.address, 3, 16, value)
        return(value)
    ## Max rate with speedUp, use vrefRate without increase if more than this
    def maxSpeedUpRate(self, value = None):
        value = dma_bits(0xEA24, self.address, 16, 0, value)
        return(value)

###################################################################
## Voltage decay rate limiting
###################################################################
class limitedDecay_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA25, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class limitedDecay_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA25, None)
            self.cutOffVolt = (self.reg_value >> 24) & 0xFF
            self.enLimitedDecay = (self.reg_value >> 23) & 0x1
            self.limitMargin = (self.reg_value >> 16) & 0x7F
            self.maxDecayRate = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.limitedDecay_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.cutOffVolt & 0xFF) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.enLimitedDecay & 0x1) << 23)
        reg = (reg & 0xFF80FFFF) + ((register_object.limitMargin & 0x7F) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.maxDecayRate & 0xFFFF)
        dma(self.address, 0xEA25, reg)
    ## Stop active limited decay when sense voltage is below this (4mv LSB)
    def cutOffVolt(self, value = None):
        value = dma_bits(0xEA25, self.address, 8, 24, value)
        return(value)
    ## Enable limited DVID dcay down rate
    def enLimitedDecay(self, value = None):
        value = dma_bits(0xEA25, self.address, 1, 23, value)
        return(value)
    ## Voltage margin for tracking
    def limitMargin(self, value = None):
        value = dma_bits(0xEA25, self.address, 7, 16, value)
        return(value)
    ## Max rate voltage can fall at during decay when limiting enabled
    def maxDecayRate(self, value = None):
        value = dma_bits(0xEA25, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class configLp_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA26, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class configLp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA26, None)
            self.dvidSettleDelay = (self.reg_value >> 29) & 0x3
            self.trackDisable = (self.reg_value >> 28) & 0x1
            self.blendDisable = (self.reg_value >> 27) & 0x1
            self.apdLpf = (self.reg_value >> 24) & 0x7
            self.pwmMaxRate = (self.reg_value >> 20) & 0x7
            self.pwmMaxBank = (self.reg_value >> 16) & 0x7
            self.blockLimitDecay = (self.reg_value >> 15) & 0x1
            self.blockChPwrOk = (self.reg_value >> 14) & 0x1
            self.forceChPwrOk = (self.reg_value >> 13) & 0x1
            self.phRunCnt = (self.reg_value >> 8) & 0x1F
            self.forceLimitDecay = (self.reg_value >> 7) & 0x1
            self.forcePhCnt = (self.reg_value >> 6) & 0x1
            self.blockDecay = (self.reg_value >> 5) & 0x1
            self.forceDecay = (self.reg_value >> 4) & 0x1
            self.blockDem = (self.reg_value >> 3) & 0x1
            self.forceDem = (self.reg_value >> 2) & 0x1
            self.blockRun = (self.reg_value >> 1) & 0x1
            self.forceRun = self.reg_value & 0x1

    def read_object(self):
        return(self.configLp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x9FFFFFFF) + ((register_object.dvidSettleDelay & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.trackDisable & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.blendDisable & 0x1) << 27)
        reg = (reg & 0xF8FFFFFF) + ((register_object.apdLpf & 0x7) << 24)
        reg = (reg & 0xFF8FFFFF) + ((register_object.pwmMaxRate & 0x7) << 20)
        reg = (reg & 0xFFF8FFFF) + ((register_object.pwmMaxBank & 0x7) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.blockLimitDecay & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.blockChPwrOk & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.forceChPwrOk & 0x1) << 13)
        reg = (reg & 0xFFFFE0FF) + ((register_object.phRunCnt & 0x1F) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.forceLimitDecay & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.forcePhCnt & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.blockDecay & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.forceDecay & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.blockDem & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.forceDem & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.blockRun & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.forceRun & 0x1)
        dma(self.address, 0xEA26, reg)
    ## Extra delay in internal ramp to aid down-ramp early settling
    def dvidSettleDelay(self, value = None):
        value = dma_bits(0xEA26, self.address, 2, 29, value)
        return(value)
    ## Disable tracking of Vout when loop disabled if 1
    def trackDisable(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 28, value)
        return(value)
    ## Disable target current blending in 1-phase mode if 1
    def blendDisable(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 27, value)
        return(value)
    ## Low-pass filter exponent for auto phase add/drop current
    def apdLpf(self, value = None):
        value = dma_bits(0xEA26, self.address, 3, 24, value)
        return(value)
    ## Allow this many pulses per Tsw (swPer*Ts)
    def pwmMaxRate(self, value = None):
        value = dma_bits(0xEA26, self.address, 3, 20, value)
        return(value)
    ## Save up this many pulses for burst
    def pwmMaxBank(self, value = None):
        value = dma_bits(0xEA26, self.address, 3, 16, value)
        return(value)
    ## Prevent channel from activating the limitDecay feature during dvid down decay
    def blockLimitDecay(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 15, value)
        return(value)
    ## Prevent channel from starting up pre-bias tracking and OOV if 1
    def blockChPwrOk(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 14, value)
        return(value)
    ## Tell channel clocks and vsen are good for pre-bias and OOV if 1
    def forceChPwrOk(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 13, value)
        return(value)
    ## Number of phase to run, minus 1 (0-7 means 1-8 phases)
    def phRunCnt(self, value = None):
        value = dma_bits(0xEA26, self.address, 5, 8, value)
        return(value)
    ## Force activation of the limitDecay feature during dvid down decay
    def forceLimitDecay(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 7, value)
        return(value)
    ## Override phase count from loopMgr, use phRunCnt below
    def forcePhCnt(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 6, value)
        return(value)
    ## Prevent activation of decay mode during down voltage ramps
    def blockDecay(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 5, value)
        return(value)
    ## Force use of decay mode during down voltage ramps
    def forceDecay(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 4, value)
        return(value)
    ## Prevent activation of discontinuous conduction with diode emulation
    def blockDem(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 3, value)
        return(value)
    ## Force discontinuous conduction with diode emulation in single-phase mode
    def forceDem(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 2, value)
        return(value)
    ## Prevent channel from running regardless of loopMgr (enable/oper)
    def blockRun(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 1, value)
        return(value)
    ## Command channel to run when 1 regardless of loopMgr (enable/oper)
    def forceRun(self, value = None):
        value = dma_bits(0xEA26, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class kPredOff_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA27, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class kPredOff_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA27, None)
            self.kPredOff1ph = (self.reg_value >> 16) & 0xFFFF
            self.kPredOff = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.kPredOff_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.kPredOff1ph & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.kPredOff & 0xFFFF)
        dma(self.address, 0xEA27, reg)
    ## Compensation for 1ph mode, if 0 use the multiphase value
    def kPredOff1ph(self, value = None):
        value = dma_bits(0xEA27, self.address, 16, 16, value)
        return(value)
    ## Predictive ramp compensation offset
    def kPredOff(self, value = None):
        value = dma_bits(0xEA27, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class kiDutyInv_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA28, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class kiDutyInv_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA28, None)
            self.kiDutyInvHi = (self.reg_value >> 16) & 0xFFFF
            self.kiDutyInvLo = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.kiDutyInv_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.kiDutyInvHi & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.kiDutyInvLo & 0xFFFF)
        dma(self.address, 0xEA28, reg)
    ## Inverse inductance voltage 1/(L*dIfs/dTs)
    def kiDutyInvHi(self, value = None):
        value = dma_bits(0xEA28, self.address, 16, 16, value)
        return(value)
    ## Inverse inductance voltage 1/(L*dIfs/dTs)
    def kiDutyInvLo(self, value = None):
        value = dma_bits(0xEA28, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class kDio_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA29, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class kDio_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA29, None)
            self.kRipReg = (self.reg_value >> 16) & 0xFFFF
            self.kDio = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.kDio_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.kRipReg & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.kDio & 0xFFFF)
        dma(self.address, 0xEA29, reg)
    ## Ripple reg initial switch frequency reference adjustment
    def kRipReg(self, value = None):
        value = dma_bits(0xEA29, self.address, 16, 16, value)
        return(value)
    ## Body diode forward-bias current slope
    def kDio(self, value = None):
        value = dma_bits(0xEA29, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estLoss_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estLoss_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2A, None)
            self.iSenSampCntFilt = (self.reg_value >> 29) & 0x7
            self.adjNegStart = (self.reg_value >> 23) & 0x3F
            self.adjNegHiWidth = (self.reg_value >> 15) & 0xFF
            self.adjHiWidth = (self.reg_value >> 7) & 0xFF
            self.lossValue = (self.reg_value >> 3) & 0xF
            self.lossShift = self.reg_value & 0x7

    def read_object(self):
        return(self.estLoss_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.iSenSampCntFilt & 0x7) << 29)
        reg = (reg & 0xE07FFFFF) + ((register_object.adjNegStart & 0x3F) << 23)
        reg = (reg & 0xFF807FFF) + ((register_object.adjNegHiWidth & 0xFF) << 15)
        reg = (reg & 0xFFFF807F) + ((register_object.adjHiWidth & 0xFF) << 7)
        reg = (reg & 0xFFFFFF87) + ((register_object.lossValue & 0xF) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.lossShift & 0x7)
        dma(self.address, 0xEA2A, reg)
    ## Filter coef to apply to the counter used to determine the effective input impedance of the iSen adc <BR> 0:2^6 1:2^8 2:2^9 3:2^10 4:2^11 5:2^12 6:2^13 7:2^14
    def iSenSampCntFilt(self, value = None):
        value = dma_bits(0xEA2A, self.address, 3, 29, value)
        return(value)
    ## threshold to aply negative hi pulse width correction
    def adjNegStart(self, value = None):
        value = dma_bits(0xEA2A, self.address, 6, 23, value)
        return(value)
    ## Adj hi pulse width with Iest Sign
    def adjNegHiWidth(self, value = None):
        value = dma_bits(0xEA2A, self.address, 8, 15, value)
        return(value)
    ## Adj hi pulse width
    def adjHiWidth(self, value = None):
        value = dma_bits(0xEA2A, self.address, 8, 7, value)
        return(value)
    ## loss value
    def lossValue(self, value = None):
        value = dma_bits(0xEA2A, self.address, 4, 3, value)
        return(value)
    ## Inductor current I*R loss
    def lossShift(self, value = None):
        value = dma_bits(0xEA2A, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estSetup_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estSetup_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2B, None)
            self.resetCount = (self.reg_value >> 28) & 0xF
            self.hiSettleCount = (self.reg_value >> 24) & 0xF
            self.dioSettleCount = (self.reg_value >> 20) & 0xF
            self.loSettleCount = (self.reg_value >> 16) & 0xF
            self.selErrCorr = (self.reg_value >> 14) & 0x3
            self.resetCfg = (self.reg_value >> 12) & 0x3
            self.hiSettledCfg = (self.reg_value >> 10) & 0x3
            self.postHiCfg = (self.reg_value >> 8) & 0x3
            self.dioSettleCfg = (self.reg_value >> 6) & 0x3
            self.dioSettledCfg = (self.reg_value >> 4) & 0x3
            self.loSettleCfg = (self.reg_value >> 2) & 0x3
            self.loSettledCfg = self.reg_value & 0x3

    def read_object(self):
        return(self.estSetup_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.resetCount & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.hiSettleCount & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.dioSettleCount & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.loSettleCount & 0xF) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.selErrCorr & 0x3) << 14)
        reg = (reg & 0xFFFFCFFF) + ((register_object.resetCfg & 0x3) << 12)
        reg = (reg & 0xFFFFF3FF) + ((register_object.hiSettledCfg & 0x3) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.postHiCfg & 0x3) << 8)
        reg = (reg & 0xFFFFFF3F) + ((register_object.dioSettleCfg & 0x3) << 6)
        reg = (reg & 0xFFFFFFCF) + ((register_object.dioSettledCfg & 0x3) << 4)
        reg = (reg & 0xFFFFFFF3) + ((register_object.loSettleCfg & 0x3) << 2)
        reg = (reg & 0xFFFFFFFC) + (register_object.loSettledCfg & 0x3)
        dma(self.address, 0xEA2B, reg)
    ## delay after hiPulse to move to hiSettled State
    def resetCount(self, value = None):
        value = dma_bits(0xEA2B, self.address, 4, 28, value)
        return(value)
    ## delay after hiPulse to move to loSettle or dioSettle State
    def hiSettleCount(self, value = None):
        value = dma_bits(0xEA2B, self.address, 4, 24, value)
        return(value)
    ## delay after dioPulse to move to dioSettled State
    def dioSettleCount(self, value = None):
        value = dma_bits(0xEA2B, self.address, 4, 20, value)
        return(value)
    ## delay after loPulse to move to loSettled State
    def loSettleCount(self, value = None):
        value = dma_bits(0xEA2B, self.address, 4, 16, value)
        return(value)
    ## Speed at which to apply offset correction: 0:downSlope 1:downSlope/2 2:downSlope/4 3:No limit
    def selErrCorr(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 14, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def resetCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 12, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def hiSettledCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 10, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def postHiCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 8, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def dioSettleCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 6, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def dioSettledCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 4, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def loSettleCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 2, value)
        return(value)
    ## bit1:updateEstimator bit0:OCdetect
    def loSettledCfg(self, value = None):
        value = dma_bits(0xEA2B, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estFilt_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estFilt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2C, None)
            self.zeroSlope = (self.reg_value >> 25) & 0x1
            self.lossToLastIsen = (self.reg_value >> 24) & 0x1
            self.vClip = (self.reg_value >> 23) & 0x1
            self.offFiltShift = (self.reg_value >> 20) & 0x7
            self.acTransSel = (self.reg_value >> 12) & 0xFF
            self.acDelaySel = (self.reg_value >> 4) & 0xFF
            self.zeroSynthStartup = (self.reg_value >> 3) & 0x1
            self.acLossShift = self.reg_value & 0x7

    def read_object(self):
        return(self.estFilt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFDFFFFFF) + ((register_object.zeroSlope & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.lossToLastIsen & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.vClip & 0x1) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.offFiltShift & 0x7) << 20)
        reg = (reg & 0xFFF00FFF) + ((register_object.acTransSel & 0xFF) << 12)
        reg = (reg & 0xFFFFF00F) + ((register_object.acDelaySel & 0xFF) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.zeroSynthStartup & 0x1) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.acLossShift & 0x7)
        dma(self.address, 0xEA2C, reg)
    ## 25 Set synth output to flat line ... using only offset to track input
    def zeroSlope(self, value = None):
        value = dma_bits(0xEA2C, self.address, 1, 25, value)
        return(value)
    ## 24 if this bit is set, calc loss from difference between iEst and last iSen
    def lossToLastIsen(self, value = None):
        value = dma_bits(0xEA2C, self.address, 1, 24, value)
        return(value)
    ## 23 if set, when adc clip is detected, force valid state in adc so phase is guaranteed to sample again within 4 clkTs
    def vClip(self, value = None):
        value = dma_bits(0xEA2C, self.address, 1, 23, value)
        return(value)
    ## 22:20 Filter setting for offset
    def offFiltShift(self, value = None):
        value = dma_bits(0xEA2C, self.address, 3, 20, value)
        return(value)
    ## 19:12 Delay after iSen is valid to dcEst settings in clkTs
    def acTransSel(self, value = None):
        value = dma_bits(0xEA2C, self.address, 8, 12, value)
        return(value)
    ## 11:4 Delay after iSen is enabled to valid iSen data from SPS in clkTs
    def acDelaySel(self, value = None):
        value = dma_bits(0xEA2C, self.address, 8, 4, value)
        return(value)
    ## 3 If set, use iSen data imediately after phase is enabled
    def zeroSynthStartup(self, value = None):
        value = dma_bits(0xEA2C, self.address, 1, 3, value)
        return(value)
    ## 2:0 lossShift used during acSynth or trans shift
    def acLossShift(self, value = None):
        value = dma_bits(0xEA2C, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estGain_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estGain_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2D, None)
            self.slopeGainI = (self.reg_value >> 28) & 0xF
            self.zeroSlopeInteg = (self.reg_value >> 27) & 0x1
            self.slopeGainIShift = (self.reg_value >> 24) & 0x7
            self.slopeGainP = (self.reg_value >> 20) & 0xF
            self.zeroSlopeErr = (self.reg_value >> 19) & 0x1
            self.slopeGainPShift = (self.reg_value >> 16) & 0x7
            self.offGainI = (self.reg_value >> 12) & 0xF
            self.zeroOffsetInteg = (self.reg_value >> 11) & 0x1
            self.offGainIShift = (self.reg_value >> 8) & 0x7
            self.offGainP = (self.reg_value >> 4) & 0xF
            self.zeroOffsetErr = (self.reg_value >> 3) & 0x1
            self.offGainPShift = self.reg_value & 0x7

    def read_object(self):
        return(self.estGain_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.slopeGainI & 0xF) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.zeroSlopeInteg & 0x1) << 27)
        reg = (reg & 0xF8FFFFFF) + ((register_object.slopeGainIShift & 0x7) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.slopeGainP & 0xF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.zeroSlopeErr & 0x1) << 19)
        reg = (reg & 0xFFF8FFFF) + ((register_object.slopeGainPShift & 0x7) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.offGainI & 0xF) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.zeroOffsetInteg & 0x1) << 11)
        reg = (reg & 0xFFFFF8FF) + ((register_object.offGainIShift & 0x7) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.offGainP & 0xF) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.zeroOffsetErr & 0x1) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.offGainPShift & 0x7)
        dma(self.address, 0xEA2D, reg)
    ## N/A MBIRD UNUSED Estimator slope correction integral gain (times pow2(-GAINISHIFT))
    def slopeGainI(self, value = None):
        value = dma_bits(0xEA2D, self.address, 4, 28, value)
        return(value)
    ## N/A MBIRD UNUSED Zero slope integrator
    def zeroSlopeInteg(self, value = None):
        value = dma_bits(0xEA2D, self.address, 1, 27, value)
        return(value)
    ## AC synth slope correction gain, like loss Integral term
    def slopeGainIShift(self, value = None):
        value = dma_bits(0xEA2D, self.address, 3, 24, value)
        return(value)
    ## N/A MBIRD UNUSED Estimator slope correction proportional gain(times pow2(-GAINPSHIFT))
    def slopeGainP(self, value = None):
        value = dma_bits(0xEA2D, self.address, 4, 20, value)
        return(value)
    ## Zero slope Err
    def zeroSlopeErr(self, value = None):
        value = dma_bits(0xEA2D, self.address, 1, 19, value)
        return(value)
    ## N/A MBIRD UNUSED shift for Pgain
    def slopeGainPShift(self, value = None):
        value = dma_bits(0xEA2D, self.address, 3, 16, value)
        return(value)
    ## Synth Offset Err correction Integral gain
    def offGainI(self, value = None):
        value = dma_bits(0xEA2D, self.address, 4, 12, value)
        return(value)
    ## Offset Integral gain forced to 0
    def zeroOffsetInteg(self, value = None):
        value = dma_bits(0xEA2D, self.address, 1, 11, value)
        return(value)
    ## shift+2 for I gain ... {0,1,2,3,4}=>{4,5,6,7,9} ... {5-7}=>11
    def offGainIShift(self, value = None):
        value = dma_bits(0xEA2D, self.address, 3, 8, value)
        return(value)
    ## Estimator offset correction proportional gain (times pow2(-GAINPSHIFT))
    def offGainP(self, value = None):
        value = dma_bits(0xEA2D, self.address, 4, 4, value)
        return(value)
    ## Zero offset correction error
    def zeroOffsetErr(self, value = None):
        value = dma_bits(0xEA2D, self.address, 1, 3, value)
        return(value)
    ## shift for P gain
    def offGainPShift(self, value = None):
        value = dma_bits(0xEA2D, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estConfig_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estConfig_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2E, None)
            self.pullZeroNoUpd = (self.reg_value >> 29) & 0x7
            self.loSettleAdd = (self.reg_value >> 27) & 0x3
            self.estSlopeRstIir = (self.reg_value >> 26) & 0x1
            self.zeroEstSw = (self.reg_value >> 25) & 0x1
            self.offIntegZZ = (self.reg_value >> 24) & 0x1
            self.forceVinVal = (self.reg_value >> 16) & 0xFF
            self.vinLpForceXduty = (self.reg_value >> 15) & 0x1
            self.vinXdutyFiltSel = (self.reg_value >> 12) & 0x7
            self.winHiCfg = (self.reg_value >> 10) & 0x3
            self.winCfg = (self.reg_value >> 8) & 0x3
            self.intgMaxCount = (self.reg_value >> 6) & 0x3
            self.upSlopeClipI = (self.reg_value >> 5) & 0x1
            self.upSlopeClipSel = (self.reg_value >> 2) & 0x7
            self.slopeClipI = (self.reg_value >> 1) & 0x1
            self.UseHloIfNotLo = self.reg_value & 0x1

    def read_object(self):
        return(self.estConfig_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.pullZeroNoUpd & 0x7) << 29)
        reg = (reg & 0xE7FFFFFF) + ((register_object.loSettleAdd & 0x3) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.estSlopeRstIir & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.zeroEstSw & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.offIntegZZ & 0x1) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.forceVinVal & 0xFF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.vinLpForceXduty & 0x1) << 15)
        reg = (reg & 0xFFFF8FFF) + ((register_object.vinXdutyFiltSel & 0x7) << 12)
        reg = (reg & 0xFFFFF3FF) + ((register_object.winHiCfg & 0x3) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.winCfg & 0x3) << 8)
        reg = (reg & 0xFFFFFF3F) + ((register_object.intgMaxCount & 0x3) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.upSlopeClipI & 0x1) << 5)
        reg = (reg & 0xFFFFFFE3) + ((register_object.upSlopeClipSel & 0x7) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.slopeClipI & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.UseHloIfNotLo & 0x1)
        dma(self.address, 0xEA2E, reg)
    ## 31:29 - Pull to zero when no updates for a while: 0=disable, 1=2.6us 2=5us 3=8 4=10 5=13 6=18, 7=21us
    def pullZeroNoUpd(self, value = None):
        value = dma_bits(0xEA2E, self.address, 3, 29, value)
        return(value)
    ## N/A MBIRD UNUSED 28:27 - Add ramdom extra delay for loSettled - 0=0, 1=0-1, 2=0-3, 3=0-7 extra clkTs
    def loSettleAdd(self, value = None):
        value = dma_bits(0xEA2E, self.address, 2, 27, value)
        return(value)
    ## N/A MBIRD UNUSED 26 - 0:normal (add loss and switch to jEst and jEstNc) 1: only add loss and switch to jEstNC so jEst expect data is flat/lagging
    def estSlopeRstIir(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 26, value)
        return(value)
    ## 25 - 0:normal (add loss and switch to jEst and jEstNc) 1: only add loss and switch to jEstNC so jEst expect data is flat/lagging
    def zeroEstSw(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 25, value)
        return(value)
    ## N/A MBIRD UNUSED 24 - 0:zero offset Integ every sw cycle 1: integrate continuously, can only be used if zeroUpSploeInteg is set
    def offIntegZZ(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 24, value)
        return(value)
    ## 23:16 -value to use to force VIN for loop calulations if vinLpForceXduty is set
    def forceVinVal(self, value = None):
        value = dma_bits(0xEA2E, self.address, 8, 16, value)
        return(value)
    ## 15 -if set ignore VIN data from tel and use forceVinVal[7:0]
    def vinLpForceXduty(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 15, value)
        return(value)
    ## 14:12 -vinXDutyFilt config for vin filtering before xdutyHi calc <BR>  B2-xDutyFilt Enable  B1:0: 0:iirCoef=2  1:iirCoef=4  2:iirCoef=6  3:iirCoef=8
    def vinXdutyFiltSel(self, value = None):
        value = dma_bits(0xEA2E, self.address, 3, 12, value)
        return(value)
    ## 11:10 - Number of valid hiStates required for est offset updates to be valid during hi pulse <BR>Higher numbers ensure that upSlope or hi-Z results don't mix into slope calculations<BR>0:1 clkTs <BR>1:last 2 consecutive clkTs valid hi <BR>2:last 3 consecutive clkTs valid hi <BR>3:last 4 consecutive clkTs valid hi
    def winHiCfg(self, value = None):
        value = dma_bits(0xEA2E, self.address, 2, 10, value)
        return(value)
    ## 9:8 - Number of valid loStates required for slope calc<BR>Higher numbers ensure that upSlope or hi-Z results don't mix into slope calculations<BR>0:1 clkTs <BR>1:last 2 consecutive clkTs valid Lo <BR>2:last 3 consecutive clkTs valid Lo <BR>3:last 4 consecutive clkTs valid Lo
    def winCfg(self, value = None):
        value = dma_bits(0xEA2E, self.address, 2, 8, value)
        return(value)
    ## 7:6 - Max clkTs count after hiFet (in loState) to update integrators/slope: 0:3 1:7 2:15 3:31
    def intgMaxCount(self, value = None):
        value = dma_bits(0xEA2E, self.address, 2, 6, value)
        return(value)
    ## N/A MBIRD UNUSED 5 - Clip upSlope integrator when clip is detected
    def upSlopeClipI(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 5, value)
        return(value)
    ## N/A MBIRD UNUSED 4:2 - Now used for ignore count variation during emulation...only loop0/ch0
    def upSlopeClipSel(self, value = None):
        value = dma_bits(0xEA2E, self.address, 3, 2, value)
        return(value)
    ## N/A MBIRD UNUSED 1 -Integ clip selection: 0:Don't sat Integ when clip detected 1:Sat integ when clip detected
    def slopeClipI(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 1, value)
        return(value)
    ## N/A MBIRD UNUSED 0 -if this bit is set, use the Hlo value from synth for offset updates
    def UseHloIfNotLo(self, value = None):
        value = dma_bits(0xEA2E, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estOffset_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA2F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estOffset_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA2F, None)
            self.delay = (self.reg_value >> 29) & 0x7
            self.slopeOffVal = (self.reg_value >> 19) & 0x3FF
            self.estOffHiAdj = (self.reg_value >> 8) & 0x7FF
            self.estOffFineAdj = self.reg_value & 0xFF

    def read_object(self):
        return(self.estOffset_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.delay & 0x7) << 29)
        reg = (reg & 0xE007FFFF) + ((register_object.slopeOffVal & 0x3FF) << 19)
        reg = (reg & 0xFFF800FF) + ((register_object.estOffHiAdj & 0x7FF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.estOffFineAdj & 0xFF)
        dma(self.address, 0xEA2F, reg)
    ## N/A MBIRD UNUSED 31:29 - Skew between estimator and sense currents
    def delay(self, value = None):
        value = dma_bits(0xEA2F, self.address, 3, 29, value)
        return(value)
    ## 28:19 - Change estimator slope by multiplying xDutyLo2iFs by this with s6.7 format so +/-0.25 Lo slope adjust possible
    def slopeOffVal(self, value = None):
        value = dma_bits(0xEA2F, self.address, 10, 19, value)
        return(value)
    ## 18:8 - fine Offset adjustment used during hiValid state
    def estOffHiAdj(self, value = None):
        value = dma_bits(0xEA2F, self.address, 11, 8, value)
        return(value)
    ## 7:0 - Fine adjust of iEst Delay s8.5 => +3.98:-4 downSlope clkTs
    def estOffFineAdj(self, value = None):
        value = dma_bits(0xEA2F, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class vAdcComp_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA30, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vAdcComp_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA30, None)
            self.slopeClipAddShift = (self.reg_value >> 26) & 0x3
            self.noiseLevel = (self.reg_value >> 23) & 0x7
            self.eslFiltShift = (self.reg_value >> 21) & 0x3
            self.eslGain = (self.reg_value >> 16) & 0x1F
            self.eslResetTran = (self.reg_value >> 15) & 0x1
            self.eslDelSel = (self.reg_value >> 12) & 0x7
            self.bypassStep = (self.reg_value >> 8) & 0xF
            self.linearStep = (self.reg_value >> 4) & 0xF
            self.maxPhEslEn = self.reg_value & 0xF

    def read_object(self):
        return(self.vAdcComp_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF3FFFFFF) + ((register_object.slopeClipAddShift & 0x3) << 26)
        reg = (reg & 0xFC7FFFFF) + ((register_object.noiseLevel & 0x7) << 23)
        reg = (reg & 0xFF9FFFFF) + ((register_object.eslFiltShift & 0x3) << 21)
        reg = (reg & 0xFFE0FFFF) + ((register_object.eslGain & 0x1F) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.eslResetTran & 0x1) << 15)
        reg = (reg & 0xFFFF8FFF) + ((register_object.eslDelSel & 0x7) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.bypassStep & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.linearStep & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.maxPhEslEn & 0xF)
        dma(self.address, 0xEA30, reg)
    ## 27:26  0:no shift  1:shift Add >>1   2: shift Add>>3   3: Add=1 LSB when DVID settled
    def slopeClipAddShift(self, value = None):
        value = dma_bits(0xEA30, self.address, 2, 26, value)
        return(value)
    ## N/A MBIRD UNUSED 25:23 noise 0:0 1:4 2:8 3:16 4:32 5:64 6:128 7:256->8bits of LFSR
    def noiseLevel(self, value = None):
        value = dma_bits(0xEA30, self.address, 3, 23, value)
        return(value)
    ## N/A MBIRD UNUSED 22:21 time constant for peak detect filter
    def eslFiltShift(self, value = None):
        value = dma_bits(0xEA30, self.address, 2, 21, value)
        return(value)
    ## N/A MBIRD UNUSED 20:16 esl compensation gain
    def eslGain(self, value = None):
        value = dma_bits(0xEA30, self.address, 5, 16, value)
        return(value)
    ## N/A MBIRD UNUSED 15 esl reset on hi2lo
    def eslResetTran(self, value = None):
        value = dma_bits(0xEA30, self.address, 1, 15, value)
        return(value)
    ## N/A MBIRD UNUSED 14:12 delay from PWM to vAdc in clkTs
    def eslDelSel(self, value = None):
        value = dma_bits(0xEA30, self.address, 3, 12, value)
        return(value)
    ## N/A MBIRD UNUSED 11:8 max value to bypass slew filter
    def bypassStep(self, value = None):
        value = dma_bits(0xEA30, self.address, 4, 8, value)
        return(value)
    ## N/A MBIRD UNUSED 7:4 max value to use ADC results directly
    def linearStep(self, value = None):
        value = dma_bits(0xEA30, self.address, 4, 4, value)
        return(value)
    ## N/A MBIRD UNUSED 3:0 number of phases equal or below which to enable Esl logic 0:not enabled
    def maxPhEslEn(self, value = None):
        value = dma_bits(0xEA30, self.address, 4, 0, value)
        return(value)

###################################################################
## Control voltage trigger threshold used in DCM with useVUnder on
###################################################################
class vTrigDcm_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 25

    def __call__(self, value = None):
        value = dma(self.address, 0xEA31, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vTrigDcm_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA31, None)
            self.useVtrigInteg = (self.reg_value >> 24) & 0x1
            self.vTrigIntegGain = (self.reg_value >> 20) & 0xF
            self.negPulseOffset = (self.reg_value >> 10) & 0x3FF
            self.vTrigOffset = self.reg_value & 0x3FF

    def read_object(self):
        return(self.vTrigDcm_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.useVtrigInteg & 0x1) << 24)
        reg = (reg & 0x10FFFFF) + ((register_object.vTrigIntegGain & 0xF) << 20)
        reg = (reg & 0x1F003FF) + ((register_object.negPulseOffset & 0x3FF) << 10)
        reg = (reg & 0x1FFFC00) + (register_object.vTrigOffset & 0x3FF)
        dma(self.address, 0xEA31, reg)
    ## 23 Use the DCM integrator to adjust trigger voltage
    def useVtrigInteg(self, value = None):
        value = dma_bits(0xEA31, self.address, 1, 24, value)
        return(value)
    ## 22:19 Trigger voltage integrator gain shift (large value is slower, lower gain)
    def vTrigIntegGain(self, value = None):
        value = dma_bits(0xEA31, self.address, 4, 20, value)
        return(value)
    ## 18:10 End negative pulse this much above target voltage
    def negPulseOffset(self, value = None):
        value = dma_bits(0xEA31, self.address, 10, 10, value)
        return(value)
    ## 9:0 Trigger voltage offset from target voltage plus integrator (if used)
    def vTrigOffset(self, value = None):
        value = dma_bits(0xEA31, self.address, 10, 0, value)
        return(value)

###################################################################
## Modulator zero crossing slope method, ripple regulation
###################################################################
class rampCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA32, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rampCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA32, None)
            self.dvidRatio = (self.reg_value >> 16) & 0xFFFF
            self.vinLpPreShift = (self.reg_value >> 12) & 0x7
            self.calcFracFilt = (self.reg_value >> 8) & 0xF
            self.softStart = (self.reg_value >> 5) & 0x7
            self.useMeasWidthSlope = (self.reg_value >> 4) & 0x1
            self.resetOnAddDrop = (self.reg_value >> 3) & 0x1
            self.useMeasAvail = (self.reg_value >> 2) & 0x1
            self.useCorrEst = (self.reg_value >> 1) & 0x1
            self.enMeasSlope = self.reg_value & 0x1

    def read_object(self):
        return(self.rampCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.dvidRatio & 0xFFFF) << 16)
        reg = (reg & 0xFFFF8FFF) + ((register_object.vinLpPreShift & 0x7) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.calcFracFilt & 0xF) << 8)
        reg = (reg & 0xFFFFFF1F) + ((register_object.softStart & 0x7) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.useMeasWidthSlope & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.resetOnAddDrop & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.useMeasAvail & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useCorrEst & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.enMeasSlope & 0x1)
        dma(self.address, 0xEA32, reg)
    ## 31:16 FPGA ONLY Scale factor to apply to DVID rate from 10uv/us to Vfs/clkTs
    def dvidRatio(self, value = None):
        value = dma_bits(0xEA32, self.address, 16, 16, value)
        return(value)
    ## 14:12 Shift scaled UTC Vin data for xDutyHi calc left 0-4
    def vinLpPreShift(self, value = None):
        value = dma_bits(0xEA32, self.address, 3, 12, value)
        return(value)
    ## 11:8 Filter value for zero crossing slope
    def calcFracFilt(self, value = None):
        value = dma_bits(0xEA32, self.address, 4, 8, value)
        return(value)
    ## 7:5 Ramp up maxOnTime after channel enable, takes 2^(n+6) clkTs
    def softStart(self, value = None):
        value = dma_bits(0xEA32, self.address, 3, 5, value)
        return(value)
    ## 4 Use measured slope to compute jMinOnTime, etc
    def useMeasWidthSlope(self, value = None):
        value = dma_bits(0xEA32, self.address, 1, 4, value)
        return(value)
    ## 3 Reset slope filt with expWidthSlope on phase add/drop
    def resetOnAddDrop(self, value = None):
        value = dma_bits(0xEA32, self.address, 1, 3, value)
        return(value)
    ## 2 Use meas slope for Avail
    def useMeasAvail(self, value = None):
        value = dma_bits(0xEA32, self.address, 1, 2, value)
        return(value)
    ## 1 use corrected current for diode emulation
    def useCorrEst(self, value = None):
        value = dma_bits(0xEA32, self.address, 1, 1, value)
        return(value)
    ## 0 use measured slope for zero crossing in modulator
    def enMeasSlope(self, value = None):
        value = dma_bits(0xEA32, self.address, 1, 0, value)
        return(value)

###################################################################
## Input Current Estimator Configuration and Up-slope FIR filter
###################################################################
class iInEstCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA33, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iInEstCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA33, None)
            self.minPeriod = (self.reg_value >> 29) & 0x7
            self.estUpFirDepth = (self.reg_value >> 26) & 0x7
            self.offsetIadjMax = (self.reg_value >> 24) & 0x3
            self.iInOffset = (self.reg_value >> 8) & 0xFFFF
            self.widthSkew = self.reg_value & 0xFF

    def read_object(self):
        return(self.iInEstCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.minPeriod & 0x7) << 29)
        reg = (reg & 0xE3FFFFFF) + ((register_object.estUpFirDepth & 0x7) << 26)
        reg = (reg & 0xFCFFFFFF) + ((register_object.offsetIadjMax & 0x3) << 24)
        reg = (reg & 0xFF0000FF) + ((register_object.iInOffset & 0xFFFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.widthSkew & 0xFF)
        dma(self.address, 0xEA33, reg)
    ## Number of counts required before each phase can be sampled again. 0-No Limit ... 7 means max samp rate =clkTs/8
    def minPeriod(self, value = None):
        value = dma_bits(0xEA33, self.address, 3, 29, value)
        return(value)
    ## N/A MBIRD UNUSED FIR depth of UpSlope FIR filter 0=1 1=2 2=4 3=8 4=16 5/6/7=Avg number of downSlope counts (for tracking non expected inputs like DC)
    def estUpFirDepth(self, value = None):
        value = dma_bits(0xEA33, self.address, 3, 26, value)
        return(value)
    ## Max downslope adjustment for offset integrator 0=1/2, 1=1x, 2=2x, 3=no limit
    def offsetIadjMax(self, value = None):
        value = dma_bits(0xEA33, self.address, 2, 24, value)
        return(value)
    ## [Deprecated] Input current estimate offset, fraction of Isense full scale range
    def iInOffset(self, value = None):
        value = dma_bits(0xEA33, self.address, 16, 8, value)
        return(value)
    ## Actual PWM high time is greater than calculated by twice this
    def widthSkew(self, value = None):
        value = dma_bits(0xEA33, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class estFault_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA34, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class estFault_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA34, None)
            self.slopeClipHiLim = (self.reg_value >> 26) & 0x3F
            self.slopeClipLoLim = (self.reg_value >> 20) & 0x3F
            self.slopeClipAdd = (self.reg_value >> 18) & 0x3
            self.resetSlopeV2Low = (self.reg_value >> 17) & 0x1
            self.maskErrToZero = (self.reg_value >> 16) & 0x1
            self.ocTrackingLimit = (self.reg_value >> 8) & 0xFF
            self.ucTrackingLimit = self.reg_value & 0xFF

    def read_object(self):
        return(self.estFault_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFF) + ((register_object.slopeClipHiLim & 0x3F) << 26)
        reg = (reg & 0xFC0FFFFF) + ((register_object.slopeClipLoLim & 0x3F) << 20)
        reg = (reg & 0xFFF3FFFF) + ((register_object.slopeClipAdd & 0x3) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.resetSlopeV2Low & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.maskErrToZero & 0x1) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.ocTrackingLimit & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.ucTrackingLimit & 0xFF)
        dma(self.address, 0xEA34, reg)
    ## 1-15.75x  Effective calc loSlope Hi limit (shorted inductor limit) relative to xDutyLo:<BR>Examples: 4: 1x  6:1.5x  8:2x 62:15.5x 63: Saturate(no limit/not reltative to xDutlyLo)
    def slopeClipHiLim(self, value = None):
        value = dma_bits(0xEA34, self.address, 6, 26, value)
        return(value)
    ## 0-0.984  Effective calc loSlope Lo limit relative to xDutyLo:<BR>Examples 0:Saturate(no limit/not relative to xDutyLo) 1:0.15625x 16:0.25x 32:0.5x 48:0.75x 63:0.98475x
    def slopeClipLoLim(self, value = None):
        value = dma_bits(0xEA34, self.address, 6, 20, value)
        return(value)
    ## constant to add to hiLim and sub from Lo limit to ensure no false faults near zero
    def slopeClipAdd(self, value = None):
        value = dma_bits(0xEA34, self.address, 2, 18, value)
        return(value)
    ## reset down slope integrator if voltage is too low
    def resetSlopeV2Low(self, value = None):
        value = dma_bits(0xEA34, self.address, 1, 17, value)
        return(value)
    ## mask errors where iSense is closer to zero than iEst
    def maskErrToZero(self, value = None):
        value = dma_bits(0xEA34, self.address, 1, 16, value)
        return(value)
    ## oc tracking fault limit
    def ocTrackingLimit(self, value = None):
        value = dma_bits(0xEA34, self.address, 8, 8, value)
        return(value)
    ## uc tracking fault limit
    def ucTrackingLimit(self, value = None):
        value = dma_bits(0xEA34, self.address, 8, 0, value)
        return(value)

###################################################################
## Bulk capacitor RLC model gain factor, including I*Rdroop scaling
###################################################################
class rampCompBulkA_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA35, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rampCompBulkA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA35, None)
            self.earlyEndDecay = (self.reg_value >> 28) & 0xF
            self.earlyEndDn = (self.reg_value >> 24) & 0xF
            self.earlyEndUp = (self.reg_value >> 20) & 0xF
            self.bulkA1DownShift = (self.reg_value >> 18) & 0x3
            self.bulkA1Down = (self.reg_value >> 10) & 0xFF
            self.bulkA1Shift = (self.reg_value >> 8) & 0x3
            self.bulkA1 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rampCompBulkA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.earlyEndDecay & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.earlyEndDn & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.earlyEndUp & 0xF) << 20)
        reg = (reg & 0xFFF3FFFF) + ((register_object.bulkA1DownShift & 0x3) << 18)
        reg = (reg & 0xFFFC03FF) + ((register_object.bulkA1Down & 0xFF) << 10)
        reg = (reg & 0xFFFFFCFF) + ((register_object.bulkA1Shift & 0x3) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.bulkA1 & 0xFF)
        dma(self.address, 0xEA35, reg)
    ## Adjustment to end DVID Decay Down compensation early, in clkTs*4
    def earlyEndDecay(self, value = None):
        value = dma_bits(0xEA35, self.address, 4, 28, value)
        return(value)
    ## Adjustment to end DVID Down compensation early, in clkTs*4
    def earlyEndDn(self, value = None):
        value = dma_bits(0xEA35, self.address, 4, 24, value)
        return(value)
    ## Adjustment to end DVID Up compensation early, in clkTs*4
    def earlyEndUp(self, value = None):
        value = dma_bits(0xEA35, self.address, 4, 20, value)
        return(value)
    ## RCBulk cap down gain = RCBULKA1DOWN * 2^(RCBULKA1DOWNSHIFT)
    def bulkA1DownShift(self, value = None):
        value = dma_bits(0xEA35, self.address, 2, 18, value)
        return(value)
    ## RCBulk cap down gain = RCBULKA1DOWN * 2^(RCBULKA1DOWNSHIFT)
    def bulkA1Down(self, value = None):
        value = dma_bits(0xEA35, self.address, 8, 10, value)
        return(value)
    ## RCBulk cap up gain = RCBULKA1 * 2^(RCBULKA1SHIFT)
    def bulkA1Shift(self, value = None):
        value = dma_bits(0xEA35, self.address, 2, 8, value)
        return(value)
    ## Bulk capacitor RLC model gain factor, including I*Rdroop scaling
    def bulkA1(self, value = None):
        value = dma_bits(0xEA35, self.address, 8, 0, value)
        return(value)

###################################################################
## Bulk capacitor RLC model gain factor, including I*Rdroop scaling
###################################################################
class rampCompBulkB_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xEA36, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rampCompBulkB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA36, None)
            self.bulkNorm = (self.reg_value >> 20) & 0x3
            self.bulkA2 = (self.reg_value >> 10) & 0x3FF
            self.bulkA3 = self.reg_value & 0x3FF

    def read_object(self):
        return(self.rampCompBulkB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.bulkNorm & 0x3) << 20)
        reg = (reg & 0x3003FF) + ((register_object.bulkA2 & 0x3FF) << 10)
        reg = (reg & 0x3FFC00) + (register_object.bulkA3 & 0x3FF)
        dma(self.address, 0xEA36, reg)
    ## Bulk capacitor RLC model overflow avoidance shift
    def bulkNorm(self, value = None):
        value = dma_bits(0xEA36, self.address, 2, 20, value)
        return(value)
    ## Bulk capacitor RLC model coefficient z^-1
    def bulkA2(self, value = None):
        value = dma_bits(0xEA36, self.address, 10, 10, value)
        return(value)
    ## Bulk capacitor RLC model coefficient z^-2
    def bulkA3(self, value = None):
        value = dma_bits(0xEA36, self.address, 10, 0, value)
        return(value)

###################################################################
## Cer capacitor RC model gain factor, including I*Rdroop scaling
###################################################################
class rampCompCerA_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xEA37, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rampCompCerA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA37, None)
            self.compNoDroop = (self.reg_value >> 21) & 0x1
            self.useDvidCurr = (self.reg_value >> 20) & 0x1
            self.cerA1DownShift = (self.reg_value >> 18) & 0x3
            self.cerA1Down = (self.reg_value >> 10) & 0xFF
            self.cerA1Shift = (self.reg_value >> 8) & 0x3
            self.cerA1 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rampCompCerA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.compNoDroop & 0x1) << 21)
        reg = (reg & 0x2FFFFF) + ((register_object.useDvidCurr & 0x1) << 20)
        reg = (reg & 0x33FFFF) + ((register_object.cerA1DownShift & 0x3) << 18)
        reg = (reg & 0x3C03FF) + ((register_object.cerA1Down & 0xFF) << 10)
        reg = (reg & 0x3FFCFF) + ((register_object.cerA1Shift & 0x3) << 8)
        reg = (reg & 0x3FFF00) + (register_object.cerA1 & 0xFF)
        dma(self.address, 0xEA37, reg)
    ## Add DVID comp signal for use with zero droop
    def compNoDroop(self, value = None):
        value = dma_bits(0xEA37, self.address, 1, 21, value)
        return(value)
    ## Compute DVID comp signal as current, subtract from sum before computing droop
    def useDvidCurr(self, value = None):
        value = dma_bits(0xEA37, self.address, 1, 20, value)
        return(value)
    ## RC Cer cap up gain = RCCERA1 * 2^(RCCERA1SHIFT)
    def cerA1DownShift(self, value = None):
        value = dma_bits(0xEA37, self.address, 2, 18, value)
        return(value)
    ## Cer capacitor RC model gain factor, including I*Rdroop scaling
    def cerA1Down(self, value = None):
        value = dma_bits(0xEA37, self.address, 8, 10, value)
        return(value)
    ## RC Cer cap up gain = RCCERA1DOWN * 2^(RCCERA1DOWNSHIFT)
    def cerA1Shift(self, value = None):
        value = dma_bits(0xEA37, self.address, 2, 8, value)
        return(value)
    ## Cer capacitor RLC model gain factor, including I*Rdroop scaling
    def cerA1(self, value = None):
        value = dma_bits(0xEA37, self.address, 8, 0, value)
        return(value)

###################################################################
## Cer capacitor RC model gain factor, including I*Rdroop scaling
###################################################################
class rampCompCerB_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xEA38, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rampCompCerB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA38, None)
            self.cerNorm = (self.reg_value >> 20) & 0x3
            self.cerA2 = (self.reg_value >> 10) & 0x3FF
            self.cerA3 = self.reg_value & 0x3FF

    def read_object(self):
        return(self.rampCompCerB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.cerNorm & 0x3) << 20)
        reg = (reg & 0x3003FF) + ((register_object.cerA2 & 0x3FF) << 10)
        reg = (reg & 0x3FFC00) + (register_object.cerA3 & 0x3FF)
        dma(self.address, 0xEA38, reg)
    ## Ceramic capacitor RC model overflow avoidance shift
    def cerNorm(self, value = None):
        value = dma_bits(0xEA38, self.address, 2, 20, value)
        return(value)
    ## OBSOLETE not used
    def cerA2(self, value = None):
        value = dma_bits(0xEA38, self.address, 10, 10, value)
        return(value)
    ## Ceramic capacitor RC model coefficient z^-1
    def cerA3(self, value = None):
        value = dma_bits(0xEA38, self.address, 10, 0, value)
        return(value)

###################################################################
## Automatic calculation of peak OC offset
###################################################################
class peakOcCalc_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEA39, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class peakOcCalc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA39, None)
            self.ocGain = (self.reg_value >> 16) & 0xFF
            self.jOcOff = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.peakOcCalc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.ocGain & 0xFF) << 16)
        reg = (reg & 0xFF0000) + (register_object.jOcOff & 0xFFFF)
        dma(self.address, 0xEA39, reg)
    ## Gain scaling of computed ripple peak vs average
    def ocGain(self, value = None):
        value = dma_bits(0xEA39, self.address, 8, 16, value)
        return(value)
    ## Offset added to computed ripple and base peakOcLimit value
    def jOcOff(self, value = None):
        value = dma_bits(0xEA39, self.address, 16, 0, value)
        return(value)

###################################################################
## Control of advanced peakOcLimit behaviors
###################################################################
class peakOcCfg_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 22

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class peakOcCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA3A, None)
            self.eventOnHcNlll = (self.reg_value >> 21) & 0x1
            self.eventOnPeakOc = (self.reg_value >> 20) & 0x1
            self.useHcNlll = (self.reg_value >> 19) & 0x1
            self.useCycToCycLimit = (self.reg_value >> 18) & 0x1
            self.usePhCurLimit = (self.reg_value >> 17) & 0x1
            self.calcInHw = (self.reg_value >> 16) & 0x1
            self.peakOcMax = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.peakOcCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.eventOnHcNlll & 0x1) << 21)
        reg = (reg & 0x2FFFFF) + ((register_object.eventOnPeakOc & 0x1) << 20)
        reg = (reg & 0x37FFFF) + ((register_object.useHcNlll & 0x1) << 19)
        reg = (reg & 0x3BFFFF) + ((register_object.useCycToCycLimit & 0x1) << 18)
        reg = (reg & 0x3DFFFF) + ((register_object.usePhCurLimit & 0x1) << 17)
        reg = (reg & 0x3EFFFF) + ((register_object.calcInHw & 0x1) << 16)
        reg = (reg & 0x3F0000) + (register_object.peakOcMax & 0xFFFF)
        dma(self.address, 0xEA3A, reg)
    ## Send a Cycle-to-Cycle limit event signal on high-current non-linear load-line activation
    def eventOnHcNlll(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 21, value)
        return(value)
    ## Send a Cycle-to-Cycle limit event signal on peak OC pulse limit
    def eventOnPeakOc(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 20, value)
        return(value)
    ## Use the high-current non-linear load-line method for fast V-Mode limiting
    def useHcNlll(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 19, value)
        return(value)
    ## Set PEAKOCLIMIT based on SVID cycToCycLimit register
    def useCycToCycLimit(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 18, value)
        return(value)
    ## Set PEAKOCLIMIT based on PMBus MFR phCurLimit register
    def usePhCurLimit(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 17, value)
        return(value)
    ## Compute peak OC limit voltage dependant term in hardware
    def calcInHw(self, value = None):
        value = dma_bits(0xEA3A, self.address, 1, 16, value)
        return(value)
    ## Store maximum PeakOCLimit value allowed
    def peakOcMax(self, value = None):
        value = dma_bits(0xEA3A, self.address, 16, 0, value)
        return(value)

###################################################################
## Override Vref target and rate or DAC
###################################################################
class vrefOverride_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class vrefOverride_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA3B, None)
            self.vrefRateValue = (self.reg_value >> 16) & 0xFFFF
            self.vrefValue = (self.reg_value >> 4) & 0xFFF
            self.forceTarget = (self.reg_value >> 1) & 0x1
            self.forceDacOut = self.reg_value & 0x1

    def read_object(self):
        return(self.vrefOverride_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vrefRateValue & 0xFFFF) << 16)
        reg = (reg & 0xFFFF000F) + ((register_object.vrefValue & 0xFFF) << 4)
        reg = (reg & 0xFFFFFFFD) + ((register_object.forceTarget & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.forceDacOut & 0x1)
        dma(self.address, 0xEA3B, reg)
    ## Use this ramp rate when forceRampTarget set
    def vrefRateValue(self, value = None):
        value = dma_bits(0xEA3B, self.address, 16, 16, value)
        return(value)
    ## Slew to this voltage DAC value when forceRampTarget set
    def vrefValue(self, value = None):
        value = dma_bits(0xEA3B, self.address, 12, 4, value)
        return(value)
    ## Override VID target settings when this is 1
    def forceTarget(self, value = None):
        value = dma_bits(0xEA3B, self.address, 1, 1, value)
        return(value)
    ## Override voltage DAC output with vrefValue when this is 1
    def forceDacOut(self, value = None):
        value = dma_bits(0xEA3B, self.address, 1, 0, value)
        return(value)

###################################################################
## Control fixed with PWM output
###################################################################
class fixedPwm_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3C, value)
        return(value)


###################################################################
## Signal monitor statistics
###################################################################
class diagnostics_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class diagnostics_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA3D, None)
            self.statRun = (self.reg_value >> 13) & 0x1
            self.statCount = (self.reg_value >> 10) & 0x7
            self.monChanPh = (self.reg_value >> 5) & 0x1F
            self.monChanLoop = self.reg_value & 0x1F

    def read_object(self):
        return(self.diagnostics_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFF) + ((register_object.statRun & 0x1) << 13)
        reg = (reg & 0x23FF) + ((register_object.statCount & 0x7) << 10)
        reg = (reg & 0x3C1F) + ((register_object.monChanPh & 0x1F) << 5)
        reg = (reg & 0x3FE0) + (register_object.monChanLoop & 0x1F)
        dma(self.address, 0xEA3D, reg)
    ## Run stats accumulator when 1
    def statRun(self, value = None):
        value = dma_bits(0xEA3D, self.address, 1, 13, value)
        return(value)
    ## Accumulation window size, power of 2 times 64 samples
    def statCount(self, value = None):
        value = dma_bits(0xEA3D, self.address, 3, 10, value)
        return(value)
    ## Phase signal to monitor
    def monChanPh(self, value = None):
        value = dma_bits(0xEA3D, self.address, 5, 5, value)
        return(value)
    ## LoopPilot signal to monitor
    def monChanLoop(self, value = None):
        value = dma_bits(0xEA3D, self.address, 5, 0, value)
        return(value)

###################################################################
## Loop telemetry test data control
###################################################################
class loopTelTest_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 31

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopTelTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA3E, None)
            self.runVadcFir = (self.reg_value >> 30) & 0x1
            self.runProc = (self.reg_value >> 29) & 0x1
            self.runTest = (self.reg_value >> 28) & 0x1
            self.useMonOut = (self.reg_value >> 27) & 0x1
            self.iEstAve = (self.reg_value >> 26) & 0x1
            self.iEstSum = (self.reg_value >> 25) & 0x1
            self.vAdc = (self.reg_value >> 24) & 0x1
            self.rstAvgIph = (self.reg_value >> 23) & 0x1
            self.rstAvgPout = (self.reg_value >> 22) & 0x1
            self.rstAvgIout = (self.reg_value >> 21) & 0x1
            self.rstAvgVadc = (self.reg_value >> 20) & 0x1
            self.wrAvgIph = (self.reg_value >> 19) & 0x1
            self.wrAvgPout = (self.reg_value >> 18) & 0x1
            self.wrAvgIout = (self.reg_value >> 17) & 0x1
            self.wrAvgVadc = (self.reg_value >> 16) & 0x1
            self.loopTestData = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.loopTelTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.runVadcFir & 0x1) << 30)
        reg = (reg & 0x5FFFFFFF) + ((register_object.runProc & 0x1) << 29)
        reg = (reg & 0x6FFFFFFF) + ((register_object.runTest & 0x1) << 28)
        reg = (reg & 0x77FFFFFF) + ((register_object.useMonOut & 0x1) << 27)
        reg = (reg & 0x7BFFFFFF) + ((register_object.iEstAve & 0x1) << 26)
        reg = (reg & 0x7DFFFFFF) + ((register_object.iEstSum & 0x1) << 25)
        reg = (reg & 0x7EFFFFFF) + ((register_object.vAdc & 0x1) << 24)
        reg = (reg & 0x7F7FFFFF) + ((register_object.rstAvgIph & 0x1) << 23)
        reg = (reg & 0x7FBFFFFF) + ((register_object.rstAvgPout & 0x1) << 22)
        reg = (reg & 0x7FDFFFFF) + ((register_object.rstAvgIout & 0x1) << 21)
        reg = (reg & 0x7FEFFFFF) + ((register_object.rstAvgVadc & 0x1) << 20)
        reg = (reg & 0x7FF7FFFF) + ((register_object.wrAvgIph & 0x1) << 19)
        reg = (reg & 0x7FFBFFFF) + ((register_object.wrAvgPout & 0x1) << 18)
        reg = (reg & 0x7FFDFFFF) + ((register_object.wrAvgIout & 0x1) << 17)
        reg = (reg & 0x7FFEFFFF) + ((register_object.wrAvgVadc & 0x1) << 16)
        reg = (reg & 0x7FFF0000) + (register_object.loopTestData & 0xFFFF)
        dma(self.address, 0xEA3E, reg)
    ## Enable loopTelProc and enable vSenFir
    def runVadcFir(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 30, value)
        return(value)
    ## Run common Vin processing (any channel can activate this)
    def runProc(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 29, value)
        return(value)
    ## Run loop processor and filters even if channel off
    def runTest(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 28, value)
        return(value)
    ## Replace vAdc data with monLoop output
    def useMonOut(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 27, value)
        return(value)
    ## Replace iEstAve data fed to phases for current balance checkers
    def iEstAve(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 26, value)
        return(value)
    ## Replace iEstSum data
    def iEstSum(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 25, value)
        return(value)
    ## Replace vAdc data
    def vAdc(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 24, value)
        return(value)
    ## Disable test mode for avgIph[], go back to normal operation
    def rstAvgIph(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 23, value)
        return(value)
    ## Disable test mode for avgPout, go back to normal operation
    def rstAvgPout(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 22, value)
        return(value)
    ## Disable test mode for avgIout, go back to normal operation
    def rstAvgIout(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 21, value)
        return(value)
    ## Disable test mode for avgVadc, go back to normal operation
    def rstAvgVadc(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 20, value)
        return(value)
    ## Write value into all avgIph[] accumulator registers (MSBs), self-clearing
    def wrAvgIph(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 19, value)
        return(value)
    ## Write value into avgPout accumulator register (MSBs), self-clearing
    def wrAvgPout(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 18, value)
        return(value)
    ## Write value into avgIout accumulator register (MSBs), self-clearing
    def wrAvgIout(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 17, value)
        return(value)
    ## Write value into avgVadc accumulator register (MSBs), self-clearing
    def wrAvgVadc(self, value = None):
        value = dma_bits(0xEA3E, self.address, 1, 16, value)
        return(value)
    ## Loop telemetry test data replacement
    def loopTestData(self, value = None):
        value = dma_bits(0xEA3E, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel trigger control register
###################################################################
class trigCtrl_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA3F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class trigCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA3F, None)
            self.trigIntEn = (self.reg_value >> 31) & 0x1
            self.trigSrc = (self.reg_value >> 24) & 0x7F
            self.trigCount = (self.reg_value >> 18) & 0x3F
            self.trigEdge = (self.reg_value >> 16) & 0x3
            self.trigLevel = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.trigCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.trigIntEn & 0x1) << 31)
        reg = (reg & 0x80FFFFFF) + ((register_object.trigSrc & 0x7F) << 24)
        reg = (reg & 0xFF03FFFF) + ((register_object.trigCount & 0x3F) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.trigEdge & 0x3) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.trigLevel & 0xFFFF)
        dma(self.address, 0xEA3F, reg)
    ## Trigger interrupt enable if 1
    def trigIntEn(self, value = None):
        value = dma_bits(0xEA3F, self.address, 1, 31, value)
        return(value)
    ## Trigger source
    def trigSrc(self, value = None):
        value = dma_bits(0xEA3F, self.address, 7, 24, value)
        return(value)
    ## Trigger only if Signal [0=low, 1=high, 2=fall, 3=rise] for count number of clkTs cycles. If trigCount == 0, then feature disabled
    def trigCount(self, value = None):
        value = dma_bits(0xEA3F, self.address, 6, 18, value)
        return(value)
    ## Trigger polarity and edge selection 0=low, 1=high, 2=fall, 3=rise
    def trigEdge(self, value = None):
        value = dma_bits(0xEA3F, self.address, 2, 16, value)
        return(value)
    ## Trigger threshold level, trigger if signal >= threshold
    def trigLevel(self, value = None):
        value = dma_bits(0xEA3F, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class phaseBal_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xEA40, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phaseBal_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA40, None)
            self.balDiffFilt = (self.reg_value >> 16) & 0x7
            self.jBalLim = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.phaseBal_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.balDiffFilt & 0x7) << 16)
        reg = (reg & 0x70000) + (register_object.jBalLim & 0xFFFF)
        dma(self.address, 0xEA40, reg)
    ## Phase imbalance difference filter 0=no filter, 1-7 get slower
    def balDiffFilt(self, value = None):
        value = dma_bits(0xEA40, self.address, 3, 16, value)
        return(value)
    ## Phase imbalance current for fault
    def jBalLim(self, value = None):
        value = dma_bits(0xEA40, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class ovFaultCtrl_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xEA41, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ovFaultCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA41, None)
            self.ouvMinLim = (self.reg_value >> 18) & 0x3
            self.ovFltFilt = (self.reg_value >> 16) & 0x3
            self.dnSettleCnt = (self.reg_value >> 8) & 0xFF
            self.upSettleCnt = self.reg_value & 0xFF

    def read_object(self):
        return(self.ovFaultCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.ouvMinLim & 0x3) << 18)
        reg = (reg & 0xCFFFF) + ((register_object.ovFltFilt & 0x3) << 16)
        reg = (reg & 0xF00FF) + ((register_object.dnSettleCnt & 0xFF) << 8)
        reg = (reg & 0xFFF00) + (register_object.upSettleCnt & 0xFF)
        dma(self.address, 0xEA41, reg)
    ## Undervolt fault limit when tracking is (0 VID-ouvTol, or the greater of 1 OUVLIM, 2 VID/2, 3 100mv)
    def ouvMinLim(self, value = None):
        value = dma_bits(0xEA41, self.address, 2, 18, value)
        return(value)
    ## Output voltage fault detector pre-filter time constant 0-3 (2^-1 to 2^-4)
    def ovFltFilt(self, value = None):
        value = dma_bits(0xEA41, self.address, 2, 16, value)
        return(value)
    ## Step OOV lim down this many clkTs after end of down ramp
    def dnSettleCnt(self, value = None):
        value = dma_bits(0xEA41, self.address, 8, 8, value)
        return(value)
    ## Step OUV lim up this many clkTs after end of up ramp
    def upSettleCnt(self, value = None):
        value = dma_bits(0xEA41, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class ouvTol_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xEA42, value)
        return(value)


###################################################################
## 
###################################################################
class oovTol_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xEA43, value)
        return(value)


###################################################################
## 
###################################################################
class ovHyst_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xEA44, value)
        return(value)


###################################################################
## Switch frequency control
###################################################################
class freqCtrl_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEA45, value)
        return(value)

    ## Desired per-phase switching period (F*Ts = N/64*Ts)
    def swPerRef(self, value = None):
        value = dma_bits(0xEA45, self.address, 14, 0, value)
        return(value)

###################################################################
## Bootstrap capacitor recharge pulse controls and SPS temp sleep modes
###################################################################
class bootcapOpt_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA46, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class bootcapOpt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA46, None)
            self.tempStartDelay = (self.reg_value >> 24) & 0xFF
            self.spsApdRchDelay = (self.reg_value >> 20) & 0xF
            self.tphOnPwm = (self.reg_value >> 14) & 0x1
            self.tmonOnPwm = (self.reg_value >> 13) & 0x1
            self.tmonOnDrEn = (self.reg_value >> 12) & 0x1
            self.tmonOnEn = (self.reg_value >> 11) & 0x1
            self.tmonOnVin = (self.reg_value >> 10) & 0x1
            self.rchOnOovFault = (self.reg_value >> 9) & 0x1
            self.rchOnFault = (self.reg_value >> 8) & 0x1
            self.rchInStartup = (self.reg_value >> 7) & 0x1
            self.rchInVid0ShtDwn = (self.reg_value >> 6) & 0x1
            self.rchInDecay = (self.reg_value >> 5) & 0x1
            self.noRchInPs3 = (self.reg_value >> 4) & 0x1
            self.noRchInPs2 = (self.reg_value >> 3) & 0x1
            self.addLowApdDelay = (self.reg_value >> 2) & 0x1
            self.useRchApdDelay = (self.reg_value >> 1) & 0x1
            self.useRchTimeDcm = self.reg_value & 0x1

    def read_object(self):
        return(self.bootcapOpt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.tempStartDelay & 0xFF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.spsApdRchDelay & 0xF) << 20)
        reg = (reg & 0xFFFFBFFF) + ((register_object.tphOnPwm & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.tmonOnPwm & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.tmonOnDrEn & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.tmonOnEn & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.tmonOnVin & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.rchOnOovFault & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.rchOnFault & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.rchInStartup & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.rchInVid0ShtDwn & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.rchInDecay & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.noRchInPs3 & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.noRchInPs2 & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.addLowApdDelay & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useRchApdDelay & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.useRchTimeDcm & 0x1)
        dma(self.address, 0xEA46, reg)
    ## Time for analog setting of temp data when starting up
    def tempStartDelay(self, value = None):
        value = dma_bits(0xEA46, self.address, 8, 24, value)
        return(value)
    ## SPS delay before first recharge pulse in dropped phase(100us)
    def spsApdRchDelay(self, value = None):
        value = dma_bits(0xEA46, self.address, 4, 20, value)
        return(value)
    ## SPS disables Tph outputs when smart PWM signaling selects sleep mode
    def tphOnPwm(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 14, value)
        return(value)
    ## SPS disables Tmon output when smart PWM signaling selects sleep mode
    def tmonOnPwm(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 13, value)
        return(value)
    ## SPS disables Tmon output when DREN is low, and wired to EN on driver
    def tmonOnDrEn(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 12, value)
        return(value)
    ## SPS disables Tmon output when EN is low, and wired to controller channel enable
    def tmonOnEn(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 11, value)
        return(value)
    ## SPS disables Tmon output when Vin is undervoltage
    def tmonOnVin(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 10, value)
        return(value)
    ## Turn on recharging when in an OOV fault shutdown and oovWakeSps in use
    def rchOnOovFault(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 9, value)
        return(value)
    ## Turn on recharging during any fault shutdown while channel commanded on
    def rchOnFault(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 8, value)
        return(value)
    ## Turn on recharging during after channel commanded on before it starts running
    def rchInStartup(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 7, value)
        return(value)
    ## Turn on recharging during VID=0 shutdown
    def rchInVid0ShtDwn(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 6, value)
        return(value)
    ## Turn on recharging during decay down ramps
    def rchInDecay(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 5, value)
        return(value)
    ## Turn off recharging (after one pulse per phase) in ps3
    def noRchInPs3(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 4, value)
        return(value)
    ## Turn off recharging (after one pulse per phase) in ps2
    def noRchInPs2(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 3, value)
        return(value)
    ## If using delay for APD entry, must add phase with pwm low during delay
    def addLowApdDelay(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 2, value)
        return(value)
    ## Delay recharging when dropping phase to allow APD entry
    def useRchApdDelay(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 1, value)
        return(value)
    ## In DCM, set recharge pulse width from rechargeTime if 1, or minOffTime if 0
    def useRchTimeDcm(self, value = None):
        value = dma_bits(0xEA46, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class bootcap_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 26

    def __call__(self, value = None):
        value = dma(self.address, 0xEA47, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class bootcap_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA47, None)
            self.rechargeTime = (self.reg_value >> 12) & 0x3FFF
            self.rechargePer = self.reg_value & 0xFFF

    def read_object(self):
        return(self.bootcap_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFF) + ((register_object.rechargeTime & 0x3FFF) << 12)
        reg = (reg & 0x3FFF000) + (register_object.rechargePer & 0xFFF)
        dma(self.address, 0xEA47, reg)
    ## Recharge pulse width (F*Ts = N/64*Ts)
    def rechargeTime(self, value = None):
        value = dma_bits(0xEA47, self.address, 14, 12, value)
        return(value)
    ## Interval between recharge of bootstrap cap of inactive phases, in Ts
    def rechargePer(self, value = None):
        value = dma_bits(0xEA47, self.address, 12, 0, value)
        return(value)

###################################################################
## AlertZ delay insertion control
###################################################################
class alertDelay_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 31

    def __call__(self, value = None):
        value = dma(self.address, 0xEA48, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class alertDelay_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA48, None)
            self.alertDlyEn = (self.reg_value >> 30) & 0x1
            self.fastDnDly = (self.reg_value >> 24) & 0x3F
            self.slowDnDly = (self.reg_value >> 18) & 0x3F
            self.fastUpDly = (self.reg_value >> 12) & 0x3F
            self.slowUpDly = (self.reg_value >> 6) & 0x3F
            self.decayDly = self.reg_value & 0x3F

    def read_object(self):
        return(self.alertDelay_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFFF) + ((register_object.alertDlyEn & 0x1) << 30)
        reg = (reg & 0x40FFFFFF) + ((register_object.fastDnDly & 0x3F) << 24)
        reg = (reg & 0x7F03FFFF) + ((register_object.slowDnDly & 0x3F) << 18)
        reg = (reg & 0x7FFC0FFF) + ((register_object.fastUpDly & 0x3F) << 12)
        reg = (reg & 0x7FFFF03F) + ((register_object.slowUpDly & 0x3F) << 6)
        reg = (reg & 0x7FFFFFC0) + (register_object.decayDly & 0x3F)
        dma(self.address, 0xEA48, reg)
    ## Enable alert delay insertion
    def alertDlyEn(self, value = None):
        value = dma_bits(0xEA48, self.address, 1, 30, value)
        return(value)
    ## Inserted alert delay for setVidFast ramping down
    def fastDnDly(self, value = None):
        value = dma_bits(0xEA48, self.address, 6, 24, value)
        return(value)
    ## Inserted alert delay for setVidSlow ramping down
    def slowDnDly(self, value = None):
        value = dma_bits(0xEA48, self.address, 6, 18, value)
        return(value)
    ## Inserted alert delay for setVidFast ramping up
    def fastUpDly(self, value = None):
        value = dma_bits(0xEA48, self.address, 6, 12, value)
        return(value)
    ## Inserted alert delay for setVidSlow ramping up
    def slowUpDly(self, value = None):
        value = dma_bits(0xEA48, self.address, 6, 6, value)
        return(value)
    ## Inserted alert delay for setVidDecay
    def decayDly(self, value = None):
        value = dma_bits(0xEA48, self.address, 6, 0, value)
        return(value)

###################################################################
## voltage output TOB for alert trigger
###################################################################
class alertTOB_class(object):
    def __init__(self, address):
        self.interface = 'vrCh'
        self.address = address
        self.bits = 14

    def __call__(self, value = None):
        value = dma(self.address, 0xEA49, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class alertTOB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA49, None)
            self.alertDownTOBEn = (self.reg_value >> 13) & 0x1
            self.alertDownTOB = (self.reg_value >> 7) & 0x3F
            self.alertUpTOBEn = (self.reg_value >> 6) & 0x1
            self.alertUpTOB = self.reg_value & 0x3F

    def read_object(self):
        return(self.alertTOB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFF) + ((register_object.alertDownTOBEn & 0x1) << 13)
        reg = (reg & 0x207F) + ((register_object.alertDownTOB & 0x3F) << 7)
        reg = (reg & 0x3FBF) + ((register_object.alertUpTOBEn & 0x1) << 6)
        reg = (reg & 0x3FC0) + (register_object.alertUpTOB & 0x3F)
        dma(self.address, 0xEA49, reg)
    ## Enable alert delay based on actual output voltage ramping down into Target + DOWN_TOB range (VMAX_TOB)
    def alertDownTOBEn(self, value = None):
        value = dma_bits(0xEA49, self.address, 1, 13, value)
        return(value)
    ## alert delay tolerance budget (TOB) while ramping down
    def alertDownTOB(self, value = None):
        value = dma_bits(0xEA49, self.address, 6, 7, value)
        return(value)
    ## Enable alert delay based on actual output voltage ramping up into Target - UP_TOB range (VMIN_TOB)
    def alertUpTOBEn(self, value = None):
        value = dma_bits(0xEA49, self.address, 1, 6, value)
        return(value)
    ## alert delay tolerance budget (TOB) while ramping up
    def alertUpTOB(self, value = None):
        value = dma_bits(0xEA49, self.address, 6, 0, value)
        return(value)

###################################################################
## Boot voltage (PMBUS) or optional AMD SVI2 boot VID
###################################################################
class bootData_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 12

    def __call__(self, value = None):
        value = dma(self.address, 0xEA58, value)
        return(value)


###################################################################
## Phase drop delay timer in multiples of clkTs period
###################################################################
class addDropDelay_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEA59, value)
        return(value)


###################################################################
## SVID absolute maximum Vout command VID code
###################################################################
class absVoutMax_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 9

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5A, value)
        return(value)


###################################################################
## Imon fault detector (pin open sensor) control
###################################################################
class partFastAdd_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5B, value)
        return(value)

    ## Delay use of fault signals after start of pin Imon Fault activation
    def imonFltSettle(self, value = None):
        value = dma_bits(0xEA5B, self.address, 8, 1, value)
        return(value)

###################################################################
## SVID Output current alert level for unfiltered comparator
###################################################################
class fastIccMax_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class fastIccMax_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA5C, None)
            self.enFastIccAlert = (self.reg_value >> 16) & 0x1
            self.iccMax100ma = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.fastIccMax_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.enFastIccAlert & 0x1) << 16)
        reg = (reg & 0x10000) + (register_object.iccMax100ma & 0xFFFF)
        dma(self.address, 0xEA5C, reg)
    ## Enable fast (unfiltered) IccMax comparator if 1 rather than firmware-based
    def enFastIccAlert(self, value = None):
        value = dma_bits(0xEA5C, self.address, 1, 16, value)
        return(value)
    ## SVID IccMax translated to 0.1Amps LSB
    def iccMax100ma(self, value = None):
        value = dma_bits(0xEA5C, self.address, 16, 0, value)
        return(value)

###################################################################
## User configuration of channel power manager
###################################################################
class spsPwrMgt_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 21

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class spsPwrMgt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA5D, None)
            self.spsNoWakePs4 = (self.reg_value >> 20) & 0x1
            self.spsAzStlDelay = (self.reg_value >> 16) & 0xF
            self.wakeUpLoEnd = (self.reg_value >> 8) & 0x3F
            self.wakeUpWidth = (self.reg_value >> 5) & 0x7
            self.spsWakeUpOov = (self.reg_value >> 4) & 0x1
            self.spsSleepEn = (self.reg_value >> 3) & 0x1
            self.spsWakeEn = (self.reg_value >> 2) & 0x1
            self.autoImonFlt = (self.reg_value >> 1) & 0x1
            self.useSdifPwr = self.reg_value & 0x1

    def read_object(self):
        return(self.spsPwrMgt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.spsNoWakePs4 & 0x1) << 20)
        reg = (reg & 0x10FFFF) + ((register_object.spsAzStlDelay & 0xF) << 16)
        reg = (reg & 0x1FC0FF) + ((register_object.wakeUpLoEnd & 0x3F) << 8)
        reg = (reg & 0x1FFF1F) + ((register_object.wakeUpWidth & 0x7) << 5)
        reg = (reg & 0x1FFFEF) + ((register_object.spsWakeUpOov & 0x1) << 4)
        reg = (reg & 0x1FFFF7) + ((register_object.spsSleepEn & 0x1) << 3)
        reg = (reg & 0x1FFFFB) + ((register_object.spsWakeEn & 0x1) << 2)
        reg = (reg & 0x1FFFFD) + ((register_object.autoImonFlt & 0x1) << 1)
        reg = (reg & 0x1FFFFE) + (register_object.useSdifPwr & 0x1)
        dma(self.address, 0xEA5D, reg)
    ## Do not issue wakeup pulses when exiting PS4
    def spsNoWakePs4(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 20, value)
        return(value)
    ## Allow time for SPS to settle autozero output, or return to normal operation
    def spsAzStlDelay(self, value = None):
        value = dma_bits(0xEA5D, self.address, 4, 16, value)
        return(value)
    ## SPS Wake up PWM low end time in clkSys (clkTs/2)
    def wakeUpLoEnd(self, value = None):
        value = dma_bits(0xEA5D, self.address, 6, 8, value)
        return(value)
    ## SPS Wake up PWM high width in clkSys (clkTs/2)
    def wakeUpWidth(self, value = None):
        value = dma_bits(0xEA5D, self.address, 3, 5, value)
        return(value)
    ## Use SPS wakeup pulses during OOV protection (DriverMAX or SDIF)
    def spsWakeUpOov(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 4, value)
        return(value)
    ## Use DriverMax SPS power-down pulses on disable or PS4 shutdown
    def spsSleepEn(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 3, value)
        return(value)
    ## Use SPS power-up wake-up pulses (DriverMAX or SDIF)
    def spsWakeEn(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 2, value)
        return(value)
    ## Use auto enable of pinOpnIsen sensors to detect Imon faults or zero-crossing
    def autoImonFlt(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 1, value)
        return(value)
    ## Enable SDIF smart driver power controls
    def useSdifPwr(self, value = None):
        value = dma_bits(0xEA5D, self.address, 1, 0, value)
        return(value)

###################################################################
## User configuration of channel power manager
###################################################################
class chPwrMgtEn_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrMgtEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA5E, None)
            self.enPs2ExitDelayZeroVid = (self.reg_value >> 23) & 0x1
            self.waitForExitDelay = (self.reg_value >> 22) & 0x1
            self.enAddAllOnePhExit = (self.reg_value >> 21) & 0x1
            self.autoDropIsenPs3 = (self.reg_value >> 20) & 0x1
            self.autoDropIsenPs2 = (self.reg_value >> 19) & 0x1
            self.manTrimOov = (self.reg_value >> 16) & 0x7
            self.enPs2ExitDelay = (self.reg_value >> 15) & 0x1
            self.enOovProtect = (self.reg_value >> 14) & 0x1
            self.enVsenOovFlt = (self.reg_value >> 13) & 0x1
            self.enVsenVccUvAct = (self.reg_value >> 12) & 0x1
            self.autoVsenPinCmp = (self.reg_value >> 11) & 0x1
            self.autoPwrDnPs4 = (self.reg_value >> 10) & 0x1
            self.autoPwrDnPs3 = (self.reg_value >> 9) & 0x1
            self.autoPwrDnPs2 = (self.reg_value >> 8) & 0x1
            self.autoPwrDnDrop = (self.reg_value >> 7) & 0x1
            self.autoPwrDnVid0Ps3 = (self.reg_value >> 6) & 0x1
            self.autoPwrDnVid0Ps2 = (self.reg_value >> 5) & 0x1
            self.autoPwrDnVid0Ps1 = (self.reg_value >> 4) & 0x1
            self.autoPwrDnVid0Ps0 = (self.reg_value >> 3) & 0x1
            self.autoPhClkCh = (self.reg_value >> 2) & 0x1
            self.autoChClkEn = (self.reg_value >> 1) & 0x1
            self.autoChPwr = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrMgtEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFF) + ((register_object.enPs2ExitDelayZeroVid & 0x1) << 23)
        reg = (reg & 0xBFFFFF) + ((register_object.waitForExitDelay & 0x1) << 22)
        reg = (reg & 0xDFFFFF) + ((register_object.enAddAllOnePhExit & 0x1) << 21)
        reg = (reg & 0xEFFFFF) + ((register_object.autoDropIsenPs3 & 0x1) << 20)
        reg = (reg & 0xF7FFFF) + ((register_object.autoDropIsenPs2 & 0x1) << 19)
        reg = (reg & 0xF8FFFF) + ((register_object.manTrimOov & 0x7) << 16)
        reg = (reg & 0xFF7FFF) + ((register_object.enPs2ExitDelay & 0x1) << 15)
        reg = (reg & 0xFFBFFF) + ((register_object.enOovProtect & 0x1) << 14)
        reg = (reg & 0xFFDFFF) + ((register_object.enVsenOovFlt & 0x1) << 13)
        reg = (reg & 0xFFEFFF) + ((register_object.enVsenVccUvAct & 0x1) << 12)
        reg = (reg & 0xFFF7FF) + ((register_object.autoVsenPinCmp & 0x1) << 11)
        reg = (reg & 0xFFFBFF) + ((register_object.autoPwrDnPs4 & 0x1) << 10)
        reg = (reg & 0xFFFDFF) + ((register_object.autoPwrDnPs3 & 0x1) << 9)
        reg = (reg & 0xFFFEFF) + ((register_object.autoPwrDnPs2 & 0x1) << 8)
        reg = (reg & 0xFFFF7F) + ((register_object.autoPwrDnDrop & 0x1) << 7)
        reg = (reg & 0xFFFFBF) + ((register_object.autoPwrDnVid0Ps3 & 0x1) << 6)
        reg = (reg & 0xFFFFDF) + ((register_object.autoPwrDnVid0Ps2 & 0x1) << 5)
        reg = (reg & 0xFFFFEF) + ((register_object.autoPwrDnVid0Ps1 & 0x1) << 4)
        reg = (reg & 0xFFFFF7) + ((register_object.autoPwrDnVid0Ps0 & 0x1) << 3)
        reg = (reg & 0xFFFFFB) + ((register_object.autoPhClkCh & 0x1) << 2)
        reg = (reg & 0xFFFFFD) + ((register_object.autoChClkEn & 0x1) << 1)
        reg = (reg & 0xFFFFFE) + (register_object.autoChPwr & 0x1)
        dma(self.address, 0xEA5E, reg)
    ## Enable PS2 exit latency of fixed 3us only if exiting from VID=0  MBIRD-1919
    def enPs2ExitDelayZeroVid(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 23, value)
        return(value)
    ## When adding all for ps change wait for normal PS2/3 exit latency
    def waitForExitDelay(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 22, value)
        return(value)
    ## Enable adding all phases when exiting onePhOnly PS2/3 to PS0/1 or PSI3/4 to PSI0/1/2
    def enAddAllOnePhExit(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 21, value)
        return(value)
    ## Enable auto disabling of Isen ADCs on dropped phases in PS3/PSI3-4 one-phase only
    def autoDropIsenPs3(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 20, value)
        return(value)
    ## Enable auto disabling of Isen ADCs on dropped phases in PS2 one-phase only
    def autoDropIsenPs2(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 19, value)
        return(value)
    ## Manual Vsen OOV threshold 0-7 = Vsen > 1.25:0.25:3.0 V
    def manTrimOov(self, value = None):
        value = dma_bits(0xEA5E, self.address, 3, 16, value)
        return(value)
    ## Enable PS2 exit latency of fixed 3us
    def enPs2ExitDelay(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 15, value)
        return(value)
    ## Enable OOV protection when Vsen or loop OOV detected
    def enOovProtect(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 14, value)
        return(value)
    ## Enable OOV fault path from Vsen comparator
    def enVsenOovFlt(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 13, value)
        return(value)
    ## When auto control enabled 1 means switch to VccUv when loop regulating else use OOV. In manual control switch from OOV to VccUv if 1
    def enVsenVccUvAct(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 12, value)
        return(value)
    ## Allow auto control of Vsen pin comparator for OOV and VccUv detection
    def autoVsenPinCmp(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 11, value)
        return(value)
    ## Power off channel circuitry in PS4 (requires longer exit latency)
    def autoPwrDnPs4(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 10, value)
        return(value)
    ## Lower power utilization in PS3 (requires exit latency, one phase only)
    def autoPwrDnPs3(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 9, value)
        return(value)
    ## Lower power utilization in PS2 (requires exit latency, one phase only)
    def autoPwrDnPs2(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 8, value)
        return(value)
    ## Lower power utilization in dropped phases (PS0,PS1)
    def autoPwrDnDrop(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 7, value)
        return(value)
    ## Power down channel circuitry at zeroVID in PS3 (requires exit latency)
    def autoPwrDnVid0Ps3(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 6, value)
        return(value)
    ## Power down channel circuitry at zeroVID in PS2 (requires exit latency)
    def autoPwrDnVid0Ps2(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 5, value)
        return(value)
    ## Power down channel circuitry at zeroVID in PS1
    def autoPwrDnVid0Ps1(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 4, value)
        return(value)
    ## Power down channel circuitry at zeroVID in PS0
    def autoPwrDnVid0Ps0(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 3, value)
        return(value)
    ## Allow automatic control of phase clock/power for channel 0
    def autoPhClkCh(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 2, value)
        return(value)
    ## Allow automatic control of channel clock/power for channel 0
    def autoChClkEn(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 1, value)
        return(value)
    ## Allow automatic control of channel clock/power for channel 0
    def autoChPwr(self, value = None):
        value = dma_bits(0xEA5E, self.address, 1, 0, value)
        return(value)

###################################################################
## Manual test controls for channel power manager
###################################################################
class chPwrTest_class(object):
    def __init__(self, address):
        self.interface = 'lmCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEA5F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA5F, None)
            self.nextPsState = (self.reg_value >> 12) & 0x7
            self.oovProtect = (self.reg_value >> 11) & 0x1
            self.shtDwnFlt = (self.reg_value >> 10) & 0x1
            self.ps4ShtDwn = (self.reg_value >> 9) & 0x1
            self.vidShtDwn = (self.reg_value >> 8) & 0x1
            self.dcmOnly = (self.reg_value >> 7) & 0x1
            self.onePhOnly = (self.reg_value >> 6) & 0x1
            self.chIsRunning = (self.reg_value >> 5) & 0x1
            self.chCmdOn = (self.reg_value >> 4) & 0x1
            self.priOn = (self.reg_value >> 3) & 0x1
            self.allocPhases = (self.reg_value >> 2) & 0x1
            self.diagComplete = (self.reg_value >> 1) & 0x1
            self.enChPwrTest = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x8FFF) + ((register_object.nextPsState & 0x7) << 12)
        reg = (reg & 0xF7FF) + ((register_object.oovProtect & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.shtDwnFlt & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.ps4ShtDwn & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.vidShtDwn & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.dcmOnly & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.onePhOnly & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.chIsRunning & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.chCmdOn & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.priOn & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.allocPhases & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.diagComplete & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.enChPwrTest & 0x1)
        dma(self.address, 0xEA5F, reg)
    ## Next PS state
    def nextPsState(self, value = None):
        value = dma_bits(0xEA5F, self.address, 3, 12, value)
        return(value)
    ## Output overvoltage protection active
    def oovProtect(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 11, value)
        return(value)
    ## Channel shutdown for fault
    def shtDwnFlt(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 10, value)
        return(value)
    ## In PS4 disable
    def ps4ShtDwn(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 9, value)
        return(value)
    ## Disabled for zero set voltage
    def vidShtDwn(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 8, value)
        return(value)
    ## Running discontinuous conduction only, no CCM
    def dcmOnly(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 7, value)
        return(value)
    ## Only one phase active, cannot add phases automatically
    def onePhOnly(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 6, value)
        return(value)
    ## Channel is currently running
    def chIsRunning(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 5, value)
        return(value)
    ## Channel has been commanded on
    def chCmdOn(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 4, value)
        return(value)
    ## Channel meets primary turn-on conditions
    def priOn(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 3, value)
        return(value)
    ## Channel has phases
    def allocPhases(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 2, value)
        return(value)
    ## Diagnostics power-on test done (DiagDone)
    def diagComplete(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 1, value)
        return(value)
    ## Enable test mode override of normal inputs
    def enChPwrTest(self, value = None):
        value = dma_bits(0xEA5F, self.address, 1, 0, value)
        return(value)

###################################################################
## SVI3 Version
###################################################################
class svi3Version_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB81, value)
        return(value)


###################################################################
## Manufacturer ID
###################################################################
class mfgId_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB82, value)
        return(value)


###################################################################
## Model ID
###################################################################
class modelId_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB83, value)
        return(value)


###################################################################
## Ten bit telemetry available
###################################################################
class tenBitTelAvail_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB84, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tenBitTelAvail_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB84, None)
            self.psys = (self.reg_value >> 6) & 0x1
            self.vin = (self.reg_value >> 5) & 0x1
            self.iin = (self.reg_value >> 4) & 0x1
            self.temp2 = (self.reg_value >> 3) & 0x1
            self.temp1 = (self.reg_value >> 2) & 0x1
            self.vout = (self.reg_value >> 1) & 0x1
            self.iout = self.reg_value & 0x1

    def read_object(self):
        return(self.tenBitTelAvail_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xBF) + ((register_object.psys & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.vin & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.iin & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.temp2 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.temp1 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.vout & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.iout & 0x1)
        dma(self.address, 0xEB84, reg)
    def psys(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 6, value)
        return(value)
    ## Input voltage telem avail
    def vin(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 5, value)
        return(value)
    ## Input current telem avail
    def iin(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 4, value)
        return(value)
    ## Ambient temperature data (no VRHOT/warn) is avail (NTC if phase temp used)
    def temp2(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 3, value)
        return(value)
    ## Driver temperature data (with VRHOT/warn) is avail
    def temp1(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 2, value)
        return(value)
    ## Output voltage data is avail
    def vout(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 1, value)
        return(value)
    ## Output current data is avail
    def iout(self, value = None):
        value = dma_bits(0xEB84, self.address, 1, 0, value)
        return(value)

###################################################################
## Sixteen bit telemetry available
###################################################################
class sixteenBitTelAvail_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB85, value)
        return(value)


###################################################################
## CRC Enabled, PSI, VID bit 8
###################################################################
class crcPsiVid_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB86, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class crcPsiVid_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB86, None)
            self.crc = (self.reg_value >> 7) & 0x1
            self.psi = (self.reg_value >> 2) & 0x7
            self.vid8 = self.reg_value & 0x1

    def read_object(self):
        return(self.crcPsiVid_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.crc & 0x1) << 7)
        reg = (reg & 0xE3) + ((register_object.psi & 0x7) << 2)
        reg = (reg & 0xFE) + (register_object.vid8 & 0x1)
        dma(self.address, 0xEB86, reg)
    ## Read-only -- CRC is enabled if 1 -- User configured via svi3CrcEn
    def crc(self, value = None):
        value = dma_bits(0xEB86, self.address, 1, 7, value)
        return(value)
    ## Read-only current PSI power state
    def psi(self, value = None):
        value = dma_bits(0xEB86, self.address, 3, 2, value)
        return(value)
    ## Read-only current VID code MSB
    def vid8(self, value = None):
        value = dma_bits(0xEB86, self.address, 1, 0, value)
        return(value)

###################################################################
## VID bits 7 - 0
###################################################################
class vid_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB87, value)
        return(value)


###################################################################
## Boot Slew Rate and Boot Voltage Code
###################################################################
class svi3BootData_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB88, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi3BootData_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB88, None)
            self.bootSlew = (self.reg_value >> 4) & 0xF
            self.bootVolt = self.reg_value & 0xF

    def read_object(self):
        return(self.svi3BootData_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.bootSlew & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.bootVolt & 0xF)
        dma(self.address, 0xEB88, reg)
    ## Boot slew rate (after reset) 0=2.5, 1=10, 2=20, 3=40 mv/us
    def bootSlew(self, value = None):
        value = dma_bits(0xEB88, self.address, 4, 4, value)
        return(value)
    ## Boot voltage (first time) 0=0, 1-11=0.5-1.5, 12-15=1.8,2.0,2.5,2.8
    def bootVolt(self, value = None):
        value = dma_bits(0xEB88, self.address, 4, 0, value)
        return(value)

###################################################################
## Telemetry scale selects for VIN, Iout, and IIN
###################################################################
class teleScale_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB89, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class teleScale_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB89, None)
            self.vinScale = (self.reg_value >> 6) & 0x3
            self.ioutScale = (self.reg_value >> 3) & 0x7
            self.iinScale = self.reg_value & 0x7

    def read_object(self):
        return(self.teleScale_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.vinScale & 0x3) << 6)
        reg = (reg & 0xC7) + ((register_object.ioutScale & 0x7) << 3)
        reg = (reg & 0xF8) + (register_object.iinScale & 0x7)
        dma(self.address, 0xEB89, reg)
    ## SVI3 Telem input voltage scale (0,1=cust, 2=(0-1023)/32V, 3=(1024-2047)/32V)
    def vinScale(self, value = None):
        value = dma_bits(0xEB89, self.address, 2, 6, value)
        return(value)
    ## SVI3 Telem output current scale, (0=cust, 1-7=(0-1023)*2^(n-6) )
    def ioutScale(self, value = None):
        value = dma_bits(0xEB89, self.address, 3, 3, value)
        return(value)
    ## SVI3 Telem input current scale (0=cust, 1-7=(0-1023)*2^(n-9) )
    def iinScale(self, value = None):
        value = dma_bits(0xEB89, self.address, 3, 0, value)
        return(value)

###################################################################
## Maximum Vout Supported
###################################################################
class maxVoutSupport_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB8A, value)
        return(value)


###################################################################
## Minimum Vout Supported
###################################################################
class minVoutSupport_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB8B, value)
        return(value)


###################################################################
## System Power Scale
###################################################################
class psysScale_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB8C, value)
        return(value)

    ## System Power Scale, (0=Custom, 1-7: (0-1023)*2^(n-6) )
    def psysScale(self, value = None):
        value = dma_bits(0xEB8C, self.address, 3, 0, value)
        return(value)

###################################################################
## Fault Status, write 0 to clear individual bits
###################################################################
class faultStatus_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB90, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class faultStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB90, None)
            self.vrhot = (self.reg_value >> 5) & 0x1
            self.ocpWarn = (self.reg_value >> 4) & 0x1
            self.otpFault = (self.reg_value >> 3) & 0x1
            self.uvpFault = (self.reg_value >> 2) & 0x1
            self.ovpFault = (self.reg_value >> 1) & 0x1
            self.ocpFault = self.reg_value & 0x1

    def read_object(self):
        return(self.faultStatus_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xDF) + ((register_object.vrhot & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.ocpWarn & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.otpFault & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.uvpFault & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.ovpFault & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.ocpFault & 0x1)
        dma(self.address, 0xEB90, reg)
    def vrhot(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 5, value)
        return(value)
    def ocpWarn(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 4, value)
        return(value)
    def otpFault(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 3, value)
        return(value)
    def uvpFault(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 2, value)
        return(value)
    def ovpFault(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 1, value)
        return(value)
    def ocpFault(self, value = None):
        value = dma_bits(0xEB90, self.address, 1, 0, value)
        return(value)

###################################################################
## NACK Status, write 0 to clear individual bits
###################################################################
class nackStatus_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEB91, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class nackStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB91, None)
            self.frameError = (self.reg_value >> 4) & 0x1
            self.crcError = (self.reg_value >> 3) & 0x1
            self.bit2 = (self.reg_value >> 2) & 0x1
            self.bit1 = (self.reg_value >> 1) & 0x1
            self.bit0 = self.reg_value & 0x1

    def read_object(self):
        return(self.nackStatus_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xEF) + ((register_object.frameError & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.crcError & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.bit2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.bit1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.bit0 & 0x1)
        dma(self.address, 0xEB91, reg)
    def frameError(self, value = None):
        value = dma_bits(0xEB91, self.address, 1, 4, value)
        return(value)
    def crcError(self, value = None):
        value = dma_bits(0xEB91, self.address, 1, 3, value)
        return(value)
    def bit2(self, value = None):
        value = dma_bits(0xEB91, self.address, 1, 2, value)
        return(value)
    def bit1(self, value = None):
        value = dma_bits(0xEB91, self.address, 1, 1, value)
        return(value)
    def bit0(self, value = None):
        value = dma_bits(0xEB91, self.address, 1, 0, value)
        return(value)

###################################################################
## Select Down VID decay, PSI6 or EN low decay, Up VID slew rate
###################################################################
class rateSelect_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rateSelect_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEBA0, None)
            self.decayConditions = (self.reg_value >> 5) & 0x7
            self.downSlewRate = (self.reg_value >> 4) & 0x1
            self.upVidSlewRate = self.reg_value & 0xF

    def read_object(self):
        return(self.rateSelect_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.decayConditions & 0x7) << 5)
        reg = (reg & 0xEF) + ((register_object.downSlewRate & 0x1) << 4)
        reg = (reg & 0xF0) + (register_object.upVidSlewRate & 0xF)
        dma(self.address, 0xEBA0, reg)
    ## 2 - Decay in PSI0-2, 1 - Decay in PSI3-4, 0 - Decay in PSI6 or EN low
    def decayConditions(self, value = None):
        value = dma_bits(0xEBA0, self.address, 3, 5, value)
        return(value)
    ## Down slew rate: 0 - down equals up, 1 - down at 1/4 up rate
    def downSlewRate(self, value = None):
        value = dma_bits(0xEBA0, self.address, 1, 4, value)
        return(value)
    ## Rate = value * 2.5 + 2.5mV/us
    def upVidSlewRate(self, value = None):
        value = dma_bits(0xEBA0, self.address, 4, 0, value)
        return(value)

###################################################################
## Load Line Adjust
###################################################################
class llAdjust_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA1, value)
        return(value)

    ## Load line slope adjustment relative to nominal (DROOP)
    def llAdjust(self, value = None):
        value = dma_bits(0xEBA1, self.address, 5, 0, value)
        return(value)

###################################################################
## Vout Offset
###################################################################
class voutOffset_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA2, value)
        return(value)


###################################################################
## Maximum selected VID voltage
###################################################################
class vidMax_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA3, value)
        return(value)


###################################################################
## Minimum selected VID voltage
###################################################################
class vidMin_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA4, value)
        return(value)


###################################################################
## Ten bit telemetry enabled
###################################################################
class tenBitTelEn_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class tenBitTelEn_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEBA5, None)
            self.psys = (self.reg_value >> 6) & 0x1
            self.vin = (self.reg_value >> 5) & 0x1
            self.iin = (self.reg_value >> 4) & 0x1
            self.temp2 = (self.reg_value >> 3) & 0x1
            self.temp1 = (self.reg_value >> 2) & 0x1
            self.vout = (self.reg_value >> 1) & 0x1
            self.iout = self.reg_value & 0x1

    def read_object(self):
        return(self.tenBitTelEn_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xBF) + ((register_object.psys & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.vin & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.iin & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.temp2 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.temp1 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.vout & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.iout & 0x1)
        dma(self.address, 0xEBA5, reg)
    def psys(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 6, value)
        return(value)
    ## Enable reporting of input voltage
    def vin(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 5, value)
        return(value)
    ## Enable reporting of input current
    def iin(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 4, value)
        return(value)
    ## Enable reporting of ambient temperature
    def temp2(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 3, value)
        return(value)
    ## Enable reporting of driver temperature
    def temp1(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 2, value)
        return(value)
    ## Enable reporting of output voltage
    def vout(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 1, value)
        return(value)
    ## Enable reporting of output current
    def iout(self, value = None):
        value = dma_bits(0xEBA5, self.address, 1, 0, value)
        return(value)

###################################################################
## Sixteen bit telemetry enabled
###################################################################
class sixteenBitTelEn_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA6, value)
        return(value)


###################################################################
## OCP Threshold
###################################################################
class ocpThresh_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA7, value)
        return(value)


###################################################################
## OCP Warning Threshold
###################################################################
class ocpWarnThresh_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA8, value)
        return(value)


###################################################################
## OCP Fault Delay
###################################################################
class ocpWnMnPlsFtDl_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBA9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ocpWnMnPlsFtDl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEBA9, None)
            self.ocpWarnMinPulse = (self.reg_value >> 3) & 0x1F
            self.ocpFaultDelay = self.reg_value & 0x7

    def read_object(self):
        return(self.ocpWnMnPlsFtDl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.ocpWarnMinPulse & 0x1F) << 3)
        reg = (reg & 0xF8) + (register_object.ocpFaultDelay & 0x7)
        dma(self.address, 0xEBA9, reg)
    def ocpWarnMinPulse(self, value = None):
        value = dma_bits(0xEBA9, self.address, 5, 3, value)
        return(value)
    def ocpFaultDelay(self, value = None):
        value = dma_bits(0xEBA9, self.address, 3, 0, value)
        return(value)

###################################################################
## Vrhot Threshold
###################################################################
class vrhotThresh_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBAA, value)
        return(value)


###################################################################
## OTP Threshold
###################################################################
class otpThresh_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBAB, value)
        return(value)


###################################################################
## Voltage protection settings
###################################################################
class voltProt_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBAC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class voltProt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEBAC, None)
            self.ovpRef = (self.reg_value >> 7) & 0x1
            self.ovpDelta = (self.reg_value >> 4) & 0x7
            self.uvpRef = (self.reg_value >> 3) & 0x1
            self.uvpDelta = self.reg_value & 0x7

    def read_object(self):
        return(self.voltProt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.ovpRef & 0x1) << 7)
        reg = (reg & 0x8F) + ((register_object.ovpDelta & 0x7) << 4)
        reg = (reg & 0xF7) + ((register_object.uvpRef & 0x1) << 3)
        reg = (reg & 0xF8) + (register_object.uvpDelta & 0x7)
        dma(self.address, 0xEBAC, reg)
    ## Over voltage protection reference select: 0=VID, 1=vidMax
    def ovpRef(self, value = None):
        value = dma_bits(0xEBAC, self.address, 1, 7, value)
        return(value)
    ## Over voltage protection delta: Delta = value * 50 + 50mV
    def ovpDelta(self, value = None):
        value = dma_bits(0xEBAC, self.address, 3, 4, value)
        return(value)
    ## Under voltage protection reference select: 0=VID, 1=vidMax
    def uvpRef(self, value = None):
        value = dma_bits(0xEBAC, self.address, 1, 3, value)
        return(value)
    ## Under voltage protection delta: Delta = value * -50 - 50mV
    def uvpDelta(self, value = None):
        value = dma_bits(0xEBAC, self.address, 3, 0, value)
        return(value)

###################################################################
## Phase count select for PSI1 and PSI2
###################################################################
class phaseShed_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBAD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phaseShed_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEBAD, None)
            self.phaseShed1 = (self.reg_value >> 4) & 0xF
            self.phaseShed2 = self.reg_value & 0xF

    def read_object(self):
        return(self.phaseShed_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xF) + ((register_object.phaseShed1 & 0xF) << 4)
        reg = (reg & 0xF0) + (register_object.phaseShed2 & 0xF)
        dma(self.address, 0xEBAD, reg)
    ## Phase count when in PSI1
    def phaseShed1(self, value = None):
        value = dma_bits(0xEBAD, self.address, 4, 4, value)
        return(value)
    ## Phase count when in PSI2
    def phaseShed2(self, value = None):
        value = dma_bits(0xEBAD, self.address, 4, 0, value)
        return(value)

###################################################################
## Debug enable
###################################################################
class debugEn_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC0, value)
        return(value)


###################################################################
## Debug payload for TEMP1
###################################################################
class debugTemp1_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC1, value)
        return(value)


###################################################################
## Debug payload for Vout[9:2]
###################################################################
class debugVoutH_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC2, value)
        return(value)


###################################################################
## Debug payload for Vout[1:0]
###################################################################
class debugVoutL_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC3, value)
        return(value)

    def debugVoutL(self, value = None):
        value = dma_bits(0xEBC3, self.address, 2, 0, value)
        return(value)

###################################################################
## Debug payload for Iout[9:2]
###################################################################
class debugIoutH_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC4, value)
        return(value)


###################################################################
## Debug payload for Iout[1:0]
###################################################################
class debugIoutL_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC5, value)
        return(value)

    def debugIoutL(self, value = None):
        value = dma_bits(0xEBC5, self.address, 2, 0, value)
        return(value)

###################################################################
## Debug payload for PWRGD, VRHOT, and OCP_WARN
###################################################################
class debugOutput_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBC6, value)
        return(value)

    def debugOutput(self, value = None):
        value = dma_bits(0xEBC6, self.address, 3, 0, value)
        return(value)

###################################################################
## General purpose register 0
###################################################################
class genPurpose0_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD0, value)
        return(value)


###################################################################
## General purpose register 1
###################################################################
class genPurpose1_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD1, value)
        return(value)


###################################################################
## General purpose register 2
###################################################################
class genPurpose2_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD2, value)
        return(value)


###################################################################
## General purpose register 3
###################################################################
class genPurpose3_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD3, value)
        return(value)


###################################################################
## General purpose register 4
###################################################################
class genPurpose4_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD4, value)
        return(value)


###################################################################
## General purpose register 5
###################################################################
class genPurpose5_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD5, value)
        return(value)


###################################################################
## General purpose register 6
###################################################################
class genPurpose6_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD6, value)
        return(value)


###################################################################
## General purpose register 7
###################################################################
class genPurpose7_class(object):
    def __init__(self, address):
        self.interface = 'svi3Ch'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEBD7, value)
        return(value)


###################################################################
## Fault sources from MCU temperature telemetry firmware
###################################################################
class mcuTempFlt_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED00, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuTempFlt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED00, None)
            self.tSpare2 = (self.reg_value >> 12) & 0x1
            self.tSpare1 = (self.reg_value >> 11) & 0x1
            self.tSpare0 = (self.reg_value >> 10) & 0x1
            self.otfC = (self.reg_value >> 9) & 0x1
            self.otf2 = (self.reg_value >> 8) & 0x1
            self.otw2 = (self.reg_value >> 7) & 0x1
            self.utf2 = (self.reg_value >> 6) & 0x1
            self.otf1 = (self.reg_value >> 5) & 0x1
            self.otw1 = (self.reg_value >> 4) & 0x1
            self.utf1 = (self.reg_value >> 3) & 0x1
            self.otf0 = (self.reg_value >> 2) & 0x1
            self.otw0 = (self.reg_value >> 1) & 0x1
            self.utf0 = self.reg_value & 0x1

    def read_object(self):
        return(self.mcuTempFlt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xEFFF) + ((register_object.tSpare2 & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.tSpare1 & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.tSpare0 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.otfC & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.otf2 & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.otw2 & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.utf2 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.otf1 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.otw1 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.utf1 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.otf0 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.otw0 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.utf0 & 0x1)
        dma(self.address, 0xED00, reg)
    ## Spare temperature fault source for rail 2 used for SDIF comm and config faults.
    def tSpare2(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 12, value)
        return(value)
    ## Spare temperature fault source for rail 1 used for SDIF comm and config faults.
    def tSpare1(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 11, value)
        return(value)
    ## Spare temperature fault source for rail 0 used for SDIF comm and config faults.
    def tSpare0(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 10, value)
        return(value)
    ## Internal temperature exceeds Over Temperature Fault threshold.
    def otfC(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 9, value)
        return(value)
    ## External temperature 2 exceeds Over Temperature Fault threshold.
    def otf2(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 8, value)
        return(value)
    ## External temperature 2 exceeds Over Temperature Warn threshold.
    def otw2(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 7, value)
        return(value)
    ## External temperature 2 exceeds Under Temperature Fault threshold.
    def utf2(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 6, value)
        return(value)
    ## External temperature 1 exceeds Over Temperature Fault threshold.
    def otf1(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 5, value)
        return(value)
    ## External temperature 1 exceeds Over Temperature Warn threshold.
    def otw1(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 4, value)
        return(value)
    ## External temperature 1 exceeds Under Temperature Fault threshold.
    def utf1(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 3, value)
        return(value)
    ## External temperature 0 exceeds Over Temperature Fault threshold.
    def otf0(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 2, value)
        return(value)
    ## External temperature 0 exceeds Over Temperature Warn threshold.
    def otw0(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 1, value)
        return(value)
    ## External temperature 0 exceeds Under Temperature Fault threshold.
    def utf0(self, value = None):
        value = dma_bits(0xED00, self.address, 1, 0, value)
        return(value)

###################################################################
## Fault sources from MCU firmware
###################################################################
class mcuFlt_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED01, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuFlt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED01, None)
            self.pstrapStore = (self.reg_value >> 13) & 0x1
            self.pstrapLoad = (self.reg_value >> 12) & 0x1
            self.passwordStore = (self.reg_value >> 11) & 0x1
            self.passwordLoad = (self.reg_value >> 10) & 0x1
            self.configStore = (self.reg_value >> 9) & 0x1
            self.configLoad = (self.reg_value >> 8) & 0x1
            self.configBusy = (self.reg_value >> 7) & 0x1
            self.configCrc = (self.reg_value >> 5) & 0x1
            self.configInvalid = (self.reg_value >> 4) & 0x1
            self.configFull = (self.reg_value >> 3) & 0x1
            self.bbReady = (self.reg_value >> 2) & 0x1
            self.bbFull = (self.reg_value >> 1) & 0x1
            self.cpuFault = self.reg_value & 0x1

    def read_object(self):
        return(self.mcuFlt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xDFFF) + ((register_object.pstrapStore & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.pstrapLoad & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.passwordStore & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.passwordLoad & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.configStore & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.configLoad & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.configBusy & 0x1) << 7)
        reg = (reg & 0xFFDF) + ((register_object.configCrc & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.configInvalid & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.configFull & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.bbReady & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.bbFull & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.cpuFault & 0x1)
        dma(self.address, 0xED01, reg)
    def pstrapStore(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 13, value)
        return(value)
    def pstrapLoad(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 12, value)
        return(value)
    ## Failed to write/store password
    def passwordStore(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 11, value)
        return(value)
    ## Failed to load password from OTP
    def passwordLoad(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 10, value)
        return(value)
    ## Failed to store configuration
    def configStore(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 9, value)
        return(value)
    ## Failed to load configuration
    def configLoad(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 8, value)
        return(value)
    ## Firmware is in the process of saving or restoring a configuration.
    def configBusy(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 7, value)
        return(value)
    ## Requested configuration CRC failed.
    def configCrc(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 5, value)
        return(value)
    ## Reguested configuration does not exist
    def configInvalid(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 4, value)
        return(value)
    ## All user configuration records are used
    def configFull(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 3, value)
        return(value)
    ## Black Box has a valid data record
    def bbReady(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 2, value)
        return(value)
    ## Black Box is Full
    def bbFull(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 1, value)
        return(value)
    ## Hard Fault has occurred (memory bus violation).
    def cpuFault(self, value = None):
        value = dma_bits(0xED01, self.address, 1, 0, value)
        return(value)

###################################################################
## Diagnostic faults
###################################################################
class diagFlt_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED02, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class diagFlt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED02, None)
            self.sdifStartup = (self.reg_value >> 15) & 0x1
            self.otpRemapRetry = (self.reg_value >> 14) & 0x1
            self.otpRemapLoad = (self.reg_value >> 13) & 0x1
            self.preFacRetry = (self.reg_value >> 12) & 0x1
            self.preFacLoad = (self.reg_value >> 11) & 0x1
            self.patchRetry = (self.reg_value >> 10) & 0x1
            self.patchLoad = (self.reg_value >> 9) & 0x1
            self.patchSize = (self.reg_value >> 8) & 0x1
            self.patchCrc = (self.reg_value >> 7) & 0x1
            self.mfrRetry = (self.reg_value >> 6) & 0x1
            self.mfrLoad = (self.reg_value >> 5) & 0x1
            self.mfrEmpty = (self.reg_value >> 4) & 0x1
            self.mfrCrc = (self.reg_value >> 3) & 0x1
            self.ramTest = (self.reg_value >> 2) & 0x1
            self.openPin = (self.reg_value >> 1) & 0x1
            self.romCrc = self.reg_value & 0x1

    def read_object(self):
        return(self.diagFlt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.sdifStartup & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.otpRemapRetry & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.otpRemapLoad & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.preFacRetry & 0x1) << 12)
        reg = (reg & 0xF7FF) + ((register_object.preFacLoad & 0x1) << 11)
        reg = (reg & 0xFBFF) + ((register_object.patchRetry & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.patchLoad & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.patchSize & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.patchCrc & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.mfrRetry & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.mfrLoad & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.mfrEmpty & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.mfrCrc & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.ramTest & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.openPin & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.romCrc & 0x1)
        dma(self.address, 0xED02, reg)
    ## SDIF initialization failure has occurred.
    def sdifStartup(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 15, value)
        return(value)
    ## OTPREMAP Data load required a retry
    def otpRemapRetry(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 14, value)
        return(value)
    ## OTPREMAP Data load failed
    def otpRemapLoad(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 13, value)
        return(value)
    ## Pre-Factory Data load required a retry
    def preFacRetry(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 12, value)
        return(value)
    ## Pre-Facotry Data load failed
    def preFacLoad(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 11, value)
        return(value)
    ## Patch Data load required a retry
    def patchRetry(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 10, value)
        return(value)
    ## Patch Data load failed
    def patchLoad(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 9, value)
        return(value)
    ## Patch Data size greater than maximum. Patch not loaded
    def patchSize(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 8, value)
        return(value)
    ## Patch Data failed CRC
    def patchCrc(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 7, value)
        return(value)
    ## Manufacturer/Test Data load required a retry
    def mfrRetry(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 6, value)
        return(value)
    ## Manufacturer/Test Data load failed
    def mfrLoad(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 5, value)
        return(value)
    ## Manufacturer/Test Data empty
    def mfrEmpty(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 4, value)
        return(value)
    ## Manufacturer/Test Data failed CRC
    def mfrCrc(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 3, value)
        return(value)
    ## RAM test failed.
    def ramTest(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 2, value)
        return(value)
    ## Device failed Open Pin test.
    def openPin(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 1, value)
        return(value)
    ## ROM CRC32 failed.
    def romCrc(self, value = None):
        value = dma_bits(0xED02, self.address, 1, 0, value)
        return(value)

###################################################################
## MCU Loop Manager Control
###################################################################
class mcuLpc_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED03, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuLpc_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED03, None)
            self.dnd2 = (self.reg_value >> 15) & 0x1
            self.sa2 = (self.reg_value >> 14) & 0x1
            self.sd2 = (self.reg_value >> 13) & 0x1
            self.pwrTest = (self.reg_value >> 12) & 0x1
            self.pinOpnEn1 = (self.reg_value >> 10) & 0x1
            self.pinOpnEn0 = (self.reg_value >> 9) & 0x1
            self.usePLL = (self.reg_value >> 8) & 0x1
            self.diagDone = (self.reg_value >> 7) & 0x1
            self.onOffInit = (self.reg_value >> 6) & 0x1
            self.dnd1 = (self.reg_value >> 5) & 0x1
            self.dnd0 = (self.reg_value >> 4) & 0x1
            self.sa1 = (self.reg_value >> 3) & 0x1
            self.sd1 = (self.reg_value >> 2) & 0x1
            self.sa0 = (self.reg_value >> 1) & 0x1
            self.sd0 = self.reg_value & 0x1

    def read_object(self):
        return(self.mcuLpc_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.dnd2 & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.sa2 & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.sd2 & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.pwrTest & 0x1) << 12)
        reg = (reg & 0xFBFF) + ((register_object.pinOpnEn1 & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.pinOpnEn0 & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.usePLL & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.diagDone & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.onOffInit & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.dnd1 & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.dnd0 & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.sa1 & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.sd1 & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.sa0 & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.sd0 & 0x1)
        dma(self.address, 0xED03, reg)
    ## Do not drop phases on channel 2
    def dnd2(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 15, value)
        return(value)
    ## Slow add phase channel 2
    def sa2(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 14, value)
        return(value)
    ## Slow drop phase channel 2
    def sd2(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 13, value)
        return(value)
    ## Command hardware to start power train tests
    def pwrTest(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 12, value)
        return(value)
    ## Activate the voltage sense pin open pull ups
    def pinOpnEn1(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 10, value)
        return(value)
    ## Activate the current sense pin open pull ups
    def pinOpnEn0(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 9, value)
        return(value)
    ## Use PLL clocks
    def usePLL(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 8, value)
        return(value)
    ## Diagnostics Done (0=diags active, 1=complete and loopMgr may run)
    def diagDone(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 7, value)
        return(value)
    ## Initialize loopMgr on-off state machine (both channels)
    def onOffInit(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 6, value)
        return(value)
    ## Do not drop phases on channel 1
    def dnd1(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 5, value)
        return(value)
    ## Do not drop phases on channel 0
    def dnd0(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 4, value)
        return(value)
    ## Slow add phase channel 1
    def sa1(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 3, value)
        return(value)
    ## Slow drop phase channel 1
    def sd1(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 2, value)
        return(value)
    ## Slow add phase channel 0
    def sa0(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 1, value)
        return(value)
    ## Slow drop phase channel 0
    def sd0(self, value = None):
        value = dma_bits(0xED03, self.address, 1, 0, value)
        return(value)

###################################################################
## MCU Control
###################################################################
class mcuCtl_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED04, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuCtl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED04, None)
            self.loadMemIntAddrOnce = (self.reg_value >> 10) & 0x1
            self.manPageSelect = (self.reg_value >> 9) & 0x1
            self.manPageControl = (self.reg_value >> 8) & 0x1
            self.enPmbGenInt = (self.reg_value >> 7) & 0x1
            self.fwResetSvi3 = (self.reg_value >> 6) & 0x1
            self.pllDeadClr = (self.reg_value >> 5) & 0x1
            self.pllDeadEn = (self.reg_value >> 4) & 0x1
            self.telUseSysClk = (self.reg_value >> 3) & 0x1
            self.otpWrtEn = (self.reg_value >> 2) & 0x1
            self.utcEnable = (self.reg_value >> 1) & 0x1
            self.remapEn = self.reg_value & 0x1

    def read_object(self):
        return(self.mcuCtl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFBFF) + ((register_object.loadMemIntAddrOnce & 0x1) << 10)
        reg = (reg & 0xFDFF) + ((register_object.manPageSelect & 0x1) << 9)
        reg = (reg & 0xFEFF) + ((register_object.manPageControl & 0x1) << 8)
        reg = (reg & 0xFF7F) + ((register_object.enPmbGenInt & 0x1) << 7)
        reg = (reg & 0xFFBF) + ((register_object.fwResetSvi3 & 0x1) << 6)
        reg = (reg & 0xFFDF) + ((register_object.pllDeadClr & 0x1) << 5)
        reg = (reg & 0xFFEF) + ((register_object.pllDeadEn & 0x1) << 4)
        reg = (reg & 0xFFF7) + ((register_object.telUseSysClk & 0x1) << 3)
        reg = (reg & 0xFFFB) + ((register_object.otpWrtEn & 0x1) << 2)
        reg = (reg & 0xFFFD) + ((register_object.utcEnable & 0x1) << 1)
        reg = (reg & 0xFFFE) + (register_object.remapEn & 0x1)
        dma(self.address, 0xED04, reg)
    ## Manage memory interrupt address buffer
    def loadMemIntAddrOnce(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 10, value)
        return(value)
    ## When not auto, select this UTC slot program page next (0=normal, 1=slow usually)
    def manPageSelect(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 9, value)
        return(value)
    ## Enable UTC slot program automatic page swapping (low power) if 0, else manual (FW) control
    def manPageControl(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 8, value)
        return(value)
    ## Enable generic PMBus interrupt
    def enPmbGenInt(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 7, value)
        return(value)
    ## 0 = run SVI3 normally 1 = hold SVI3 in reset state as if RESET_L was low
    def fwResetSvi3(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 6, value)
        return(value)
    ## 0 = Do not clear 1 = Allows Clock Divider to return to normal operation after pllDead removal
    def pllDeadClr(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 5, value)
        return(value)
    ## 0 = Disabled 1 = Allows Clock Divider to respond to pllDead condition
    def pllDeadEn(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 4, value)
        return(value)
    ## use sysClk for base telClk even if pll is used and locked
    def telUseSysClk(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 3, value)
        return(value)
    ## Enable writes to OTP if 1
    def otpWrtEn(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 2, value)
        return(value)
    ## Utility ADC controller enable: 0=disable 1=active
    def utcEnable(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 1, value)
        return(value)
    ## Map first 64 words ROM into RAM:  0=normal RAM 1=use ROM
    def remapEn(self, value = None):
        value = dma_bits(0xED04, self.address, 1, 0, value)
        return(value)

###################################################################
## Firmware phase current balance adjust, 0-3
###################################################################
class currBalPh03_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED05, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class currBalPh03_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED05, None)
            self.balPh3 = (self.reg_value >> 24) & 0xFF
            self.balPh2 = (self.reg_value >> 16) & 0xFF
            self.balPh1 = (self.reg_value >> 8) & 0xFF
            self.balPh0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.currBalPh03_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.balPh3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.balPh2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.balPh1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.balPh0 & 0xFF)
        dma(self.address, 0xED05, reg)
    ## Current balance adjust phase 3
    def balPh3(self, value = None):
        value = dma_bits(0xED05, self.address, 8, 24, value)
        return(value)
    ## Current balance adjust phase 2
    def balPh2(self, value = None):
        value = dma_bits(0xED05, self.address, 8, 16, value)
        return(value)
    ## Current balance adjust phase 1
    def balPh1(self, value = None):
        value = dma_bits(0xED05, self.address, 8, 8, value)
        return(value)
    ## Current balance adjust phase 0
    def balPh0(self, value = None):
        value = dma_bits(0xED05, self.address, 8, 0, value)
        return(value)

###################################################################
## Firmware phase current balance adjust, 4-7
###################################################################
class currBalPh47_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED06, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class currBalPh47_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED06, None)
            self.balPh7 = (self.reg_value >> 24) & 0xFF
            self.balPh6 = (self.reg_value >> 16) & 0xFF
            self.balPh5 = (self.reg_value >> 8) & 0xFF
            self.balPh4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.currBalPh47_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.balPh7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.balPh6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.balPh5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.balPh4 & 0xFF)
        dma(self.address, 0xED06, reg)
    ## Current balance adjust phase 7
    def balPh7(self, value = None):
        value = dma_bits(0xED06, self.address, 8, 24, value)
        return(value)
    ## Current balance adjust phase 6
    def balPh6(self, value = None):
        value = dma_bits(0xED06, self.address, 8, 16, value)
        return(value)
    ## Current balance adjust phase 5
    def balPh5(self, value = None):
        value = dma_bits(0xED06, self.address, 8, 8, value)
        return(value)
    ## Current balance adjust phase 4
    def balPh4(self, value = None):
        value = dma_bits(0xED06, self.address, 8, 0, value)
        return(value)

###################################################################
## Firmware phase current balance control
###################################################################
class currBalCtrl_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 1

    def __call__(self, value = None):
        value = dma(self.address, 0xED07, value)
        return(value)


###################################################################
## Firmware bad phase map
###################################################################
class mcuBadPhase_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED08, value)
        return(value)


###################################################################
## Firmware power & loop management command output
###################################################################
class mcuPhPwrMgt_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED09, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuPhPwrMgt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED09, None)
            self.manImonFltDetEn = (self.reg_value >> 8) & 0xFF
            self.manEnClkPh = self.reg_value & 0xFF

    def read_object(self):
        return(self.mcuPhPwrMgt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.manImonFltDetEn & 0xFF) << 8)
        reg = (reg & 0xFF00) + (register_object.manEnClkPh & 0xFF)
        dma(self.address, 0xED09, reg)
    ## Manual enable of pinOpnIsen sensors in Imon fault mode (no pullup)
    def manImonFltDetEn(self, value = None):
        value = dma_bits(0xED09, self.address, 8, 8, value)
        return(value)
    ## Manual enable of clocks for each phase
    def manEnClkPh(self, value = None):
        value = dma_bits(0xED09, self.address, 8, 0, value)
        return(value)

###################################################################
## Firmware power & loop management command output
###################################################################
class mcuPwrMgt_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuPwrMgt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED0A, None)
            self.mcuNeedPwmTerm2 = (self.reg_value >> 30) & 0x1
            self.mcuNeedPwmTerm1 = (self.reg_value >> 29) & 0x1
            self.mcuNeedPwmTerm0 = (self.reg_value >> 28) & 0x1
            self.mcuNeedIadc = (self.reg_value >> 24) & 0xF
            self.mcuNeedVadc = (self.reg_value >> 21) & 0x7
            self.mcuNeedPsys = (self.reg_value >> 20) & 0x1
            self.mcuNeedTel = (self.reg_value >> 19) & 0x1
            self.mcuNeedDll = (self.reg_value >> 18) & 0x1
            self.mcuNeedBg = (self.reg_value >> 17) & 0x1
            self.mcuNeedOsc = (self.reg_value >> 16) & 0x1
            self.manEnClkComm = (self.reg_value >> 15) & 0x1
            self.manEnClkCh2 = (self.reg_value >> 14) & 0x1
            self.manEnClkCh1 = (self.reg_value >> 13) & 0x1
            self.manEnClkCh0 = (self.reg_value >> 12) & 0x1
            self.selVccUvVsen2 = (self.reg_value >> 11) & 0x1
            self.selVccUvVsen1 = (self.reg_value >> 10) & 0x1
            self.selVccUvVsen0 = (self.reg_value >> 9) & 0x1
            self.sysIntEnable = (self.reg_value >> 8) & 0x1
            self.utcLpSel = (self.reg_value >> 7) & 0x1
            self.mcuCmdOnCh2 = (self.reg_value >> 6) & 0x1
            self.mcuCmdOnCh1 = (self.reg_value >> 5) & 0x1
            self.mcuCmdOnCh0 = (self.reg_value >> 4) & 0x1
            self.mcuMayRunCh2 = (self.reg_value >> 3) & 0x1
            self.mcuMayRunCh1 = (self.reg_value >> 2) & 0x1
            self.mcuMayRunCh0 = (self.reg_value >> 1) & 0x1
            self.sysPwrOk = self.reg_value & 0x1

    def read_object(self):
        return(self.mcuPwrMgt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xBFFFFFFF) + ((register_object.mcuNeedPwmTerm2 & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.mcuNeedPwmTerm1 & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.mcuNeedPwmTerm0 & 0x1) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.mcuNeedIadc & 0xF) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.mcuNeedVadc & 0x7) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.mcuNeedPsys & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.mcuNeedTel & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.mcuNeedDll & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.mcuNeedBg & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.mcuNeedOsc & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.manEnClkComm & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.manEnClkCh2 & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.manEnClkCh1 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.manEnClkCh0 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.selVccUvVsen2 & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.selVccUvVsen1 & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.selVccUvVsen0 & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.sysIntEnable & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.utcLpSel & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.mcuCmdOnCh2 & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.mcuCmdOnCh1 & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.mcuCmdOnCh0 & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.mcuMayRunCh2 & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.mcuMayRunCh1 & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.mcuMayRunCh0 & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.sysPwrOk & 0x1)
        dma(self.address, 0xED0A, reg)
    ## Firmware requires PWM mid-drive termination to be on, ch 2
    def mcuNeedPwmTerm2(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 30, value)
        return(value)
    ## Firmware requires PWM mid-drive termination to be on, ch 1
    def mcuNeedPwmTerm1(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 29, value)
        return(value)
    ## Firmware requires PWM mid-drive termination to be on, ch 0
    def mcuNeedPwmTerm0(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 28, value)
        return(value)
    ## Firmware requires Isen ADCs to run (if under automatic power management)
    def mcuNeedIadc(self, value = None):
        value = dma_bits(0xED0A, self.address, 4, 24, value)
        return(value)
    ## Firmware requires Vsen ADCs to run (if under automatic power management)
    def mcuNeedVadc(self, value = None):
        value = dma_bits(0xED0A, self.address, 3, 21, value)
        return(value)
    ## Firmware requires fast PSYS comparators (if under automatic power management)
    def mcuNeedPsys(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 20, value)
        return(value)
    ## Firmware requires Telemetry ADC to run (if under automatic power management)
    def mcuNeedTel(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 19, value)
        return(value)
    ## Firmware requires DLL to run (if under automatic power management)
    def mcuNeedDll(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 18, value)
        return(value)
    ## Firmware requires Switched cap Bandgap to run (if under automatic power management)
    def mcuNeedBg(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 17, value)
        return(value)
    ## Firmware requires oscillator to run (if under automatic power management)
    def mcuNeedOsc(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 16, value)
        return(value)
    ## Manual enable of clock for loop common circuitry
    def manEnClkComm(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 15, value)
        return(value)
    ## Manual enable of clock for channel 2
    def manEnClkCh2(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 14, value)
        return(value)
    ## Manual enable of clock for channel 1
    def manEnClkCh1(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 13, value)
        return(value)
    ## Manual enable of clock for channel 0
    def manEnClkCh0(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 12, value)
        return(value)
    ## Manual selection of Vsen2 comparator (1) VccUv brown-out detection, (0) OOV
    def selVccUvVsen2(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 11, value)
        return(value)
    ## Manual selection of Vsen1 comparator (1) VccUv brown-out detection, (0) OOV
    def selVccUvVsen1(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 10, value)
        return(value)
    ## Manual selection of Vsen0 comparator (1) VccUv brown-out detection, (0) OOV
    def selVccUvVsen0(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 9, value)
        return(value)
    ## Enable sysPwr interrupt
    def sysIntEnable(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 8, value)
        return(value)
    ## use low power shift selections in UTC to save power/slow down UTC
    def utcLpSel(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 7, value)
        return(value)
    ## Firmware commands channel 2 to run
    def mcuCmdOnCh2(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 6, value)
        return(value)
    ## Firmware commands channel 1 to run
    def mcuCmdOnCh1(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 5, value)
        return(value)
    ## Firmware commands channel 0 to run
    def mcuCmdOnCh0(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 4, value)
        return(value)
    ## Firmware permits channel 2 to run
    def mcuMayRunCh2(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 3, value)
        return(value)
    ## Firmware permits channel 1 to run
    def mcuMayRunCh1(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 2, value)
        return(value)
    ## Firmware permits channel 0 to run
    def mcuMayRunCh0(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 1, value)
        return(value)
    ## Firmware has system at full power condition
    def sysPwrOk(self, value = None):
        value = dma_bits(0xED0A, self.address, 1, 0, value)
        return(value)

###################################################################
## Enable interrupt on PMBus commands 1F-00
###################################################################
class pmbIrqMask0_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0B, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands 3F-20
###################################################################
class pmbIrqMask1_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0C, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands 5F-40
###################################################################
class pmbIrqMask2_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0D, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands 7F-60
###################################################################
class pmbIrqMask3_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0E, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands 9F-80
###################################################################
class pmbIrqMask4_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED0F, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands BF-A0
###################################################################
class pmbIrqMask5_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED10, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands DF-C0
###################################################################
class pmbIrqMask6_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED11, value)
        return(value)


###################################################################
## Enable interrupt on PMBus commands FF-E0
###################################################################
class pmbIrqMask7_class(object):
    def __init__(self, address):
        self.interface = 'mcuBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED12, value)
        return(value)


###################################################################
## MCU controls for target voltage and slew rate
###################################################################
class mcuSumVolt_class(object):
    def __init__(self, address):
        self.interface = 'mcuCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED20, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuSumVolt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED20, None)
            self.limitDecay = (self.reg_value >> 15) & 0x1
            self.mcuDecay = (self.reg_value >> 14) & 0x1
            self.mcuSetRate = (self.reg_value >> 13) & 0x1
            self.mcuSetVolt = (self.reg_value >> 12) & 0x1
            self.mcuSumVolt = self.reg_value & 0xFFF

    def read_object(self):
        return(self.mcuSumVolt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFF) + ((register_object.limitDecay & 0x1) << 15)
        reg = (reg & 0xBFFF) + ((register_object.mcuDecay & 0x1) << 14)
        reg = (reg & 0xDFFF) + ((register_object.mcuSetRate & 0x1) << 13)
        reg = (reg & 0xEFFF) + ((register_object.mcuSetVolt & 0x1) << 12)
        reg = (reg & 0xF000) + (register_object.mcuSumVolt & 0xFFF)
        dma(self.address, 0xED20, reg)
    ## Actively limit how fast the voltage decays to reduce repeated swings that can become audible
    def limitDecay(self, value = None):
        value = dma_bits(0xED20, self.address, 1, 15, value)
        return(value)
    ## If mcuSetRate=1, this bit selects passive decay down ramps (1) or active down ramps (0)
    def mcuDecay(self, value = None):
        value = dma_bits(0xED20, self.address, 1, 14, value)
        return(value)
    ## MCU takes control of DVID slew rates, via MCUONRISE register
    def mcuSetRate(self, value = None):
        value = dma_bits(0xED20, self.address, 1, 13, value)
        return(value)
    ## MCU takes control of target voltages, via MCUSUMVOLT
    def mcuSetVolt(self, value = None):
        value = dma_bits(0xED20, self.address, 1, 12, value)
        return(value)
    ## Target voltage, in millivolts
    def mcuSumVolt(self, value = None):
        value = dma_bits(0xED20, self.address, 12, 0, value)
        return(value)

###################################################################
## MCU writes power on ramp rate for channel 0 here
###################################################################
class mcuOnRise_class(object):
    def __init__(self, address):
        self.interface = 'mcuCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xED23, value)
        return(value)


###################################################################
## MCU writes power down ramp rate (AVS) for channel 0 here
###################################################################
class mcuOffFall_class(object):
    def __init__(self, address):
        self.interface = 'mcuCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xED26, value)
        return(value)


###################################################################
## Interrupt Status - post mask
###################################################################
class dMACIntStatus_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED30, value)
        return(value)


###################################################################
## Terminal Count Status - post mask
###################################################################
class dMACIntTCStatus_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED31, value)
        return(value)


###################################################################
## Terminal Count Interrupt
###################################################################
class dMACIntTCClear_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED32, value)
        return(value)


###################################################################
## Error Request - post mask
###################################################################
class dMACIntErrorStatus_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED33, value)
        return(value)


###################################################################
## Error Interrupt Clear
###################################################################
class dMACIntErrClr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED34, value)
        return(value)


###################################################################
## Terminal Count Reached - pre mask
###################################################################
class dMACRawIntTCStatus_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED35, value)
        return(value)


###################################################################
## Error Request - pre mask
###################################################################
class dMACRawIntErrorStatus_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED36, value)
        return(value)


###################################################################
## Channels Enabled
###################################################################
class dMACEnbldChns_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED37, value)
        return(value)


###################################################################
## ??????
###################################################################
class dMACSoftSReq_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED39, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACSoftSReq_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED39, None)
            self.softSReq7 = (self.reg_value >> 7) & 0x1
            self.softSReq6 = (self.reg_value >> 6) & 0x1
            self.softSReq5 = (self.reg_value >> 5) & 0x1
            self.softSReq4 = (self.reg_value >> 4) & 0x1
            self.softSReq3 = (self.reg_value >> 3) & 0x1
            self.softSReq2 = (self.reg_value >> 2) & 0x1
            self.softSReq1 = (self.reg_value >> 1) & 0x1
            self.softSReq0 = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACSoftSReq_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7F) + ((register_object.softSReq7 & 0x1) << 7)
        reg = (reg & 0xBF) + ((register_object.softSReq6 & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.softSReq5 & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.softSReq4 & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.softSReq3 & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.softSReq2 & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.softSReq1 & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.softSReq0 & 0x1)
        dma(self.address, 0xED39, reg)
    def softSReq7(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 7, value)
        return(value)
    def softSReq6(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 6, value)
        return(value)
    def softSReq5(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 5, value)
        return(value)
    def softSReq4(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 4, value)
        return(value)
    def softSReq3(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 3, value)
        return(value)
    def softSReq2(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 2, value)
        return(value)
    def softSReq1(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 1, value)
        return(value)
    def softSReq0(self, value = None):
        value = dma_bits(0xED39, self.address, 1, 0, value)
        return(value)

###################################################################
## Enables all DMAC Operations
###################################################################
class dMACConfiguration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xED3C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACConfiguration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED3C, None)
            self.crcTwoCycle = (self.reg_value >> 3) & 0x1
            self.unUsed2 = (self.reg_value >> 1) & 0x3
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACConfiguration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.crcTwoCycle & 0x1) << 3)
        reg = (reg & 0x9) + ((register_object.unUsed2 & 0x3) << 1)
        reg = (reg & 0xE) + (register_object.e & 0x1)
        dma(self.address, 0xED3C, reg)
    ## 1 = Enables Two Cycle CRC operation, 0 = Enables Four Cycle CRC operation (default)
    def crcTwoCycle(self, value = None):
        value = dma_bits(0xED3C, self.address, 1, 3, value)
        return(value)
    ## Unused (in ARM Primecell, these configure endianness of AHB Master 0 and 1)
    def unUsed2(self, value = None):
        value = dma_bits(0xED3C, self.address, 2, 1, value)
        return(value)
    ## Enables all DMAC Operations
    def e(self, value = None):
        value = dma_bits(0xED3C, self.address, 1, 0, value)
        return(value)

###################################################################
## CRC calculated
###################################################################
class dMACCRC_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED3D, value)
        return(value)


###################################################################
## Source Address for Channel 1
###################################################################
class dMACC1SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED48, value)
        return(value)


###################################################################
## Destination Address for Channel 1
###################################################################
class dMACC1DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED49, value)
        return(value)


###################################################################
## Control for Channel 1
###################################################################
class dMACC1Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED4B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC1Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED4B, None)
            self.unUsed3 = (self.reg_value >> 31) & 0x1
            self.unUsed2 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.unUsed1 = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC1Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed3 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed2 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.unUsed1 & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED4B, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed3(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED4B, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED4B, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED4B, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED4B, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED4B, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high - Unused
    def unUsed1(self, value = None):
        value = dma_bits(0xED4B, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED4B, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 1
###################################################################
class dMACC1Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED4C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC1Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED4C, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.unUsed = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC1Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.unUsed & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED4C, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED4C, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED4C, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED4C, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED4C, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit - unUsed
    def unUsed(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED4C, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED4C, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 2
###################################################################
class dMACC2SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED50, value)
        return(value)


###################################################################
## Destination Address for Channel 2
###################################################################
class dMACC2DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED51, value)
        return(value)


###################################################################
## Control for Channel 2
###################################################################
class dMACC2Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED53, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC2Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED53, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC2Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED53, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED53, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED53, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED53, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED53, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED53, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED53, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED53, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 2
###################################################################
class dMACC2Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED54, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC2Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED54, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC2Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED54, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED54, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED54, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED54, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED54, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED54, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED54, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 3
###################################################################
class dMACC3SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED58, value)
        return(value)


###################################################################
## Destination Address for Channel 3
###################################################################
class dMACC3DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED59, value)
        return(value)


###################################################################
## Control for Channel 3
###################################################################
class dMACC3Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED5B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC3Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED5B, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC3Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED5B, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED5B, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED5B, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED5B, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED5B, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED5B, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED5B, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED5B, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 3
###################################################################
class dMACC3Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED5C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC3Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED5C, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC3Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED5C, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED5C, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED5C, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED5C, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED5C, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED5C, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED5C, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 4
###################################################################
class dMACC4SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED60, value)
        return(value)


###################################################################
## Destination Address for Channel 4
###################################################################
class dMACC4DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED61, value)
        return(value)


###################################################################
## Control for Channel 1
###################################################################
class dMACC4Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED63, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC4Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED63, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC4Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED63, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED63, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED63, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED63, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED63, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED63, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED63, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED63, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 1
###################################################################
class dMACC4Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED64, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC4Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED64, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC4Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED64, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED64, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED64, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED64, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED64, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED64, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED64, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 5
###################################################################
class dMACC5SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED68, value)
        return(value)


###################################################################
## Destination Address for Channel 5
###################################################################
class dMACC5DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED69, value)
        return(value)


###################################################################
## Control for Channel 5
###################################################################
class dMACC5Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED6B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC5Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED6B, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC5Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED6B, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED6B, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED6B, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED6B, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED6B, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED6B, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED6B, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED6B, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 5
###################################################################
class dMACC5Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED6C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC5Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED6C, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC5Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED6C, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED6C, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED6C, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED6C, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED6C, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED6C, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED6C, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 6
###################################################################
class dMACC6SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED70, value)
        return(value)


###################################################################
## Destination Address for Channel 6
###################################################################
class dMACC6DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED71, value)
        return(value)


###################################################################
## Control for Channel 6
###################################################################
class dMACC6Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED73, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC6Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED73, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC6Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED73, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED73, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED73, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED73, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED73, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED73, self.address, 2, 14, value)
        return(value)
    ## 0 = Back to Back RW operations, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED73, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED73, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 6
###################################################################
class dMACC6Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED74, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC6Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED74, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC6Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED74, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED74, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED74, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED74, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED74, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED74, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED74, self.address, 1, 0, value)
        return(value)

###################################################################
## Source Address for Channel 7
###################################################################
class dMACC7SrcAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED78, value)
        return(value)


###################################################################
## Destination Address for Channel 7
###################################################################
class dMACC7DstAddr_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED79, value)
        return(value)


###################################################################
## Control for Channel 7
###################################################################
class dMACC7Control_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED7B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC7Control_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED7B, None)
            self.unUsed2 = (self.reg_value >> 31) & 0x1
            self.unUsed1 = (self.reg_value >> 28) & 0x7
            self.di = (self.reg_value >> 27) & 0x1
            self.si = (self.reg_value >> 26) & 0x1
            self.d = (self.reg_value >> 25) & 0x1
            self.s = (self.reg_value >> 24) & 0x1
            self.dWidth = (self.reg_value >> 21) & 0x7
            self.sWidth = (self.reg_value >> 18) & 0x7
            self.dbSize = (self.reg_value >> 16) & 0x3
            self.sbSize = (self.reg_value >> 14) & 0x3
            self.newOpWhenReady = (self.reg_value >> 13) & 0x1
            self.transferSize = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dMACC7Control_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.unUsed2 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed1 & 0x7) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.di & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.si & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.d & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.s & 0x1) << 24)
        reg = (reg & 0xFF1FFFFF) + ((register_object.dWidth & 0x7) << 21)
        reg = (reg & 0xFFE3FFFF) + ((register_object.sWidth & 0x7) << 18)
        reg = (reg & 0xFFFCFFFF) + ((register_object.dbSize & 0x3) << 16)
        reg = (reg & 0xFFFF3FFF) + ((register_object.sbSize & 0x3) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.newOpWhenReady & 0x1) << 13)
        reg = (reg & 0xFFFFE000) + (register_object.transferSize & 0x1FFF)
        dma(self.address, 0xED7B, reg)
    ## Terminal Count Interrupt enable bit - unUsed
    def unUsed2(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED7B, self.address, 3, 28, value)
        return(value)
    ## Destination increment
    def di(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 27, value)
        return(value)
    ## Source increment
    def si(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 26, value)
        return(value)
    ## Destination AHB Master select
    def d(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 25, value)
        return(value)
    ## Source AHB Master select
    def s(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 24, value)
        return(value)
    ## Destination Transfer Width
    def dWidth(self, value = None):
        value = dma_bits(0xED7B, self.address, 3, 21, value)
        return(value)
    ## Source Transfer Width
    def sWidth(self, value = None):
        value = dma_bits(0xED7B, self.address, 3, 18, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def dbSize(self, value = None):
        value = dma_bits(0xED7B, self.address, 2, 16, value)
        return(value)
    ## Bulk Transfer for Data Logging
    def sbSize(self, value = None):
        value = dma_bits(0xED7B, self.address, 2, 14, value)
        return(value)
    ## 0 = New Operation always, 1 = New Operation issued when ready is high
    def newOpWhenReady(self, value = None):
        value = dma_bits(0xED7B, self.address, 1, 13, value)
        return(value)
    ## Transfer size
    def transferSize(self, value = None):
        value = dma_bits(0xED7B, self.address, 13, 0, value)
        return(value)

###################################################################
## Configuration for Channel 7
###################################################################
class dMACC7Configuration_class(object):
    def __init__(self, address):
        self.interface = 'dmacBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED7C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dMACC7Configuration_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED7C, None)
            self.unUsed2 = (self.reg_value >> 20) & 0xFFF
            self.c = (self.reg_value >> 19) & 0x1
            self.h = (self.reg_value >> 18) & 0x1
            self.a = (self.reg_value >> 17) & 0x1
            self.skipWr = (self.reg_value >> 16) & 0x1
            self.itc = (self.reg_value >> 15) & 0x1
            self.ie = (self.reg_value >> 14) & 0x1
            self.flowCntrl = (self.reg_value >> 11) & 0x7
            self.unUsed1 = (self.reg_value >> 10) & 0x1
            self.destPeripheral = (self.reg_value >> 6) & 0xF
            self.doCRC = (self.reg_value >> 5) & 0x1
            self.srcPeripheral = (self.reg_value >> 1) & 0xF
            self.e = self.reg_value & 0x1

    def read_object(self):
        return(self.dMACC7Configuration_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFF) + ((register_object.unUsed2 & 0xFFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.c & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.h & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.a & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.skipWr & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.itc & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.ie & 0x1) << 14)
        reg = (reg & 0xFFFFC7FF) + ((register_object.flowCntrl & 0x7) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.unUsed1 & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.destPeripheral & 0xF) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.doCRC & 0x1) << 5)
        reg = (reg & 0xFFFFFFE1) + ((register_object.srcPeripheral & 0xF) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.e & 0x1)
        dma(self.address, 0xED7C, reg)
    ## Not used
    def unUsed2(self, value = None):
        value = dma_bits(0xED7C, self.address, 12, 20, value)
        return(value)
    ## Circular Buffer
    def c(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 19, value)
        return(value)
    ## Halt
    def h(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 18, value)
        return(value)
    ## Active
    def a(self):
        value = dma_bits(0xED7C, self.address, 1, 17, None)
        return(value)
    ## Write Cycle skipped, Used for CRC without write cycle
    def skipWr(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 16, value)
        return(value)
    ## Terminal Count Interrupt Mask
    def itc(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 15, value)
        return(value)
    ## Interrupt Error Mask
    def ie(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 14, value)
        return(value)
    ## Flow Control and Transfer Type
    def flowCntrl(self, value = None):
        value = dma_bits(0xED7C, self.address, 3, 11, value)
        return(value)
    ## Not used
    def unUsed1(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 10, value)
        return(value)
    ## Destination Peripheral
    def destPeripheral(self, value = None):
        value = dma_bits(0xED7C, self.address, 4, 6, value)
        return(value)
    ## Crc Enable Bit
    def doCRC(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 5, value)
        return(value)
    ## Source Peripheral
    def srcPeripheral(self, value = None):
        value = dma_bits(0xED7C, self.address, 4, 1, value)
        return(value)
    ## Channel Enable
    def e(self, value = None):
        value = dma_bits(0xED7C, self.address, 1, 0, value)
        return(value)

###################################################################
## Serial Logging Mask Register
###################################################################
class serLogCmdMask_class(object):
    def __init__(self, address):
        self.interface = 'serLogBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED80, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class serLogCmdMask_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED80, None)
            self.alertLogEn = (self.reg_value >> 31) & 0x1
            self.cmdMask = self.reg_value & 0x7FFFFFFF

    def read_object(self):
        return(self.serLogCmdMask_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.alertLogEn & 0x1) << 31)
        reg = (reg & 0x80000000) + (register_object.cmdMask & 0x7FFFFFFF)
        dma(self.address, 0xED80, reg)
    ## Alert Logger Enabled
    def alertLogEn(self, value = None):
        value = dma_bits(0xED80, self.address, 1, 31, value)
        return(value)
    ## Bit [30:0] Command Mask (one hot encoded per command to be filtered) 0 = Command is logged, 1 = Command is masked (NOT logged) <BR> For SVID the command list is given below <BR>0: Reserved_00h <BR>1: SetVID_fast <BR>2: SetVID_slow <BR>3: SetVID_Decay <BR>4: SetPS <BR>5: SetRegAddr <BR>6: SetRegData <BR>7: GetReg <BR>8: Test_Mode <BR>9: SetWP <BR>10: SetRegAddr_Vendor <BR>11: SetRegData_Vendor <BR>12: GetReg_Vendor <BR>13: GetReg_PktRecent <BR>14: GetReg_PktAlert <BR>15: GetReg_PktBad <BR>16: GetReg_VrEvent <BR>17: SetRegAddr_TestCfg <BR>18: SetRegAddr_TestCfg <BR>19: GetReg_TestCfg <BR>20-3F: Reserved_14h-Reserved_1fh <BR> <BR> For SVI3 the command list is given below <BR>0: reg_rd, <BR>1: reg_wr, <BR>2: chg_power, <BR>3: vid_cmd, <BR>4: init_cmd, <BR>5: en_crc, <BR>6: dis_crc, <BR>7: rst_vid, <BR>8: rst_allreg, <BR>9: addr_cmd, <BR>10: rst_reg, <BR>11: tel_cmd <BR>12: invalid_cmd, <BR>13~30: unused.
    def cmdMask(self, value = None):
        value = dma_bits(0xED80, self.address, 31, 0, value)
        return(value)

###################################################################
## Serial Logging Mask Register
###################################################################
class serLogAddrMask_class(object):
    def __init__(self, address):
        self.interface = 'serLogBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED81, value)
        return(value)


###################################################################
## Serial Logging Config Register
###################################################################
class serLogCfg_class(object):
    def __init__(self, address):
        self.interface = 'serLogBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED82, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class serLogCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED82, None)
            self.startStopSel = (self.reg_value >> 6) & 0x3FFFFFF
            self.stopSelect = (self.reg_value >> 4) & 0x3
            self.chan = (self.reg_value >> 1) & 0x7
            self.enable = self.reg_value & 0x1

    def read_object(self):
        return(self.serLogCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.startStopSel & 0x3FFFFFF) << 6)
        reg = (reg & 0xFFFFFFCF) + ((register_object.stopSelect & 0x3) << 4)
        reg = (reg & 0xFFFFFFF1) + ((register_object.chan & 0x7) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.enable & 0x1)
        dma(self.address, 0xED82, reg)
    ## Define which event starts/stops ser Logging events (single bit mask per event) <BR>  0 = svid SetVID_FAST command <BR>  1 = svid SetVID_SLOW command <BR>  2 = svid SetVID_DECAY command <BR>  3 = svid SetWP command <BR>  4 = svid Set Offset command <BR>  5 = svid Communication error <BR>  6 = svid ACK == 2'b00 <BR>  7 = svid ACK == 2'b01 <BR>  8 = svid ACK == 2'b10 <BR>  9 = svid ACK == 2'b11 <BR> 10 = svi3 NackStatus bit 0 <BR> 11 = svi3 NackStatus bit 1 <BR> 12 = svi3 NackStatus bit 2 <BR> 13 = svi3 NackStatus bit 3 <BR> 14 = svi3 NackStatus bit 4 <BR> 15 = svi3 NackStatus bit 5 <BR> 16 = svi3 FaultStatus bit 0 <BR> 17 = svi3 FaultStatus bit 1 <BR> 18 = svi3 FaultStatus bit 2 <BR> 19 = svi3 FaultStatus bit 3 <BR> 20 = svi3 FaultStatus bit 4 <BR> 21 = svi3 FaultStatus bit 5 <BR> 22 = svi3 RESET_L rising edge <BR> 23 = svi3 RESET_L falling edge <BR> 24 = GPIO trigger <BR> 25 = dcb event
    def startStopSel(self, value = None):
        value = dma_bits(0xED82, self.address, 26, 6, value)
        return(value)
    ## 0 = TransferSize (start at start trigger) <BR>1 = TransferSize/4 (stop TransferSize/4 after start trigger) <BR>2 = TransferSize/2 (stop TransferSize/2 after start trigger) <BR>3 = 3*TransferSize/4 (stop 3*TransferSize/4 after start trigger)
    def stopSelect(self, value = None):
        value = dma_bits(0xED82, self.address, 2, 4, value)
        return(value)
    ## Indicate DMA Channel used for serial logging
    def chan(self, value = None):
        value = dma_bits(0xED82, self.address, 3, 1, value)
        return(value)
    ## Enable logging
    def enable(self, value = None):
        value = dma_bits(0xED82, self.address, 1, 0, value)
        return(value)

###################################################################
## Read only register for Logger
###################################################################
class serLogPtr_class(object):
    def __init__(self, address):
        self.interface = 'serLogBus'
        self.address = address
        self.bits = 26

    def __call__(self, value = None):
        value = dma(self.address, 0xED83, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class serLogPtr_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED83, None)
            self.lastPointer = (self.reg_value >> 13) & 0x1FFF
            self.logPointer = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.serLogPtr_Object(self.address))

    ## Last written Pointer Register (value of counter that was last written to RAM)
    def lastPointer(self):
        value = dma_bits(0xED83, self.address, 13, 13, None)
        return(value)
    ## Log Pointer Register (value of counter when logEvent occurred)
    def logPointer(self):
        value = dma_bits(0xED83, self.address, 13, 0, None)
        return(value)

###################################################################
## Timestamp of first DCB Capture
###################################################################
class dcbTimeStamp_class(object):
    def __init__(self, address):
        self.interface = 'dcbBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xED84, value)
        return(value)


###################################################################
## Trigger Pointer Register
###################################################################
class dcbTrigReg_class(object):
    def __init__(self, address):
        self.interface = 'dcbBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xED85, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcbTrigReg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED85, None)
            self.dftTrigSel = (self.reg_value >> 14) & 0x3
            self.bufferFull = (self.reg_value >> 13) & 0x1
            self.trigPointer = self.reg_value & 0x1FFF

    def read_object(self):
        return(self.dcbTrigReg_Object(self.address))

    ## Select the DFT trigger select output
    def dftTrigSel(self, value = None):
        value = dma_bits(0xED85, self.address, 2, 14, value)
        return(value)
    ## 0 = Buffer Not Full, 1 = Buffer Full
    def bufferFull(self):
        value = dma_bits(0xED85, self.address, 1, 13, None)
        return(value)
    ## Trigger Pointer Register
    def trigPointer(self):
        value = dma_bits(0xED85, self.address, 13, 0, None)
        return(value)

###################################################################
## 
###################################################################
class dcbCfg_class(object):
    def __init__(self, address):
        self.interface = 'dcbBus'
        self.address = address
        self.bits = 23

    def __call__(self, value = None):
        value = dma(self.address, 0xED86, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcbCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED86, None)
            self.stopSelect = (self.reg_value >> 21) & 0x3
            self.oddCycleSel = (self.reg_value >> 15) & 0x3F
            self.trigSrc = (self.reg_value >> 11) & 0xF
            self.captStTrig = (self.reg_value >> 6) & 0x1F
            self.source = self.reg_value & 0x3F

    def read_object(self):
        return(self.dcbCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFF) + ((register_object.stopSelect & 0x3) << 21)
        reg = (reg & 0x607FFF) + ((register_object.oddCycleSel & 0x3F) << 15)
        reg = (reg & 0x7F87FF) + ((register_object.trigSrc & 0xF) << 11)
        reg = (reg & 0x7FF83F) + ((register_object.captStTrig & 0x1F) << 6)
        reg = (reg & 0x7FFFC0) + (register_object.source & 0x3F)
        dma(self.address, 0xED86, reg)
    ## 0 = TransferSize (start at start trigger) <BR>1 = TransferSize/4 (stop TransferSize/4 after start trigger) <BR>2 = TransferSize/2 (stop TransferSize/2 after start trigger) <BR>3 = 3*TransferSize/4 (stop 3*TransferSize/4 after start trigger)
    def stopSelect(self, value = None):
        value = dma_bits(0xED86, self.address, 2, 21, value)
        return(value)
    ## Selection of source for ODD DCB cycle <BR> ___uses same lookup table as source
    def oddCycleSel(self, value = None):
        value = dma_bits(0xED86, self.address, 6, 15, value)
        return(value)
    ## Trigger source<BR>0x0 clkTs Trigger DTB capture on each clkTs <BR>0x1 iSenValid clkTs && iSenDataTrigger <BR>0x2 telAdcValidMux telAdc data valid & DTBMUXSEL (telMuxSel = DCBCFG[5:0]) <BR>0x3 clkTs/2 Trigger DTB capture on each clkTs/2 <BR>0x4 telAdcValid telAdc Data Valid <BR>0x5 clkTs/4 Trigger DTB capture on each clkTs/4 <BR>0x6 clkTs/8 Trigger DTB capture on each clkTs/8 <BR>0x7 SVC External SVC pin <BR>0x8 clkTs/16 Trigger DTB capture on each clkTs/16 <BR>0x9 clkTs/32 Trigger DTB capture on each clkTs/32 <BR>0x0a 70us programmable UTC timer
    def trigSrc(self, value = None):
        value = dma_bits(0xED86, self.address, 4, 11, value)
        return(value)
    ## DCB Capture Start table<BR>0x0 Immediate Start DCB capture on first trigger after DMA is enabled <BR>0x1 DVIDchange Start DCB capture on DVID change <BR>0x2 (nvrhotPadInZ?) externalTrigger Start DCB capture on external trigger from GPIO0 rising edge <BR>0x3 vSenDataClip Start DCB when any vSen data detects a clip <BR>0x4 iSenDataClip Start DCB when any iSen data detects a clip <BR>0x5 iSenSelDataClip Start DCB when selected iSen data & DTBMUXSEL detects a clip <BR>0x6 triggerCh0 loop derived trigger <BR>0x7 triggerCh1 loop derived trigger <BR>0x8 triggerCh2 loop derived trigger <BR>0x9 triggerPh0 phase derived trigger <BR>0xA triggerPh1 phase derived trigger <BR>0xB triggerPh2 phase derived trigger <BR>0xC triggerPh3 phase derived trigger <BR>0xD triggerPh4 phase derived trigger <BR>0xE triggerPh5 phase derived trigger <BR>0xF triggerPh6 phase derived trigger <BR>0x10 triggerPh7 phase derived trigger <BR>0x11 lfsrTrig trigger on LFSR restart <BR>0x12 Snapshot Trigger <BR>0x13 Rise edge of nsvAlert <BR>0x14 Fall edge of nsvAlert <BR>0x15 Rise edge of PinAlert <BR>0x16 Fall edge of PinAlert <BR>0x17 Rise edge of PsysCrit <BR>0x18 Fall edge of PsysCrit <BR>0x19 Rise edge of OCPLZ <BR>0x1a Fall edge of OCPLZ <BR>0x1b logEvent
    def captStTrig(self, value = None):
        value = dma_bits(0xED86, self.address, 5, 6, value)
        return(value)
    ## Select input source from DCB Capture Input table <BR>0x0 0 - 16 <BR>0x1 vSen0DataPack clkTs 16 <BR>0x2 vSen1DataPack clkTs 16 <BR>0x3 vSen2DataPack clkTs 16 <BR>0x4 {telAdcData[13:0],telDataClip[1:0]} clkSys/(SampleCount+7) 16 <BR>0x5 {10'h0, muxSel[5:0]} clkSys/(SampleCount+7) 16 <BR>0x6 iSen0DataPack clkTs 16 <BR>0x7 iSen1DataPack clkTs 16 <BR>0x8 iSen2DataPack clkTs 16 <BR>0x9 iSen3DataPack clkTs 16 <BR>0xB {16'h0} <BR>0xC counter16Bit trigger 16 <BR>0xD monOutLoop0 clkTs 16 <BR>0xE monOutLoop1 clkTs 16 <BR>0xF monOutLoop2 clkTs 16 <BR>0x10 monOut0 clkTs 16 <BR>0x11 monOut1 clkTs 16 <BR>0x12 monOut2 clkTs 16 <BR>0x13 monOut3 clkTs 16 <BR>0x14 monOut4 clkTs 16 <BR>0x15 monOut5 clkTs 16 <BR>0x16 monOut6 clkTs 16 <BR>0x17 monOut7 clkTs 16 <BR>0x20 stBus.clkEnable1(lower 16 bits)<BR>0x21 stBus.clkEnable2(Upper 2 bytes)<BR>0x22 stBus.clkEnable2 (lower 2 bytes)<BR>0x2C overCurr clkTs PHASEBUSMSB* <BR>0x2E underCurr clkTs PHASEBUSMSB* <BR>0x30 {svidVout0[7:0],svidIout0[7:0]} <BR>0x31 {8'd0, svidPout0[7:0]} <BR>0x32 {svidVout1[7:0],svidIout1[7:0]} <BR>0x33 {8'd0, svidPout1[7:0]} <BR>0x34 {svidVout2[7:0],svidIout2[7:0]} <BR>0x35 {8'd0, svidPout2[7:0]} <BR>0x36 {svidVin0, svidIin0} <BR>0x37 {8'd0, svidPin0[7:0]} <BR>0x38 {svidVin1[7:0], svidIin1[7:0]} <BR>0x39 {8'd0, svidPin1[7:0]} <BR>0x3A {svidVin2[7:0], svidIin2[7:0]} <BR>0x3B {8'd0, svidPin2[7:0]} <BR>0x3C {svidVin3[7:0], svidIin3[7:0]} <BR>0x3D {8'd0, svidPin3[7:0]} <BR>0x3E {8'd0, svidIout3[7:0]}
    def source(self, value = None):
        value = dma_bits(0xED86, self.address, 6, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dcbIsenCfg_class(object):
    def __init__(self, address):
        self.interface = 'dcbBus'
        self.address = address
        self.bits = 11

    def __call__(self, value = None):
        value = dma(self.address, 0xED87, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dcbIsenCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED87, None)
            self.iSenAvgSel = (self.reg_value >> 10) & 0x1
            self.iSenDataPackSel = (self.reg_value >> 8) & 0x3
            self.iSenTrigSampB = (self.reg_value >> 7) & 0x1
            self.iSenTrigSampA = (self.reg_value >> 6) & 0x1
            self.iSenTrigAzData = (self.reg_value >> 5) & 0x1
            self.iSenTrigNonAzData = (self.reg_value >> 4) & 0x1
            self.iSenTrigPh3 = (self.reg_value >> 3) & 0x1
            self.iSenTrigPh2 = (self.reg_value >> 2) & 0x1
            self.iSenTrigPh1 = (self.reg_value >> 1) & 0x1
            self.iSenTrigPh0 = self.reg_value & 0x1

    def read_object(self):
        return(self.dcbIsenCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FF) + ((register_object.iSenAvgSel & 0x1) << 10)
        reg = (reg & 0x4FF) + ((register_object.iSenDataPackSel & 0x3) << 8)
        reg = (reg & 0x77F) + ((register_object.iSenTrigSampB & 0x1) << 7)
        reg = (reg & 0x7BF) + ((register_object.iSenTrigSampA & 0x1) << 6)
        reg = (reg & 0x7DF) + ((register_object.iSenTrigAzData & 0x1) << 5)
        reg = (reg & 0x7EF) + ((register_object.iSenTrigNonAzData & 0x1) << 4)
        reg = (reg & 0x7F7) + ((register_object.iSenTrigPh3 & 0x1) << 3)
        reg = (reg & 0x7FB) + ((register_object.iSenTrigPh2 & 0x1) << 2)
        reg = (reg & 0x7FD) + ((register_object.iSenTrigPh1 & 0x1) << 1)
        reg = (reg & 0x7FE) + (register_object.iSenTrigPh0 & 0x1)
        dma(self.address, 0xED87, reg)
    ## If set, the iSen data stored and used in synth and filtered is gated by iSenTrig instead of synth valid
    def iSenAvgSel(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 10, value)
        return(value)
    ## For vSenData: <BR> 0: vSenData[15:0] <BR> 1:{vSenData[15:3],dataValid,clipHi,clipLo} <BR> 2/3:{vSenData[15:2],clipHi,clipLo} <BR>  For iSenData: <BR>0:Data[11:0],clipAll[1:0],phSel[1:0] <BR>1:Data[11:0],phSel[1:0],dataValid,cnvt8<BR>2:Data[11:0],phSel[1:0],selSamp,azSel <BR>3:Data[11:0],phSel[1:0],selSamp,adcMode <BR> For telData: <BR> 0:anaComTelAdcCalc[15:0] <BR> 1:{anaComTelAdcCalc[15:2],telDataClip}
    def iSenDataPackSel(self, value = None):
        value = dma_bits(0xED87, self.address, 2, 8, value)
        return(value)
    ## Enable iSen Trigger for Sample B data
    def iSenTrigSampB(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 7, value)
        return(value)
    ## Enable iSen Trigger for Sample A data
    def iSenTrigSampA(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 6, value)
        return(value)
    ## Enable iSen Trigger for auto-zero data / dcbTelSlotSel[5]
    def iSenTrigAzData(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 5, value)
        return(value)
    ## Enable iSen Trigger for non-AutoZero data  / dcbTelSlotSel[4]
    def iSenTrigNonAzData(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 4, value)
        return(value)
    ## Enable iSen Trigger for ph3 data / dcbTelSlotSel[3]
    def iSenTrigPh3(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 3, value)
        return(value)
    ## Enable iSen Trigger for ph2 data / dcbTelSlotSel[2]
    def iSenTrigPh2(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 2, value)
        return(value)
    ## Enable iSen Trigger for ph1 data / dcbTelSlotSel[1]
    def iSenTrigPh1(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 1, value)
        return(value)
    ## Enable iSen Trigger for ph0 data / dcbTelSlotSel[0]
    def iSenTrigPh0(self, value = None):
        value = dma_bits(0xED87, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class dpbCfg_class(object):
    def __init__(self, address):
        self.interface = 'dpbBus'
        self.address = address
        self.bits = 4

    def __call__(self, value = None):
        value = dma(self.address, 0xED88, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class dpbCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED88, None)
            self.dpbTrig = (self.reg_value >> 3) & 0x1
            self.dpbInOutZ = (self.reg_value >> 2) & 0x1
            self.unUsed01 = self.reg_value & 0x3

    def read_object(self):
        return(self.dpbCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.dpbTrig & 0x1) << 3)
        reg = (reg & 0xB) + ((register_object.dpbInOutZ & 0x1) << 2)
        reg = (reg & 0xC) + (register_object.unUsed01 & 0x3)
        dma(self.address, 0xED88, reg)
    ## 0=Ignore Trigger pin input, 1 = Consider Trigger pin input to qualify incoming clocks
    def dpbTrig(self, value = None):
        value = dma_bits(0xED88, self.address, 1, 3, value)
        return(value)
    ## 0=DPB Out to Pins, 1 = DPB In from Pins
    def dpbInOutZ(self, value = None):
        value = dma_bits(0xED88, self.address, 1, 2, value)
        return(value)
    ## Not used
    def unUsed01(self, value = None):
        value = dma_bits(0xED88, self.address, 2, 0, value)
        return(value)

###################################################################
## 
###################################################################
class sdifCfg_class(object):
    def __init__(self, address):
        self.interface = 'sdifBus'
        self.address = address
        self.bits = 5

    def __call__(self, value = None):
        value = dma(self.address, 0xED89, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sdifCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED89, None)
            self.sdifClkDiv = (self.reg_value >> 3) & 0x3
            self.sdifAzClkDiv = (self.reg_value >> 1) & 0x3
            self.sdifEnable = self.reg_value & 0x1

    def read_object(self):
        return(self.sdifCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.sdifClkDiv & 0x3) << 3)
        reg = (reg & 0x19) + ((register_object.sdifAzClkDiv & 0x3) << 1)
        reg = (reg & 0x1E) + (register_object.sdifEnable & 0x1)
        dma(self.address, 0xED89, reg)
    ## Select clock divider to generate SDIF Clock <BR>0x0 - 2MHz, <BR>0x1 - 1.5MHz, <BR>0x2 - 1MHz, <BR>0x3 - 750kHz
    def sdifClkDiv(self, value = None):
        value = dma_bits(0xED89, self.address, 2, 3, value)
        return(value)
    ## Select clock divider to generate SDIF AZ Clock Pulse <BR>0x0 - 499.68ns, <BR>0x1 - 999.36ns, <BR>0x2 - 1499.04ns, <BR>0x3 - 1998.72ns
    def sdifAzClkDiv(self, value = None):
        value = dma_bits(0xED89, self.address, 2, 1, value)
        return(value)
    ## Enable the SDIF Interface
    def sdifEnable(self, value = None):
        value = dma_bits(0xED89, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class sdifMsg_class(object):
    def __init__(self, address):
        self.interface = 'sdifBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED8A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sdifMsg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8A, None)
            self.sdifRegData = (self.reg_value >> 24) & 0xFF
            self.unused = (self.reg_value >> 18) & 0x3F
            self.sdifCmdCount = (self.reg_value >> 14) & 0xF
            self.sdifRegAddr = (self.reg_value >> 10) & 0xF
            self.sdifAddr = (self.reg_value >> 6) & 0xF
            self.sdifCmd = (self.reg_value >> 2) & 0xF
            self.sdifIntEnable = (self.reg_value >> 1) & 0x1
            self.sdifSend = self.reg_value & 0x1

    def read_object(self):
        return(self.sdifMsg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.sdifRegData & 0xFF) << 24)
        reg = (reg & 0xFF03FFFF) + ((register_object.unused & 0x3F) << 18)
        reg = (reg & 0xFFFC3FFF) + ((register_object.sdifCmdCount & 0xF) << 14)
        reg = (reg & 0xFFFFC3FF) + ((register_object.sdifRegAddr & 0xF) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.sdifAddr & 0xF) << 6)
        reg = (reg & 0xFFFFFFC3) + ((register_object.sdifCmd & 0xF) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.sdifIntEnable & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.sdifSend & 0x1)
        dma(self.address, 0xED8A, reg)
    ## The data to be written using REGWRITE command is written to this location. The data from the REGREAD is read from here.
    def sdifRegData(self, value = None):
        value = dma_bits(0xED8A, self.address, 8, 24, value)
        return(value)
    ## Not used
    def unused(self, value = None):
        value = dma_bits(0xED8A, self.address, 6, 18, value)
        return(value)
    ## The number of bytes (sdifCmdCount + 1) that should be chained together using auto-increment for REGREAD/REGWRITE. The read value from this register shows actual count during the SDIF Transfer.
    def sdifCmdCount(self, value = None):
        value = dma_bits(0xED8A, self.address, 4, 14, value)
        return(value)
    ## The adddress of the specific register within the SPS chip that you want to REGREAD/REGWRITE (For INIT command, put the Individual address here)
    def sdifRegAddr(self, value = None):
        value = dma_bits(0xED8A, self.address, 4, 10, value)
        return(value)
    ## The address of the SPS chip that you want to communicate with (For INIT command, put the Group address here)
    def sdifAddr(self, value = None):
        value = dma_bits(0xED8A, self.address, 4, 6, value)
        return(value)
    ## The command that you want to send on SDIF Bus <BR>0x0 INIT command  (sdifAddr = Group Addr; sdifRegAddr = Individual Addr; sdifSend = 1) <BR>0x1 SDIF REG READ (sdifAddr = Ind Addr of Owl; sdifRegAddr = Register Addr within Owl; sdifCmdCount = 1 + Number of addresses to read from; sdifSend = 1; sdifRegData = Read data shows up in here) <BR>0x2 SDIF REG WRITE (sdifAddr = Grp/Ind Addr of Owl; sdifRegAddr = Register Addr within Owl; sdifCmdCount = 1 + Number of addresses to write to ; sdifRegData = Put data to be written, here. sdifSend = 1; Write data sdifRegData field) <BR>0x3 SETSPSMODE0   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x4 SETSPSMODE1   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x5 SETSPSMODE2   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x6 SETSPSMODE3   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x7 SETSPSMODE4   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x8 SETSPSMODE5   (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0x9 GETTEMP       (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0xA GETTEMPAZ     (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0xB GETVOLT       (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0xC STARTAZ       (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1) <BR>0xF DUN Command (sdifAddr = Grp/Ind Addr of Owl; sdifSend = 1)
    def sdifCmd(self, value = None):
        value = dma_bits(0xED8A, self.address, 4, 2, value)
        return(value)
    ## 1 = Enable generation of Interrupt for this message upon completion. 0 = Disable Interrupt.
    def sdifIntEnable(self, value = None):
        value = dma_bits(0xED8A, self.address, 1, 1, value)
        return(value)
    ## Setting this bit initiates an SDIF command. This bit auto-clears.
    def sdifSend(self, value = None):
        value = dma_bits(0xED8A, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class sdifStatus_class(object):
    def __init__(self, address):
        self.interface = 'sdifBus'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xED8B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sdifStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8B, None)
            self.sdifAck1 = (self.reg_value >> 11) & 0x3
            self.sdifAck2 = (self.reg_value >> 9) & 0x3
            self.sdifAck3 = (self.reg_value >> 7) & 0x3
            self.fwCmdInProgress = (self.reg_value >> 6) & 0x1
            self.lpCmdInProgress = (self.reg_value >> 5) & 0x1
            self.sdifInProg = (self.reg_value >> 4) & 0x1
            self.sdifParityReply = (self.reg_value >> 3) & 0x1
            self.sdifParityErr = (self.reg_value >> 2) & 0x1
            self.sdifAck = self.reg_value & 0x3

    def read_object(self):
        return(self.sdifStatus_Object(self.address))

    ## Report Status of the ACK1 for the command <BR> 0x0 BUSERR <BR> 0x1 ACK <BR> 0x2 REJ <BR> 0x3 NACK
    def sdifAck1(self):
        value = dma_bits(0xED8B, self.address, 2, 11, None)
        return(value)
    ## Report Status of the ACK2 for the command <BR> 0x0 BUSERR <BR> 0x1 ACK <BR> 0x2 REJ <BR> 0x3 NACK
    def sdifAck2(self):
        value = dma_bits(0xED8B, self.address, 2, 9, None)
        return(value)
    ## Report Status of the ACK3 for the command <BR> 0x0 BUSERR <BR> 0x1 ACK <BR> 0x2 REJ <BR> 0x3 NACK
    def sdifAck3(self):
        value = dma_bits(0xED8B, self.address, 2, 7, None)
        return(value)
    ## Indicate FW command is in progress
    def fwCmdInProgress(self):
        value = dma_bits(0xED8B, self.address, 1, 6, None)
        return(value)
    ## Indicate LP command is in progress
    def lpCmdInProgress(self):
        value = dma_bits(0xED8B, self.address, 1, 5, None)
        return(value)
    ## Indicate command is in progress
    def sdifInProg(self):
        value = dma_bits(0xED8B, self.address, 1, 4, None)
        return(value)
    ## Indicate parity value in read-back transmission
    def sdifParityReply(self):
        value = dma_bits(0xED8B, self.address, 1, 3, None)
        return(value)
    ## 1 = Indicate parity error in read-back transmission
    def sdifParityErr(self):
        value = dma_bits(0xED8B, self.address, 1, 2, None)
        return(value)
    ## Report Status of the ACK (Combined using priority method) for the command <BR> 0x0 BUSERR <BR> 0x1 ACK <BR> 0x2 REJ <BR> 0x3 NACK
    def sdifAck(self):
        value = dma_bits(0xED8B, self.address, 2, 0, None)
        return(value)

###################################################################
## SDIF Group Address
###################################################################
class sdifGrpAddr_class(object):
    def __init__(self, address):
        self.interface = 'sdifBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED8C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sdifGrpAddr_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8C, None)
            self.sdifGrpAddr7 = (self.reg_value >> 28) & 0xF
            self.sdifGrpAddr6 = (self.reg_value >> 24) & 0xF
            self.sdifGrpAddr5 = (self.reg_value >> 20) & 0xF
            self.sdifGrpAddr4 = (self.reg_value >> 16) & 0xF
            self.sdifGrpAddr3 = (self.reg_value >> 12) & 0xF
            self.sdifGrpAddr2 = (self.reg_value >> 8) & 0xF
            self.sdifGrpAddr1 = (self.reg_value >> 4) & 0xF
            self.sdifGrpAddr0 = self.reg_value & 0xF

    def read_object(self):
        return(self.sdifGrpAddr_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.sdifGrpAddr7 & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.sdifGrpAddr6 & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.sdifGrpAddr5 & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.sdifGrpAddr4 & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.sdifGrpAddr3 & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.sdifGrpAddr2 & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.sdifGrpAddr1 & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.sdifGrpAddr0 & 0xF)
        dma(self.address, 0xED8C, reg)
    ## Group Address for SPS 7
    def sdifGrpAddr7(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 28, value)
        return(value)
    ## Group Address for SPS 6
    def sdifGrpAddr6(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 24, value)
        return(value)
    ## Group Address for SPS 5
    def sdifGrpAddr5(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 20, value)
        return(value)
    ## Group Address for SPS 4
    def sdifGrpAddr4(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 16, value)
        return(value)
    ## Group Address for SPS 3
    def sdifGrpAddr3(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 12, value)
        return(value)
    ## Group Address for SPS 2
    def sdifGrpAddr2(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 8, value)
        return(value)
    ## Group Address for SPS 1
    def sdifGrpAddr1(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 4, value)
        return(value)
    ## Group Address for SPS 0
    def sdifGrpAddr0(self, value = None):
        value = dma_bits(0xED8C, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class spsMgrCfg_class(object):
    def __init__(self, address):
        self.interface = 'spsMgr'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED8D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class spsMgrCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8D, None)
            self.rstIsenAzFilt = (self.reg_value >> 5) & 0x7
            self.disIsenAdcAz = (self.reg_value >> 2) & 0x7
            self.computeLpDiff = (self.reg_value >> 1) & 0x1
            self.spsFwOverride = self.reg_value & 0x1

    def read_object(self):
        return(self.spsMgrCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.rstIsenAzFilt & 0x7) << 5)
        reg = (reg & 0xE3) + ((register_object.disIsenAdcAz & 0x7) << 2)
        reg = (reg & 0xFD) + ((register_object.computeLpDiff & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.spsFwOverride & 0x1)
        dma(self.address, 0xED8D, reg)
    ## Reset the Isen autozero filter by channel, it will reinitialize on first sample when reset disabled
    def rstIsenAzFilt(self, value = None):
        value = dma_bits(0xED8D, self.address, 3, 5, value)
        return(value)
    ## Disable normal Isen Adc autozero operation by channel (so SDIF autozero can be used)
    def disIsenAdcAz(self, value = None):
        value = dma_bits(0xED8D, self.address, 3, 2, value)
        return(value)
    ## (0 = Do Not compute Diff for individual phases in SPS Mgr, 1 = Compute Diff for individual phases in SPS Mgr)
    def computeLpDiff(self, value = None):
        value = dma_bits(0xED8D, self.address, 1, 1, value)
        return(value)
    ## SPS Mgr Firmware Override (0 = Do NOT override loop commands, 1 = override loop commands)
    def spsFwOverride(self, value = None):
        value = dma_bits(0xED8D, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class spsMgrStatus_class(object):
    def __init__(self, address):
        self.interface = 'spsMgr'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED8E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class spsMgrStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8E, None)
            self.spsMode7 = (self.reg_value >> 28) & 0xF
            self.spsMode6 = (self.reg_value >> 24) & 0xF
            self.spsMode5 = (self.reg_value >> 20) & 0xF
            self.spsMode4 = (self.reg_value >> 16) & 0xF
            self.spsMode3 = (self.reg_value >> 12) & 0xF
            self.spsMode2 = (self.reg_value >> 8) & 0xF
            self.spsMode1 = (self.reg_value >> 4) & 0xF
            self.spsMode0 = self.reg_value & 0xF

    def read_object(self):
        return(self.spsMgrStatus_Object(self.address))

    ## SPS Mode for SPS 7
    def spsMode7(self):
        value = dma_bits(0xED8E, self.address, 4, 28, None)
        return(value)
    ## SPS Mode for SPS 6
    def spsMode6(self):
        value = dma_bits(0xED8E, self.address, 4, 24, None)
        return(value)
    ## SPS Mode for SPS 5
    def spsMode5(self):
        value = dma_bits(0xED8E, self.address, 4, 20, None)
        return(value)
    ## SPS Mode for SPS 4
    def spsMode4(self):
        value = dma_bits(0xED8E, self.address, 4, 16, None)
        return(value)
    ## SPS Mode for SPS 3
    def spsMode3(self):
        value = dma_bits(0xED8E, self.address, 4, 12, None)
        return(value)
    ## SPS Mode for SPS 2
    def spsMode2(self):
        value = dma_bits(0xED8E, self.address, 4, 8, None)
        return(value)
    ## SPS Mode for SPS 1
    def spsMode1(self):
        value = dma_bits(0xED8E, self.address, 4, 4, None)
        return(value)
    ## SPS Mode for SPS 0
    def spsMode0(self):
        value = dma_bits(0xED8E, self.address, 4, 0, None)
        return(value)

###################################################################
## Control settings for SDIF temperature/VDD measurements
###################################################################
class spsTmonCfg_class(object):
    def __init__(self, address):
        self.interface = 'spsMgr'
        self.address = address
        self.bits = 30

    def __call__(self, value = None):
        value = dma(self.address, 0xED8F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class spsTmonCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED8F, None)
            self.blockDM5toDM0 = (self.reg_value >> 29) & 0x1
            self.blockDM3toDM0 = (self.reg_value >> 28) & 0x1
            self.blockDM2toDM0 = (self.reg_value >> 27) & 0x1
            self.blockDM1toDM0 = (self.reg_value >> 26) & 0x1
            self.disableDm4PwmWake = (self.reg_value >> 25) & 0x1
            self.tmonReadyOvrEn = (self.reg_value >> 24) & 0x1
            self.tmonReadyOvrVal = (self.reg_value >> 23) & 0x1
            self.sdifTempSel = (self.reg_value >> 21) & 0x3
            self.tmonWindowSize = (self.reg_value >> 16) & 0x1F
            self.tmonDelayCfg = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.spsTmonCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFFF) + ((register_object.blockDM5toDM0 & 0x1) << 29)
        reg = (reg & 0x2FFFFFFF) + ((register_object.blockDM3toDM0 & 0x1) << 28)
        reg = (reg & 0x37FFFFFF) + ((register_object.blockDM2toDM0 & 0x1) << 27)
        reg = (reg & 0x3BFFFFFF) + ((register_object.blockDM1toDM0 & 0x1) << 26)
        reg = (reg & 0x3DFFFFFF) + ((register_object.disableDm4PwmWake & 0x1) << 25)
        reg = (reg & 0x3EFFFFFF) + ((register_object.tmonReadyOvrEn & 0x1) << 24)
        reg = (reg & 0x3F7FFFFF) + ((register_object.tmonReadyOvrVal & 0x1) << 23)
        reg = (reg & 0x3F9FFFFF) + ((register_object.sdifTempSel & 0x3) << 21)
        reg = (reg & 0x3FE0FFFF) + ((register_object.tmonWindowSize & 0x1F) << 16)
        reg = (reg & 0x3FFF0000) + (register_object.tmonDelayCfg & 0xFFFF)
        dma(self.address, 0xED8F, reg)
    ## Block the SDIF message to set an individual phase to DM0 if in DM5, use PWM wakeup only
    def blockDM5toDM0(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 29, value)
        return(value)
    ## Block the SDIF message to set an individual phase to DM0 if in DM3, use PWM wakeup only
    def blockDM3toDM0(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 28, value)
        return(value)
    ## Block the SDIF message to set an individual phase to DM0 if in DM2, use PWM wakeup only
    def blockDM2toDM0(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 27, value)
        return(value)
    ## Block the SDIF message to set an individual phase to DM0 if in DM1, use PWM wakeup only
    def blockDM1toDM0(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 26, value)
        return(value)
    ## Disable DM4 wakeup based on PWM(0 = Wakeup with PWM or SDIF, 1 = do NOT wakeup based on PWM, respond only to SDIF)
    def disableDm4PwmWake(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 25, value)
        return(value)
    ## SPS Mgr Tmon Ready Override (0 = Do NOT override, 1 = override with OvrVal)
    def tmonReadyOvrEn(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 24, value)
        return(value)
    ## SPS Mgr Tmon Ready Override Value
    def tmonReadyOvrVal(self, value = None):
        value = dma_bits(0xED8F, self.address, 1, 23, value)
        return(value)
    ## Which TEMP pin SDIF SPSs are tied to 0=none, 1=TEMP0, 2=TEMP1, 3=TEMP2
    def sdifTempSel(self, value = None):
        value = dma_bits(0xED8F, self.address, 2, 21, value)
        return(value)
    ## Number of TEMP samples to average for one phase measurement, interrupt MCU once this many readings
    def tmonWindowSize(self, value = None):
        value = dma_bits(0xED8F, self.address, 5, 16, value)
        return(value)
    ## TMON ready delay for analog settling, Val * clkTs, default is 32 * 82ns, CAN TRIM BITS FROM HERE
    def tmonDelayCfg(self, value = None):
        value = dma_bits(0xED8F, self.address, 16, 0, value)
        return(value)

###################################################################
## Loop signal override values
###################################################################
class overrideOc_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED90, value)
        return(value)


###################################################################
## Loop signal override values
###################################################################
class overrideUc_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED91, value)
        return(value)


###################################################################
## Control PWM output and over.under current flags
###################################################################
class ctrlOverride_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 6

    def __call__(self, value = None):
        value = dma(self.address, 0xED92, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class ctrlOverride_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED92, None)
            self.maskOC = (self.reg_value >> 5) & 0x1
            self.maskUC = (self.reg_value >> 4) & 0x1
            self.forceOC = (self.reg_value >> 3) & 0x1
            self.forceUC = (self.reg_value >> 2) & 0x1

    def read_object(self):
        return(self.ctrlOverride_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1F) + ((register_object.maskOC & 0x1) << 5)
        reg = (reg & 0x2F) + ((register_object.maskUC & 0x1) << 4)
        reg = (reg & 0x37) + ((register_object.forceOC & 0x1) << 3)
        reg = (reg & 0x3B) + ((register_object.forceUC & 0x1) << 2)
        dma(self.address, 0xED92, reg)
    ## Bit-wise AND overcurrent signals with bit-mask when 1
    def maskOC(self, value = None):
        value = dma_bits(0xED92, self.address, 1, 5, value)
        return(value)
    ## Bit-wise AND undercurrent signals with bit-mask when 1
    def maskUC(self, value = None):
        value = dma_bits(0xED92, self.address, 1, 4, value)
        return(value)
    ## Force overcurrent signals to follow bit-mask when 1
    def forceOC(self, value = None):
        value = dma_bits(0xED92, self.address, 1, 3, value)
        return(value)
    ## Force undercurrent signals to follow bit-mask when 1
    def forceUC(self, value = None):
        value = dma_bits(0xED92, self.address, 1, 2, value)
        return(value)

###################################################################
## 
###################################################################
class csXbar0_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED93, value)
        return(value)


###################################################################
## 
###################################################################
class csXbar1_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED94, value)
        return(value)


###################################################################
## 
###################################################################
class csXbar2_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED95, value)
        return(value)


###################################################################
## 
###################################################################
class csXbar3_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED96, value)
        return(value)


###################################################################
## MCU Debugger Pin Select
###################################################################
class mcuDbgPinSel_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED97, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class mcuDbgPinSel_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED97, None)
            self.dbgTrigSel = (self.reg_value >> 24) & 0xFF
            self.swDioSel = (self.reg_value >> 16) & 0xFF
            self.unUsed01 = (self.reg_value >> 8) & 0xFF
            self.swClkSel = self.reg_value & 0xFF

    def read_object(self):
        return(self.mcuDbgPinSel_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.dbgTrigSel & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.swDioSel & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.unUsed01 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.swClkSel & 0xFF)
        dma(self.address, 0xED97, reg)
    def dbgTrigSel(self, value = None):
        value = dma_bits(0xED97, self.address, 8, 24, value)
        return(value)
    ## Select nPINALERT pin for SWDIO
    def swDioSel(self, value = None):
        value = dma_bits(0xED97, self.address, 8, 16, value)
        return(value)
    ## Not used
    def unUsed01(self, value = None):
        value = dma_bits(0xED97, self.address, 8, 8, value)
        return(value)
    ## Selecti nVRHOT pin for SWCLK
    def swClkSel(self, value = None):
        value = dma_bits(0xED97, self.address, 8, 0, value)
        return(value)

###################################################################
## High Speed Bus interrupt trap - IRQ8
###################################################################
class hsBusInt_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED98, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class hsBusInt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED98, None)
            self.hsIntEn = (self.reg_value >> 31) & 0x1
            self.unUsed02 = (self.reg_value >> 28) & 0x7
            self.trapAddrMask = (self.reg_value >> 16) & 0xFFF
            self.unUsed01 = (self.reg_value >> 12) & 0xF
            self.trapAddr = self.reg_value & 0xFFF

    def read_object(self):
        return(self.hsBusInt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.hsIntEn & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed02 & 0x7) << 28)
        reg = (reg & 0xF000FFFF) + ((register_object.trapAddrMask & 0xFFF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.unUsed01 & 0xF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.trapAddr & 0xFFF)
        dma(self.address, 0xED98, reg)
    ## HS interrupt enable
    def hsIntEn(self, value = None):
        value = dma_bits(0xED98, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed02(self, value = None):
        value = dma_bits(0xED98, self.address, 3, 28, value)
        return(value)
    ## Address mask, 0=Ignore bit, 1=Match bit
    def trapAddrMask(self, value = None):
        value = dma_bits(0xED98, self.address, 12, 16, value)
        return(value)
    ## Not used
    def unUsed01(self, value = None):
        value = dma_bits(0xED98, self.address, 4, 12, value)
        return(value)
    ## Trap address
    def trapAddr(self, value = None):
        value = dma_bits(0xED98, self.address, 12, 0, value)
        return(value)

###################################################################
## [Deprecated] PMBus interrupt trap - IRQ9
###################################################################
class pmBusInt_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED99, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pmBusInt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED99, None)
            self.pmIntEn = (self.reg_value >> 31) & 0x1
            self.unUsed02 = (self.reg_value >> 28) & 0x7
            self.trapAddrMask = (self.reg_value >> 16) & 0xFFF
            self.unUsed01 = (self.reg_value >> 12) & 0xF
            self.trapAddr = self.reg_value & 0xFFF

    def read_object(self):
        return(self.pmBusInt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pmIntEn & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unUsed02 & 0x7) << 28)
        reg = (reg & 0xF000FFFF) + ((register_object.trapAddrMask & 0xFFF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.unUsed01 & 0xF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.trapAddr & 0xFFF)
        dma(self.address, 0xED99, reg)
    ## HS interrupt enable
    def pmIntEn(self, value = None):
        value = dma_bits(0xED99, self.address, 1, 31, value)
        return(value)
    ## Not used
    def unUsed02(self, value = None):
        value = dma_bits(0xED99, self.address, 3, 28, value)
        return(value)
    ## Address mask, 0=Ignore bit, 1=Match bit
    def trapAddrMask(self, value = None):
        value = dma_bits(0xED99, self.address, 12, 16, value)
        return(value)
    ## Not used
    def unUsed01(self, value = None):
        value = dma_bits(0xED99, self.address, 4, 12, value)
        return(value)
    ## Trap address
    def trapAddr(self, value = None):
        value = dma_bits(0xED99, self.address, 12, 0, value)
        return(value)

###################################################################
## High Speed Bus interrupt trap, mask bits only - IRQ8
###################################################################
class memoryIntMask_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xED9A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class memoryIntMask_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED9A, None)
            self.readWrtMask = (self.reg_value >> 16) & 0x1
            self.bankMask = (self.reg_value >> 14) & 0x3
            self.trapAddrMask = self.reg_value & 0x3FFF

    def read_object(self):
        return(self.memoryIntMask_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.readWrtMask & 0x1) << 16)
        reg = (reg & 0x13FFF) + ((register_object.bankMask & 0x3) << 14)
        reg = (reg & 0x1C000) + (register_object.trapAddrMask & 0x3FFF)
        dma(self.address, 0xED9A, reg)
    ## Read-write bit mask
    def readWrtMask(self, value = None):
        value = dma_bits(0xED9A, self.address, 1, 16, value)
        return(value)
    ## Memory bank: 00=RAM, 01=ROM, 10=Reg, 11=OTP
    def bankMask(self, value = None):
        value = dma_bits(0xED9A, self.address, 2, 14, value)
        return(value)
    ## Address mask, 0=Ignore bit, 1=Match bit
    def trapAddrMask(self, value = None):
        value = dma_bits(0xED9A, self.address, 14, 0, value)
        return(value)

###################################################################
## High Speed Bus interrupt trap - IRQ8
###################################################################
class memoryInt_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 17

    def __call__(self, value = None):
        value = dma(self.address, 0xED9B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class memoryInt_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED9B, None)
            self.readWrt = (self.reg_value >> 16) & 0x1
            self.bank = (self.reg_value >> 14) & 0x3
            self.trapAddr = self.reg_value & 0x3FFF

    def read_object(self):
        return(self.memoryInt_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.readWrt & 0x1) << 16)
        reg = (reg & 0x13FFF) + ((register_object.bank & 0x3) << 14)
        reg = (reg & 0x1C000) + (register_object.trapAddr & 0x3FFF)
        dma(self.address, 0xED9B, reg)
    ## Read-write bit
    def readWrt(self, value = None):
        value = dma_bits(0xED9B, self.address, 1, 16, value)
        return(value)
    ## Memory bank: 00=RAM, 01=ROM, 10=Reg, 11=OTP
    def bank(self, value = None):
        value = dma_bits(0xED9B, self.address, 2, 14, value)
        return(value)
    ## Trap address
    def trapAddr(self, value = None):
        value = dma_bits(0xED9B, self.address, 14, 0, value)
        return(value)

###################################################################
## PWM GPIO control
###################################################################
class pwmGPIOcfg_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED9C, value)
        return(value)


###################################################################
## PWM GPIO control
###################################################################
class pwmGPIOdir_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED9D, value)
        return(value)


###################################################################
## PWM GPIO control
###################################################################
class pwmGPIOdata_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED9E, value)
        return(value)


###################################################################
## PWM Status
###################################################################
class pwmStatusIn_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xED9F, value)
        return(value)


###################################################################
## PWM GPIO Mid Drive Control
###################################################################
class pwmGPIOmidDr_class(object):
    def __init__(self, address):
        self.interface = 'tstBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEDD8, value)
        return(value)


###################################################################
## SVI3 Output Current
###################################################################
class svi3Iout_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA0, value)
        return(value)


###################################################################
## SVI3 Output Voltage
###################################################################
class svi3Vout_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA1, value)
        return(value)


###################################################################
## SVI3 Temperature 1
###################################################################
class svi3Temp1_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA2, value)
        return(value)


###################################################################
## SVI3 Temperature 2
###################################################################
class svi3Temp2_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA3, value)
        return(value)


###################################################################
## SVI3 Input Current
###################################################################
class svi3Iin_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA4, value)
        return(value)


###################################################################
## SVI3 Input Voltage
###################################################################
class svi3Vin_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 10

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA5, value)
        return(value)


###################################################################
## SVI3 scaled OOC fault limit
###################################################################
class svi3OocLimit_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA6, value)
        return(value)


###################################################################
## SVI3 scaled OOC Warning fault limit
###################################################################
class svi3OocWarnLimit_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA7, value)
        return(value)


###################################################################
## SVI3 Fast Delay register
###################################################################
class svi3FastDelay_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA8, value)
        return(value)


###################################################################
## SVI3 Configuration
###################################################################
class svi3Cfg_class(object):
    def __init__(self, address):
        self.interface = 'svi3Tbus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEDA9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi3Cfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDA9, None)
            self.useSvi3WarnDet = (self.reg_value >> 6) & 0x1
            self.useSvi3OtWarn = (self.reg_value >> 5) & 0x1
            self.useSvi3OtLimit = (self.reg_value >> 4) & 0x1
            self.useSvi3OocWarnLimit = (self.reg_value >> 3) & 0x1
            self.useSvi3FastDelay = (self.reg_value >> 2) & 0x1
            self.useLowerLimit = (self.reg_value >> 1) & 0x1
            self.useSvi3OocLimit = self.reg_value & 0x1

    def read_object(self):
        return(self.svi3Cfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xBF) + ((register_object.useSvi3WarnDet & 0x1) << 6)
        reg = (reg & 0xDF) + ((register_object.useSvi3OtWarn & 0x1) << 5)
        reg = (reg & 0xEF) + ((register_object.useSvi3OtLimit & 0x1) << 4)
        reg = (reg & 0xF7) + ((register_object.useSvi3OocWarnLimit & 0x1) << 3)
        reg = (reg & 0xFB) + ((register_object.useSvi3FastDelay & 0x1) << 2)
        reg = (reg & 0xFD) + ((register_object.useLowerLimit & 0x1) << 1)
        reg = (reg & 0xFE) + (register_object.useSvi3OocLimit & 0x1)
        dma(self.address, 0xEDA9, reg)
    ## 1 - Use the fastSumOcWarnDet (undelayed), 0 - Use fastSumOcWarn
    def useSvi3WarnDet(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 6, value)
        return(value)
    ## 1 - Use the svi3OtWarn, 0 - Use PMBus OT_WARN_LIMIT
    def useSvi3OtWarn(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 5, value)
        return(value)
    ## 1 - Use the svi3OtLimit, 0 - Use PMBus OT_FAULT_LIMIT
    def useSvi3OtLimit(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 4, value)
        return(value)
    ## 1 - Use the svi3OocWarnLimit, 0 - Use PMBus OOC_WARN_LIMIT
    def useSvi3OocWarnLimit(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 3, value)
        return(value)
    ## 1 - Use svi3FastDelay, 0 - Use PMBus fast fault delay
    def useSvi3FastDelay(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 2, value)
        return(value)
    ## 1 - Use the lower of svi3OocLimit or OOC_FAULT_LIMIT
    def useLowerLimit(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 1, value)
        return(value)
    ## 1 - Use the svi3OocLimit, 0 - Use PMBus OOC_FAULT_LIMIT
    def useSvi3OocLimit(self, value = None):
        value = dma_bits(0xEDA9, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class otpCtrl_class(object):
    def __init__(self, address):
        self.interface = 'otpBus'
        self.address = address
        self.bits = 7

    def __call__(self, value = None):
        value = dma(self.address, 0xEDD0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otpCtrl_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDD0, None)
            self.standby = (self.reg_value >> 6) & 0x1
            self.ptr = (self.reg_value >> 5) & 0x1
            self.mode = (self.reg_value >> 1) & 0xF
            self.enable = self.reg_value & 0x1

    def read_object(self):
        return(self.otpCtrl_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3F) + ((register_object.standby & 0x1) << 6)
        reg = (reg & 0x5F) + ((register_object.ptr & 0x1) << 5)
        reg = (reg & 0x61) + ((register_object.mode & 0xF) << 1)
        reg = (reg & 0x7E) + (register_object.enable & 0x1)
        dma(self.address, 0xEDD0, reg)
    ## Post enable, The OTP will remain in standby mode when set.
    def standby(self, value = None):
        value = dma_bits(0xEDD0, self.address, 1, 6, value)
        return(value)
    ## Enable the use of the Test Row
    def ptr(self, value = None):
        value = dma_bits(0xEDD0, self.address, 1, 5, value)
        return(value)
    ## The mode the controller is operating in.MODE<br>0000: Normal<br>0001: Initial Stress Read<br>0010: Program<br>0100: Program Stress Read<br>1001: HT Initial Stress Read<br>1100: HT Program Stress Read
    def mode(self, value = None):
        value = dma_bits(0xEDD0, self.address, 4, 1, value)
        return(value)
    ## Enable the OTP controller
    def enable(self, value = None):
        value = dma_bits(0xEDD0, self.address, 1, 0, value)
        return(value)

###################################################################
## OTP remap control register
###################################################################
class otpRemap_class(object):
    def __init__(self, address):
        self.interface = 'otpBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEDD1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otpRemap_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDD1, None)
            self.en1 = (self.reg_value >> 31) & 0x1
            self.unused1 = (self.reg_value >> 28) & 0x7
            self.badAddr1 = (self.reg_value >> 16) & 0xFFF
            self.en0 = (self.reg_value >> 15) & 0x1
            self.unused0 = (self.reg_value >> 12) & 0x7
            self.badAddr0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.otpRemap_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.en1 & 0x1) << 31)
        reg = (reg & 0x8FFFFFFF) + ((register_object.unused1 & 0x7) << 28)
        reg = (reg & 0xF000FFFF) + ((register_object.badAddr1 & 0xFFF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.en0 & 0x1) << 15)
        reg = (reg & 0xFFFF8FFF) + ((register_object.unused0 & 0x7) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.badAddr0 & 0xFFF)
        dma(self.address, 0xEDD1, reg)
    def en1(self, value = None):
        value = dma_bits(0xEDD1, self.address, 1, 31, value)
        return(value)
    def unused1(self, value = None):
        value = dma_bits(0xEDD1, self.address, 3, 28, value)
        return(value)
    def badAddr1(self, value = None):
        value = dma_bits(0xEDD1, self.address, 12, 16, value)
        return(value)
    def en0(self, value = None):
        value = dma_bits(0xEDD1, self.address, 1, 15, value)
        return(value)
    def unused0(self, value = None):
        value = dma_bits(0xEDD1, self.address, 3, 12, value)
        return(value)
    def badAddr0(self, value = None):
        value = dma_bits(0xEDD1, self.address, 12, 0, value)
        return(value)

###################################################################
## OTP spare control register
###################################################################
class otpSpare_class(object):
    def __init__(self, address):
        self.interface = 'otpBus'
        self.address = address
        self.bits = 28

    def __call__(self, value = None):
        value = dma(self.address, 0xEDD2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otpSpare_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDD2, None)
            self.unused1 = (self.reg_value >> 26) & 0x3
            self.mapAddr1 = (self.reg_value >> 14) & 0xFFF
            self.unused0 = (self.reg_value >> 12) & 0x3
            self.mapAddr0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.otpSpare_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFFF) + ((register_object.unused1 & 0x3) << 26)
        reg = (reg & 0xC003FFF) + ((register_object.mapAddr1 & 0xFFF) << 14)
        reg = (reg & 0xFFFCFFF) + ((register_object.unused0 & 0x3) << 12)
        reg = (reg & 0xFFFF000) + (register_object.mapAddr0 & 0xFFF)
        dma(self.address, 0xEDD2, reg)
    def unused1(self, value = None):
        value = dma_bits(0xEDD2, self.address, 2, 26, value)
        return(value)
    def mapAddr1(self, value = None):
        value = dma_bits(0xEDD2, self.address, 12, 14, value)
        return(value)
    def unused0(self, value = None):
        value = dma_bits(0xEDD2, self.address, 2, 12, value)
        return(value)
    def mapAddr0(self, value = None):
        value = dma_bits(0xEDD2, self.address, 12, 0, value)
        return(value)

###################################################################
## OTP test control register
###################################################################
class otpTest_class(object):
    def __init__(self, address):
        self.interface = 'otpBus'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xEDD3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otpTest_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDD3, None)
            self.writeCountOverride = (self.reg_value >> 17) & 0x1
            self.writeCount = (self.reg_value >> 7) & 0x3FF
            self.readCountOverride = (self.reg_value >> 6) & 0x1
            self.readCount = (self.reg_value >> 3) & 0x7
            self.clkMode = self.reg_value & 0x7

    def read_object(self):
        return(self.otpTest_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFF) + ((register_object.writeCountOverride & 0x1) << 17)
        reg = (reg & 0x2007F) + ((register_object.writeCount & 0x3FF) << 7)
        reg = (reg & 0x3FFBF) + ((register_object.readCountOverride & 0x1) << 6)
        reg = (reg & 0x3FFC7) + ((register_object.readCount & 0x7) << 3)
        reg = (reg & 0x3FFF8) + (register_object.clkMode & 0x7)
        dma(self.address, 0xEDD3, reg)
    ## If 1, the write timer count is overriden with the count from the writeCount bits
    def writeCountOverride(self, value = None):
        value = dma_bits(0xEDD3, self.address, 1, 17, value)
        return(value)
    ## Write timer count override value.  These 3 bits correspond to the number of clocks the controller spends asserting the PWE signal. The typical value is 488 (0x1e8)
    def writeCount(self, value = None):
        value = dma_bits(0xEDD3, self.address, 10, 7, value)
        return(value)
    ## If 1, the read timer count is overriden with the count from the readCount bits
    def readCountOverride(self, value = None):
        value = dma_bits(0xEDD3, self.address, 1, 6, value)
        return(value)
    ## Read timer count override value.  These 3 bits correspond to the number of clocks the controller spends waiting for the data to arrive during a read. The typical value in nova is 3 (0b010)
    def readCount(self, value = None):
        value = dma_bits(0xEDD3, self.address, 3, 3, value)
        return(value)
    ## These 3 bits determine the PCLK mode, one hot<br>001 (normal,default) 1.5 clksys wide.<br>010 1.0 clkSys wide.<br>100 0.5 clkSys wide
    def clkMode(self, value = None):
        value = dma_bits(0xEDD3, self.address, 3, 0, value)
        return(value)

###################################################################
## 
###################################################################
class monPhStat_class(object):
    def __init__(self, address):
        self.interface = 'stPh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEDE0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class monPhStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDE0, None)
            self.monPhMax = (self.reg_value >> 16) & 0xFFFF
            self.monPhMin = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.monPhStat_Object(self.address))

    def monPhMax(self):
        value = dma_bits(0xEDE0, self.address, 16, 16, None)
        return(value)
    def monPhMin(self):
        value = dma_bits(0xEDE0, self.address, 16, 0, None)
        return(value)

###################################################################
## 
###################################################################
class monPh_class(object):
    def __init__(self, address):
        self.interface = 'stPh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEDE8, value)
        return(value)


###################################################################
## 
###################################################################
class monLoop_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEDF0, value)
        return(value)


###################################################################
## 
###################################################################
class monLpStat_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEDF3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class monLpStat_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDF3, None)
            self.monLpMax = (self.reg_value >> 16) & 0xFFFF
            self.monLpMin = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.monLpStat_Object(self.address))

    def monLpMax(self):
        value = dma_bits(0xEDF3, self.address, 16, 16, None)
        return(value)
    def monLpMin(self):
        value = dma_bits(0xEDF3, self.address, 16, 0, None)
        return(value)

###################################################################
## 
###################################################################
class loopStatA_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEDF6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopStatA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDF6, None)
            self.shtDwnFlt = (self.reg_value >> 31) & 0x1
            self.runLoop = (self.reg_value >> 30) & 0x1
            self.dem = (self.reg_value >> 29) & 0x1
            self.decay = (self.reg_value >> 28) & 0x1
            self.volt = (self.reg_value >> 16) & 0xFFF
            self.rate = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.loopStatA_Object(self.address))

    def shtDwnFlt(self):
        value = dma_bits(0xEDF6, self.address, 1, 31, None)
        return(value)
    def runLoop(self):
        value = dma_bits(0xEDF6, self.address, 1, 30, None)
        return(value)
    def dem(self):
        value = dma_bits(0xEDF6, self.address, 1, 29, None)
        return(value)
    def decay(self):
        value = dma_bits(0xEDF6, self.address, 1, 28, None)
        return(value)
    def volt(self):
        value = dma_bits(0xEDF6, self.address, 12, 16, None)
        return(value)
    def rate(self):
        value = dma_bits(0xEDF6, self.address, 16, 0, None)
        return(value)

###################################################################
## 
###################################################################
class loopStatB_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 20

    def __call__(self, value = None):
        value = dma(self.address, 0xEDF9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopStatB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDF9, None)
            self.typZcdTime = (self.reg_value >> 12) & 0xFF
            self.dcmOnly = (self.reg_value >> 11) & 0x1
            self.onePhOnly = (self.reg_value >> 10) & 0x1
            self.chTempGood = (self.reg_value >> 9) & 0x1
            self.phTempGood = (self.reg_value >> 8) & 0x1
            self.trackVid = self.reg_value & 0xFF

    def read_object(self):
        return(self.loopStatB_Object(self.address))

    ## typical zero-cross detector delay, in clkTs
    def typZcdTime(self):
        value = dma_bits(0xEDF9, self.address, 8, 12, None)
        return(value)
    def dcmOnly(self):
        value = dma_bits(0xEDF9, self.address, 1, 11, None)
        return(value)
    def onePhOnly(self):
        value = dma_bits(0xEDF9, self.address, 1, 10, None)
        return(value)
    def chTempGood(self):
        value = dma_bits(0xEDF9, self.address, 1, 9, None)
        return(value)
    def phTempGood(self):
        value = dma_bits(0xEDF9, self.address, 1, 8, None)
        return(value)
    def trackVid(self):
        value = dma_bits(0xEDF9, self.address, 8, 0, None)
        return(value)

###################################################################
## 
###################################################################
class loopStatC_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEDFC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopStatC_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEDFC, None)
            self.loopCurrent = (self.reg_value >> 20) & 0xFFF
            self.actPs = (self.reg_value >> 16) & 0xF
            self.needTelem = (self.reg_value >> 15) & 0x1
            self.secOn = (self.reg_value >> 14) & 0x1
            self.priOn = (self.reg_value >> 13) & 0x1
            self.vinUndrVolt = (self.reg_value >> 12) & 0x1
            self.sumVolt = self.reg_value & 0xFFF

    def read_object(self):
        return(self.loopStatC_Object(self.address))

    def loopCurrent(self):
        value = dma_bits(0xEDFC, self.address, 12, 20, None)
        return(value)
    def actPs(self):
        value = dma_bits(0xEDFC, self.address, 4, 16, None)
        return(value)
    def needTelem(self):
        value = dma_bits(0xEDFC, self.address, 1, 15, None)
        return(value)
    def secOn(self):
        value = dma_bits(0xEDFC, self.address, 1, 14, None)
        return(value)
    def priOn(self):
        value = dma_bits(0xEDFC, self.address, 1, 13, None)
        return(value)
    def vinUndrVolt(self):
        value = dma_bits(0xEDFC, self.address, 1, 12, None)
        return(value)
    def sumVolt(self):
        value = dma_bits(0xEDFC, self.address, 12, 0, None)
        return(value)

###################################################################
## 
###################################################################
class loopStatD_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 13

    def __call__(self, value = None):
        value = dma(self.address, 0xEE00, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class loopStatD_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE00, None)
            self.phRunCnt = (self.reg_value >> 8) & 0x1F
            self.phAvail = self.reg_value & 0xFF

    def read_object(self):
        return(self.loopStatD_Object(self.address))

    def phRunCnt(self):
        value = dma_bits(0xEE00, self.address, 5, 8, None)
        return(value)
    def phAvail(self):
        value = dma_bits(0xEE00, self.address, 8, 0, None)
        return(value)

###################################################################
## Loop manager status and signal source for flexible lmgrInt
###################################################################
class lmgrStatus_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE03, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class lmgrStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE03, None)
            self.anded = (self.reg_value >> 31) & 0x1
            self.loopSettled = (self.reg_value >> 29) & 0x1
            self.pwrGd = (self.reg_value >> 28) & 0x1
            self.phEnDisdeactive = (self.reg_value >> 27) & 0x1
            self.goCh = (self.reg_value >> 26) & 0x1
            self.runLoop = (self.reg_value >> 25) & 0x1
            self.bootMode = (self.reg_value >> 24) & 0x1
            self.chPwrOk = (self.reg_value >> 23) & 0x1
            self.sysPwrOk = (self.reg_value >> 22) & 0x1
            self.inputUnderVoltZ = (self.reg_value >> 21) & 0x1
            self.tOffDlyDone = (self.reg_value >> 20) & 0x1
            self.tOnDlyDone = (self.reg_value >> 19) & 0x1
            self.onOffCases = (self.reg_value >> 18) & 0x1
            self.availPhases = (self.reg_value >> 17) & 0x1
            self.shtDwnFltZ = (self.reg_value >> 16) & 0x1
            self.runClocksDel = (self.reg_value >> 15) & 0x1
            self.diagComplete = (self.reg_value >> 14) & 0x1
            self.ps03ExitZ = (self.reg_value >> 13) & 0x1
            self.ps04ExitZ = (self.reg_value >> 12) & 0x1
            self.psExitWaitZ = (self.reg_value >> 11) & 0x1
            self.reEnDelayZ = (self.reg_value >> 10) & 0x1
            self.vidShutDownZ = (self.reg_value >> 9) & 0x1
            self.secOn = (self.reg_value >> 8) & 0x1
            self.priOn = (self.reg_value >> 7) & 0x1
            self.onOffState = self.reg_value & 0x7F

    def read_object(self):
        return(self.lmgrStatus_Object(self.address))

    ## All of the lmgrIntAnd masked and anded bits are high
    def anded(self):
        value = dma_bits(0xEE03, self.address, 1, 31, None)
        return(value)
    ## Loop settled at target voltage
    def loopSettled(self):
        value = dma_bits(0xEE03, self.address, 1, 29, None)
        return(value)
    ## Power good output bit is on
    def pwrGd(self):
        value = dma_bits(0xEE03, self.address, 1, 28, None)
        return(value)
    ## Phase enable disable signal
    def phEnDisdeactive(self):
        value = dma_bits(0xEE03, self.address, 1, 27, None)
        return(value)
    ## goCh combination signal is high
    def goCh(self):
        value = dma_bits(0xEE03, self.address, 1, 26, None)
        return(value)
    ## loop is regulating
    def runLoop(self):
        value = dma_bits(0xEE03, self.address, 1, 25, None)
        return(value)
    ## In boot mode
    def bootMode(self):
        value = dma_bits(0xEE03, self.address, 1, 24, None)
        return(value)
    ## channel power is up
    def chPwrOk(self):
        value = dma_bits(0xEE03, self.address, 1, 23, None)
        return(value)
    ## MCU set system power OK
    def sysPwrOk(self):
        value = dma_bits(0xEE03, self.address, 1, 22, None)
        return(value)
    ## High if input volt and vddMon volt are high enough
    def inputUnderVoltZ(self):
        value = dma_bits(0xEE03, self.address, 1, 21, None)
        return(value)
    ## Turn off delay done
    def tOffDlyDone(self):
        value = dma_bits(0xEE03, self.address, 1, 20, None)
        return(value)
    ## Turn on delay done
    def tOnDlyDone(self):
        value = dma_bits(0xEE03, self.address, 1, 19, None)
        return(value)
    ## High if ONOFF configured EN and OPER conditions met for running
    def onOffCases(self):
        value = dma_bits(0xEE03, self.address, 1, 18, None)
        return(value)
    ## This rail has good phases available
    def availPhases(self):
        value = dma_bits(0xEE03, self.address, 1, 17, None)
        return(value)
    ## High if not shut down for fault
    def shtDwnFltZ(self):
        value = dma_bits(0xEE03, self.address, 1, 16, None)
        return(value)
    ## Clocks running on PLL
    def runClocksDel(self):
        value = dma_bits(0xEE03, self.address, 1, 15, None)
        return(value)
    ## MCU has set mculpc.diagDone
    def diagComplete(self):
        value = dma_bits(0xEE03, self.address, 1, 14, None)
        return(value)
    ## high if not in PS3 or not waiting for PS3 exit
    def ps03ExitZ(self):
        value = dma_bits(0xEE03, self.address, 1, 13, None)
        return(value)
    ## high if not in PS4 or not waiting for PS4 exit
    def ps04ExitZ(self):
        value = dma_bits(0xEE03, self.address, 1, 12, None)
        return(value)
    ## high if not waiting for power state exit
    def psExitWaitZ(self):
        value = dma_bits(0xEE03, self.address, 1, 11, None)
        return(value)
    ## high if not waiting for re-enable delay
    def reEnDelayZ(self):
        value = dma_bits(0xEE03, self.address, 1, 10, None)
        return(value)
    ## high if not at VID=0 shutdown
    def vidShutDownZ(self):
        value = dma_bits(0xEE03, self.address, 1, 9, None)
        return(value)
    ## Meets secondary turn on conditions
    def secOn(self):
        value = dma_bits(0xEE03, self.address, 1, 8, None)
        return(value)
    ## Meets primary turn on conditions (enable/oper command)
    def priOn(self):
        value = dma_bits(0xEE03, self.address, 1, 7, None)
        return(value)
    ## Bits: SETTLE, RAMPDN, ON, PRE, OFF, INIT, RESET
    def onOffState(self):
        value = dma_bits(0xEE03, self.address, 7, 0, None)
        return(value)

###################################################################
## AVS read-only dvid down rate for channel 0 here
###################################################################
class avsFallRate_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE08, value)
        return(value)


###################################################################
## AVS read-only dvid up rate (AVS) for channel 0 here
###################################################################
class avsRiseRate_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE0B, value)
        return(value)


###################################################################
## Channel power manager status
###################################################################
class chPwrStatus_class(object):
    def __init__(self, address):
        self.interface = 'stCh'
        self.address = address
        self.bits = 27

    def __call__(self, value = None):
        value = dma(self.address, 0xEE0E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class chPwrStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE0E, None)
            self.stateNum = (self.reg_value >> 23) & 0xF
            self.needChDM = (self.reg_value >> 20) & 0x7
            self.needPh1DM = (self.reg_value >> 17) & 0x7
            self.setButDM = (self.reg_value >> 16) & 0x1
            self.setAllDM = (self.reg_value >> 15) & 0x1
            self.needPwmTerm = (self.reg_value >> 14) & 0x1
            self.asleep = (self.reg_value >> 13) & 0x1
            self.needRecharge = (self.reg_value >> 12) & 0x1
            self.needVccUv = (self.reg_value >> 11) & 0x1
            self.needOov = (self.reg_value >> 10) & 0x1
            self.needVcomp = (self.reg_value >> 9) & 0x1
            self.needFastV = (self.reg_value >> 8) & 0x1
            self.needVadc = (self.reg_value >> 7) & 0x1
            self.needIadcIs3 = (self.reg_value >> 6) & 0x1
            self.needIadcIs2 = (self.reg_value >> 5) & 0x1
            self.needIadcIs1 = (self.reg_value >> 4) & 0x1
            self.needIadcIs0 = (self.reg_value >> 3) & 0x1
            self.needTelem = (self.reg_value >> 2) & 0x1
            self.needBg = (self.reg_value >> 1) & 0x1
            self.needOsc = self.reg_value & 0x1

    def read_object(self):
        return(self.chPwrStatus_Object(self.address))

    ## State machine state code (numeric)<br>0 = CUCFG - Not yet configured<br>1  = CNON - No Phases assigned<br>2  = CFLT - Fault Shutdown power-up<br>3  = CDIS - Channel disabled <br>4  = CPRI - Transitional startup state<br>5  = CACT - Multiphase active <br>6  = CONE - Single Phase only (CCM/DCM, no phase adds allowed)<br>7  = CDCM - DCM Only, VSEN comp mode active<br>8  = CDZC - DCM Only with ZCD signalling from Owl<br>9  = CZVF - Zero VID fast startup (Vsen/ISEN ADC/PWM on<br>10 = CZVM - Zero VID meduim startup (VSEN ADC on PWM off)<br>11 = CZVS - Zero VID slower startup (VSEN/PWM Off)<br>12 = CSTBY - Standby (PS4/PSI6/EN=0)<br>13-15 = Reserved
    def stateNum(self):
        value = dma_bits(0xEE0E, self.address, 4, 23, None)
        return(value)
    ## Requested group driver mode if setAll/But
    def needChDM(self):
        value = dma_bits(0xEE0E, self.address, 3, 20, None)
        return(value)
    ## Requested driver mode for base phase
    def needPh1DM(self):
        value = dma_bits(0xEE0E, self.address, 3, 17, None)
        return(value)
    ## Set all-but-base phases to ChDM
    def setButDM(self):
        value = dma_bits(0xEE0E, self.address, 1, 16, None)
        return(value)
    ## Set all phases to ChDM
    def setAllDM(self):
        value = dma_bits(0xEE0E, self.address, 1, 15, None)
        return(value)
    ## Channel's phases should be terminated
    def needPwmTerm(self):
        value = dma_bits(0xEE0E, self.address, 1, 14, None)
        return(value)
    ## Channel drivers are expected to be asleep (no PWM)
    def asleep(self):
        value = dma_bits(0xEE0E, self.address, 1, 13, None)
        return(value)
    ## Channel's phases need recharging when reactivated
    def needRecharge(self):
        value = dma_bits(0xEE0E, self.address, 1, 12, None)
        return(value)
    ## Set VSEN pin comparator into Vcc undervolt VSEN
    def needVccUv(self):
        value = dma_bits(0xEE0E, self.address, 1, 11, None)
        return(value)
    ## Set VSEN pin comparator into OOV detection
    def needOov(self):
        value = dma_bits(0xEE0E, self.address, 1, 10, None)
        return(value)
    ## Need Vsen ADC in comparator mode
    def needVcomp(self):
        value = dma_bits(0xEE0E, self.address, 1, 9, None)
        return(value)
    ## Need Vsen ADC fully operational
    def needFastV(self):
        value = dma_bits(0xEE0E, self.address, 1, 8, None)
        return(value)
    ## Power up Vsen ADC prepared for fast activation
    def needVadc(self):
        value = dma_bits(0xEE0E, self.address, 1, 7, None)
        return(value)
    ## Need current sense ADC1 on (any chan)
    def needIadcIs3(self):
        value = dma_bits(0xEE0E, self.address, 1, 6, None)
        return(value)
    ## Need current sense ADC1 on (any chan)
    def needIadcIs2(self):
        value = dma_bits(0xEE0E, self.address, 1, 5, None)
        return(value)
    ## Need current sense ADC1 on (any chan)
    def needIadcIs1(self):
        value = dma_bits(0xEE0E, self.address, 1, 4, None)
        return(value)
    ## Need current sense ADC0 on (any chan)
    def needIadcIs0(self):
        value = dma_bits(0xEE0E, self.address, 1, 3, None)
        return(value)
    ## Need Vin telemetry
    def needTelem(self):
        value = dma_bits(0xEE0E, self.address, 1, 2, None)
        return(value)
    ## Need bandgap powered up
    def needBg(self):
        value = dma_bits(0xEE0E, self.address, 1, 1, None)
        return(value)
    ## Need main oscillator running all the time
    def needOsc(self):
        value = dma_bits(0xEE0E, self.address, 1, 0, None)
        return(value)

###################################################################
## Isen Autozero register readbacks, by Isen ADC and phase
###################################################################
class iSenAzData_class(object):
    def __init__(self, address):
        self.interface = 'stIs'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE13, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class iSenAzData_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE13, None)
            self.filtPh1 = (self.reg_value >> 12) & 0xFFF
            self.filtPh0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.iSenAzData_Object(self.address))

    ## Autozero filter value for second phase in this ADC
    def filtPh1(self):
        value = dma_bits(0xEE13, self.address, 12, 12, None)
        return(value)
    ## Autozero filter value for first phase in this ADC
    def filtPh0(self):
        value = dma_bits(0xEE13, self.address, 12, 0, None)
        return(value)

###################################################################
## System status
###################################################################
class sysStatus_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE20, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class sysStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE20, None)
            self.chIsRunning2 = (self.reg_value >> 31) & 0x1
            self.chIsRunning1 = (self.reg_value >> 30) & 0x1
            self.chIsRunning0 = (self.reg_value >> 29) & 0x1
            self.clkDivOnPll = (self.reg_value >> 28) & 0x1
            self.clkDivPllDead = (self.reg_value >> 27) & 0x1
            self.extDataLoadOk = (self.reg_value >> 26) & 0x1
            self.intDataLoadOk = (self.reg_value >> 25) & 0x1
            self.actPsState2 = (self.reg_value >> 22) & 0x7
            self.actPsState1 = (self.reg_value >> 19) & 0x7
            self.actPsState0 = (self.reg_value >> 16) & 0x7
            self.bg2Good = (self.reg_value >> 15) & 0x1
            self.cfpOut = (self.reg_value >> 14) & 0x1
            self.shtDwnFlt2 = (self.reg_value >> 13) & 0x1
            self.shtDwnFlt1 = (self.reg_value >> 12) & 0x1
            self.shtDwnFlt0 = (self.reg_value >> 11) & 0x1
            self.runLoopTs2 = (self.reg_value >> 10) & 0x1
            self.runLoopTs1 = (self.reg_value >> 9) & 0x1
            self.runLoopTs0 = (self.reg_value >> 8) & 0x1
            self.pinOpnFlt = (self.reg_value >> 7) & 0x1
            self.anaReady = (self.reg_value >> 3) & 0x1
            self.pllLocked = (self.reg_value >> 1) & 0x1
            self.pllDead = self.reg_value & 0x1

    def read_object(self):
        return(self.sysStatus_Object(self.address))

    def chIsRunning2(self):
        value = dma_bits(0xEE20, self.address, 1, 31, None)
        return(value)
    def chIsRunning1(self):
        value = dma_bits(0xEE20, self.address, 1, 30, None)
        return(value)
    def chIsRunning0(self):
        value = dma_bits(0xEE20, self.address, 1, 29, None)
        return(value)
    def clkDivOnPll(self):
        value = dma_bits(0xEE20, self.address, 1, 28, None)
        return(value)
    def clkDivPllDead(self):
        value = dma_bits(0xEE20, self.address, 1, 27, None)
        return(value)
    def extDataLoadOk(self):
        value = dma_bits(0xEE20, self.address, 1, 26, None)
        return(value)
    def intDataLoadOk(self):
        value = dma_bits(0xEE20, self.address, 1, 25, None)
        return(value)
    def actPsState2(self):
        value = dma_bits(0xEE20, self.address, 3, 22, None)
        return(value)
    def actPsState1(self):
        value = dma_bits(0xEE20, self.address, 3, 19, None)
        return(value)
    def actPsState0(self):
        value = dma_bits(0xEE20, self.address, 3, 16, None)
        return(value)
    def bg2Good(self):
        value = dma_bits(0xEE20, self.address, 1, 15, None)
        return(value)
    def cfpOut(self):
        value = dma_bits(0xEE20, self.address, 1, 14, None)
        return(value)
    def shtDwnFlt2(self):
        value = dma_bits(0xEE20, self.address, 1, 13, None)
        return(value)
    def shtDwnFlt1(self):
        value = dma_bits(0xEE20, self.address, 1, 12, None)
        return(value)
    def shtDwnFlt0(self):
        value = dma_bits(0xEE20, self.address, 1, 11, None)
        return(value)
    def runLoopTs2(self):
        value = dma_bits(0xEE20, self.address, 1, 10, None)
        return(value)
    def runLoopTs1(self):
        value = dma_bits(0xEE20, self.address, 1, 9, None)
        return(value)
    def runLoopTs0(self):
        value = dma_bits(0xEE20, self.address, 1, 8, None)
        return(value)
    def pinOpnFlt(self):
        value = dma_bits(0xEE20, self.address, 1, 7, None)
        return(value)
    def anaReady(self):
        value = dma_bits(0xEE20, self.address, 1, 3, None)
        return(value)
    def pllLocked(self):
        value = dma_bits(0xEE20, self.address, 1, 1, None)
        return(value)
    def pllDead(self):
        value = dma_bits(0xEE20, self.address, 1, 0, None)
        return(value)

###################################################################
## Pin open status A
###################################################################
class pinOpnInA_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE21, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pinOpnInA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE21, None)
            self.pinOpnIsenP7P = (self.reg_value >> 15) & 0x1
            self.pinOpnIsenP7N = (self.reg_value >> 14) & 0x1
            self.pinOpnIsenP6P = (self.reg_value >> 13) & 0x1
            self.pinOpnIsenP6N = (self.reg_value >> 12) & 0x1
            self.pinOpnIsenP5P = (self.reg_value >> 11) & 0x1
            self.pinOpnIsenP5N = (self.reg_value >> 10) & 0x1
            self.pinOpnIsenP4P = (self.reg_value >> 9) & 0x1
            self.pinOpnIsenP4N = (self.reg_value >> 8) & 0x1
            self.pinOpnIsenP3P = (self.reg_value >> 7) & 0x1
            self.pinOpnIsenP3N = (self.reg_value >> 6) & 0x1
            self.pinOpnIsenP2P = (self.reg_value >> 5) & 0x1
            self.pinOpnIsenP2N = (self.reg_value >> 4) & 0x1
            self.pinOpnIsenP1P = (self.reg_value >> 3) & 0x1
            self.pinOpnIsenP1N = (self.reg_value >> 2) & 0x1
            self.pinOpnIsenP0P = (self.reg_value >> 1) & 0x1
            self.pinOpnIsenP0N = self.reg_value & 0x1

    def read_object(self):
        return(self.pinOpnInA_Object(self.address))

    ## [15]
    def pinOpnIsenP7P(self):
        value = dma_bits(0xEE21, self.address, 1, 15, None)
        return(value)
    ## [14]
    def pinOpnIsenP7N(self):
        value = dma_bits(0xEE21, self.address, 1, 14, None)
        return(value)
    ## [13]
    def pinOpnIsenP6P(self):
        value = dma_bits(0xEE21, self.address, 1, 13, None)
        return(value)
    ## [12]
    def pinOpnIsenP6N(self):
        value = dma_bits(0xEE21, self.address, 1, 12, None)
        return(value)
    ## [11]
    def pinOpnIsenP5P(self):
        value = dma_bits(0xEE21, self.address, 1, 11, None)
        return(value)
    ## [10]
    def pinOpnIsenP5N(self):
        value = dma_bits(0xEE21, self.address, 1, 10, None)
        return(value)
    ## [9]
    def pinOpnIsenP4P(self):
        value = dma_bits(0xEE21, self.address, 1, 9, None)
        return(value)
    ## [8]
    def pinOpnIsenP4N(self):
        value = dma_bits(0xEE21, self.address, 1, 8, None)
        return(value)
    ## [7]
    def pinOpnIsenP3P(self):
        value = dma_bits(0xEE21, self.address, 1, 7, None)
        return(value)
    ## [6]
    def pinOpnIsenP3N(self):
        value = dma_bits(0xEE21, self.address, 1, 6, None)
        return(value)
    ## [5]
    def pinOpnIsenP2P(self):
        value = dma_bits(0xEE21, self.address, 1, 5, None)
        return(value)
    ## [4]
    def pinOpnIsenP2N(self):
        value = dma_bits(0xEE21, self.address, 1, 4, None)
        return(value)
    ## [3]
    def pinOpnIsenP1P(self):
        value = dma_bits(0xEE21, self.address, 1, 3, None)
        return(value)
    ## [2]
    def pinOpnIsenP1N(self):
        value = dma_bits(0xEE21, self.address, 1, 2, None)
        return(value)
    ## [1] ISEN0P open
    def pinOpnIsenP0P(self):
        value = dma_bits(0xEE21, self.address, 1, 1, None)
        return(value)
    ## [0] ISEN0N open
    def pinOpnIsenP0N(self):
        value = dma_bits(0xEE21, self.address, 1, 0, None)
        return(value)

###################################################################
## Pin open status B
###################################################################
class pinOpnInB_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 6

    def __call__(self, value = None):
        value = dma(self.address, 0xEE22, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pinOpnInB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE22, None)
            self.pinOpnVsenL2V = (self.reg_value >> 5) & 0x1
            self.pinOpnVsenL2G = (self.reg_value >> 4) & 0x1
            self.pinOpnVsenL1V = (self.reg_value >> 3) & 0x1
            self.pinOpnVsenL1G = (self.reg_value >> 2) & 0x1
            self.pinOpnVsenL0V = (self.reg_value >> 1) & 0x1
            self.pinOpnVsenL0G = self.reg_value & 0x1

    def read_object(self):
        return(self.pinOpnInB_Object(self.address))

    ## [5] VSEN2 open
    def pinOpnVsenL2V(self):
        value = dma_bits(0xEE22, self.address, 1, 5, None)
        return(value)
    ## [4] RGND2 open
    def pinOpnVsenL2G(self):
        value = dma_bits(0xEE22, self.address, 1, 4, None)
        return(value)
    ## [3] VSEN1 open
    def pinOpnVsenL1V(self):
        value = dma_bits(0xEE22, self.address, 1, 3, None)
        return(value)
    ## [2] RGND1 open
    def pinOpnVsenL1G(self):
        value = dma_bits(0xEE22, self.address, 1, 2, None)
        return(value)
    ## [1] VSEN0 open
    def pinOpnVsenL0V(self):
        value = dma_bits(0xEE22, self.address, 1, 1, None)
        return(value)
    ## [0] RGND0 open
    def pinOpnVsenL0G(self):
        value = dma_bits(0xEE22, self.address, 1, 0, None)
        return(value)

###################################################################
## 
###################################################################
class pinRead_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 29

    def __call__(self, value = None):
        value = dma(self.address, 0xEE23, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pinRead_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE23, None)
            self.sdifClkSync = (self.reg_value >> 28) & 0x1
            self.sdifDataSync = (self.reg_value >> 27) & 0x1
            self.gpio7InSync = (self.reg_value >> 26) & 0x1
            self.gpio6InSync = (self.reg_value >> 25) & 0x1
            self.gpio5InSync = (self.reg_value >> 24) & 0x1
            self.gpio4InSync = (self.reg_value >> 23) & 0x1
            self.gpio3InSync = (self.reg_value >> 22) & 0x1
            self.gpio2InSync = (self.reg_value >> 21) & 0x1
            self.gpio1InSync = (self.reg_value >> 20) & 0x1
            self.gpio0InSync = (self.reg_value >> 19) & 0x1
            self.gpio1Sync = (self.reg_value >> 18) & 0x1
            self.svitiPadIn = (self.reg_value >> 17) & 0x1
            self.cfpSync = (self.reg_value >> 16) & 0x1
            self.addressPadIn = (self.reg_value >> 15) & 0x1
            self.configselPadIn = (self.reg_value >> 14) & 0x1
            self.npmalertSyncZ = (self.reg_value >> 13) & 0x1
            self.pmsdaPadIn = (self.reg_value >> 12) & 0x1
            self.pmsclPadIn = (self.reg_value >> 11) & 0x1
            self.pwrgd2Sync = (self.reg_value >> 10) & 0x1
            self.pwrgd1Sync = (self.reg_value >> 9) & 0x1
            self.pwrgd0Sync = (self.reg_value >> 8) & 0x1
            self.nvrhotSyncZ = (self.reg_value >> 7) & 0x1
            self.enable2Sync = (self.reg_value >> 6) & 0x1
            self.enable1Sync = (self.reg_value >> 5) & 0x1
            self.enable0Sync = (self.reg_value >> 4) & 0x1
            self.gpio0Sync = (self.reg_value >> 3) & 0x1
            self.svitoPadIn = (self.reg_value >> 2) & 0x1
            self.svicPadIn = (self.reg_value >> 1) & 0x1
            self.svidPadIn = self.reg_value & 0x1

    def read_object(self):
        return(self.pinRead_Object(self.address))

    def sdifClkSync(self):
        value = dma_bits(0xEE23, self.address, 1, 28, None)
        return(value)
    def sdifDataSync(self):
        value = dma_bits(0xEE23, self.address, 1, 27, None)
        return(value)
    def gpio7InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 26, None)
        return(value)
    def gpio6InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 25, None)
        return(value)
    def gpio5InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 24, None)
        return(value)
    def gpio4InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 23, None)
        return(value)
    def gpio3InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 22, None)
        return(value)
    def gpio2InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 21, None)
        return(value)
    def gpio1InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 20, None)
        return(value)
    def gpio0InSync(self):
        value = dma_bits(0xEE23, self.address, 1, 19, None)
        return(value)
    def gpio1Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 18, None)
        return(value)
    def svitiPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 17, None)
        return(value)
    def cfpSync(self):
        value = dma_bits(0xEE23, self.address, 1, 16, None)
        return(value)
    def addressPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 15, None)
        return(value)
    def configselPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 14, None)
        return(value)
    def npmalertSyncZ(self):
        value = dma_bits(0xEE23, self.address, 1, 13, None)
        return(value)
    def pmsdaPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 12, None)
        return(value)
    def pmsclPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 11, None)
        return(value)
    def pwrgd2Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 10, None)
        return(value)
    def pwrgd1Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 9, None)
        return(value)
    def pwrgd0Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 8, None)
        return(value)
    def nvrhotSyncZ(self):
        value = dma_bits(0xEE23, self.address, 1, 7, None)
        return(value)
    def enable2Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 6, None)
        return(value)
    def enable1Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 5, None)
        return(value)
    def enable0Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 4, None)
        return(value)
    def gpio0Sync(self):
        value = dma_bits(0xEE23, self.address, 1, 3, None)
        return(value)
    def svitoPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 2, None)
        return(value)
    def svicPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 1, None)
        return(value)
    def svidPadIn(self):
        value = dma_bits(0xEE23, self.address, 1, 0, None)
        return(value)

###################################################################
## 
###################################################################
class phStatus_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEE24, value)
        return(value)


###################################################################
## 
###################################################################
class pwrStatusB_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE25, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrStatusB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE25, None)
            self.enPwrTel = (self.reg_value >> 15) & 0x1
            self.enPwrIsen3 = (self.reg_value >> 14) & 0x1
            self.enPwrIsen2 = (self.reg_value >> 13) & 0x1
            self.enPwrIsen1 = (self.reg_value >> 12) & 0x1
            self.enPwrIsen0 = (self.reg_value >> 11) & 0x1
            self.enPwrVsen2 = (self.reg_value >> 10) & 0x1
            self.enPwrVsen1 = (self.reg_value >> 9) & 0x1
            self.enPwrVsen0 = (self.reg_value >> 8) & 0x1
            self.enClkPh = self.reg_value & 0xFF

    def read_object(self):
        return(self.pwrStatusB_Object(self.address))

    ## Tel Adc, Comp, and Dig on
    def enPwrTel(self):
        value = dma_bits(0xEE25, self.address, 1, 15, None)
        return(value)
    ## Isen1 Adc, Comp, and Dig on
    def enPwrIsen3(self):
        value = dma_bits(0xEE25, self.address, 1, 14, None)
        return(value)
    ## Isen1 Adc, Comp, and Dig on
    def enPwrIsen2(self):
        value = dma_bits(0xEE25, self.address, 1, 13, None)
        return(value)
    ## Isen1 Adc, Comp, and Dig on
    def enPwrIsen1(self):
        value = dma_bits(0xEE25, self.address, 1, 12, None)
        return(value)
    ## Isen0 Adc, Comp, and Dig on
    def enPwrIsen0(self):
        value = dma_bits(0xEE25, self.address, 1, 11, None)
        return(value)
    ## Vsen2 Adc, Comp, and Dig on
    def enPwrVsen2(self):
        value = dma_bits(0xEE25, self.address, 1, 10, None)
        return(value)
    ## Vsen1 Adc, Comp, and Dig on
    def enPwrVsen1(self):
        value = dma_bits(0xEE25, self.address, 1, 9, None)
        return(value)
    ## Vsen0 Adc, Comp, and Dig on
    def enPwrVsen0(self):
        value = dma_bits(0xEE25, self.address, 1, 8, None)
        return(value)
    ## Phase digital circuit clocks are enabled
    def enClkPh(self):
        value = dma_bits(0xEE25, self.address, 8, 0, None)
        return(value)

###################################################################
## 
###################################################################
class pwrStatus_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 30

    def __call__(self, value = None):
        value = dma(self.address, 0xEE26, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class pwrStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE26, None)
            self.sysPwrOk = (self.reg_value >> 29) & 0x1
            self.needTelem = (self.reg_value >> 28) & 0x1
            self.bootMode2 = (self.reg_value >> 27) & 0x1
            self.bootMode1 = (self.reg_value >> 26) & 0x1
            self.bootMode0 = (self.reg_value >> 25) & 0x1
            self.noOnCmd2 = (self.reg_value >> 24) & 0x1
            self.noOnCmd1 = (self.reg_value >> 23) & 0x1
            self.noOnCmd0 = (self.reg_value >> 22) & 0x1
            self.inputUnderVolt2 = (self.reg_value >> 21) & 0x1
            self.inputUnderVolt1 = (self.reg_value >> 20) & 0x1
            self.inputUnderVolt0 = (self.reg_value >> 19) & 0x1
            self.enClkCh2 = (self.reg_value >> 18) & 0x1
            self.enClkCh1 = (self.reg_value >> 17) & 0x1
            self.enClkCh0 = (self.reg_value >> 16) & 0x1
            self.shtDwnFlt2 = (self.reg_value >> 15) & 0x1
            self.shtDwnFlt1 = (self.reg_value >> 14) & 0x1
            self.shtDwnFlt0 = (self.reg_value >> 13) & 0x1
            self.ps4ShtDwn2 = (self.reg_value >> 12) & 0x1
            self.ps4ShtDwn1 = (self.reg_value >> 11) & 0x1
            self.ps4ShtDwn0 = (self.reg_value >> 10) & 0x1
            self.chCmdOn2 = (self.reg_value >> 9) & 0x1
            self.chCmdOn1 = (self.reg_value >> 8) & 0x1
            self.chCmdOn0 = (self.reg_value >> 7) & 0x1
            self.chPwrOk2 = (self.reg_value >> 6) & 0x1
            self.chPwrOk1 = (self.reg_value >> 5) & 0x1
            self.chPwrOk0 = (self.reg_value >> 4) & 0x1
            self.chPwrOff2 = (self.reg_value >> 3) & 0x1
            self.chPwrOff1 = (self.reg_value >> 2) & 0x1
            self.chPwrOff0 = (self.reg_value >> 1) & 0x1
            self.onSysReq = self.reg_value & 0x1

    def read_object(self):
        return(self.pwrStatus_Object(self.address))

    def sysPwrOk(self):
        value = dma_bits(0xEE26, self.address, 1, 29, None)
        return(value)
    def needTelem(self):
        value = dma_bits(0xEE26, self.address, 1, 28, None)
        return(value)
    def bootMode2(self):
        value = dma_bits(0xEE26, self.address, 1, 27, None)
        return(value)
    def bootMode1(self):
        value = dma_bits(0xEE26, self.address, 1, 26, None)
        return(value)
    def bootMode0(self):
        value = dma_bits(0xEE26, self.address, 1, 25, None)
        return(value)
    def noOnCmd2(self):
        value = dma_bits(0xEE26, self.address, 1, 24, None)
        return(value)
    def noOnCmd1(self):
        value = dma_bits(0xEE26, self.address, 1, 23, None)
        return(value)
    def noOnCmd0(self):
        value = dma_bits(0xEE26, self.address, 1, 22, None)
        return(value)
    def inputUnderVolt2(self):
        value = dma_bits(0xEE26, self.address, 1, 21, None)
        return(value)
    def inputUnderVolt1(self):
        value = dma_bits(0xEE26, self.address, 1, 20, None)
        return(value)
    ## Channel supply voltage too low
    def inputUnderVolt0(self):
        value = dma_bits(0xEE26, self.address, 1, 19, None)
        return(value)
    def enClkCh2(self):
        value = dma_bits(0xEE26, self.address, 1, 18, None)
        return(value)
    def enClkCh1(self):
        value = dma_bits(0xEE26, self.address, 1, 17, None)
        return(value)
    ## Channel (loopPilot) clocks are enabled
    def enClkCh0(self):
        value = dma_bits(0xEE26, self.address, 1, 16, None)
        return(value)
    def shtDwnFlt2(self):
        value = dma_bits(0xEE26, self.address, 1, 15, None)
        return(value)
    def shtDwnFlt1(self):
        value = dma_bits(0xEE26, self.address, 1, 14, None)
        return(value)
    ## Channel is shutdown for fault
    def shtDwnFlt0(self):
        value = dma_bits(0xEE26, self.address, 1, 13, None)
        return(value)
    def ps4ShtDwn2(self):
        value = dma_bits(0xEE26, self.address, 1, 12, None)
        return(value)
    def ps4ShtDwn1(self):
        value = dma_bits(0xEE26, self.address, 1, 11, None)
        return(value)
    ## Channel is in PS4 (ultralow power) shutdown but still commanded on
    def ps4ShtDwn0(self):
        value = dma_bits(0xEE26, self.address, 1, 10, None)
        return(value)
    def chCmdOn2(self):
        value = dma_bits(0xEE26, self.address, 1, 9, None)
        return(value)
    def chCmdOn1(self):
        value = dma_bits(0xEE26, self.address, 1, 8, None)
        return(value)
    ## Channel has received a valid command to run
    def chCmdOn0(self):
        value = dma_bits(0xEE26, self.address, 1, 7, None)
        return(value)
    def chPwrOk2(self):
        value = dma_bits(0xEE26, self.address, 1, 6, None)
        return(value)
    def chPwrOk1(self):
        value = dma_bits(0xEE26, self.address, 1, 5, None)
        return(value)
    ## Channel power is completely on
    def chPwrOk0(self):
        value = dma_bits(0xEE26, self.address, 1, 4, None)
        return(value)
    def chPwrOff2(self):
        value = dma_bits(0xEE26, self.address, 1, 3, None)
        return(value)
    def chPwrOff1(self):
        value = dma_bits(0xEE26, self.address, 1, 2, None)
        return(value)
    ## Channel power is completely off
    def chPwrOff0(self):
        value = dma_bits(0xEE26, self.address, 1, 1, None)
        return(value)
    ## Hardware request for system power to be on=1 or off=0 whn sysPwrInt sent
    def onSysReq(self):
        value = dma_bits(0xEE26, self.address, 1, 0, None)
        return(value)

###################################################################
## Phase power manager status -- driver mode
###################################################################
class phPwrNeedDM_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE27, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPwrNeedDM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE27, None)
            self.needPhDM7 = (self.reg_value >> 21) & 0x7
            self.needPhDM6 = (self.reg_value >> 18) & 0x7
            self.needPhDM5 = (self.reg_value >> 15) & 0x7
            self.needPhDM4 = (self.reg_value >> 12) & 0x7
            self.needPhDM3 = (self.reg_value >> 9) & 0x7
            self.needPhDM2 = (self.reg_value >> 6) & 0x7
            self.needPhDM1 = (self.reg_value >> 3) & 0x7
            self.needPhDM0 = self.reg_value & 0x7

    def read_object(self):
        return(self.phPwrNeedDM_Object(self.address))

    ## Driver mode requested for phase 7
    def needPhDM7(self):
        value = dma_bits(0xEE27, self.address, 3, 21, None)
        return(value)
    ## Driver mode requested for phase 6
    def needPhDM6(self):
        value = dma_bits(0xEE27, self.address, 3, 18, None)
        return(value)
    ## Driver mode requested for phase 5
    def needPhDM5(self):
        value = dma_bits(0xEE27, self.address, 3, 15, None)
        return(value)
    ## Driver mode requested for phase 4
    def needPhDM4(self):
        value = dma_bits(0xEE27, self.address, 3, 12, None)
        return(value)
    ## Driver mode requested for phase 3
    def needPhDM3(self):
        value = dma_bits(0xEE27, self.address, 3, 9, None)
        return(value)
    ## Driver mode requested for phase 2
    def needPhDM2(self):
        value = dma_bits(0xEE27, self.address, 3, 6, None)
        return(value)
    ## Driver mode requested for phase 1
    def needPhDM1(self):
        value = dma_bits(0xEE27, self.address, 3, 3, None)
        return(value)
    ## Driver mode requested for phase 0
    def needPhDM0(self):
        value = dma_bits(0xEE27, self.address, 3, 0, None)
        return(value)

###################################################################
## Phase power manager status -- Wakeup and termination
###################################################################
class phPwrStatus_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE28, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class phPwrStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE28, None)
            self.ccmLoHiSent = (self.reg_value >> 16) & 0xFF
            self.sendWakeZHi = (self.reg_value >> 8) & 0xFF
            self.needPwmTerm = self.reg_value & 0xFF

    def read_object(self):
        return(self.phPwrStatus_Object(self.address))

    ## Phase PWM pulsed Lo to Hi normally, wake up driver
    def ccmLoHiSent(self):
        value = dma_bits(0xEE28, self.address, 8, 16, None)
        return(value)
    ## Request Z-Hi wake up pulse for phase
    def sendWakeZHi(self):
        value = dma_bits(0xEE28, self.address, 8, 8, None)
        return(value)
    ## Activate phase PWM termination resistor divider
    def needPwmTerm(self):
        value = dma_bits(0xEE28, self.address, 8, 0, None)
        return(value)

###################################################################
## SPS manager -- active driver mode
###################################################################
class spsActDM_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE29, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class spsActDM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE29, None)
            self.actDM7 = (self.reg_value >> 21) & 0x7
            self.actDM6 = (self.reg_value >> 18) & 0x7
            self.actDM5 = (self.reg_value >> 15) & 0x7
            self.actDM4 = (self.reg_value >> 12) & 0x7
            self.actDM3 = (self.reg_value >> 9) & 0x7
            self.actDM2 = (self.reg_value >> 6) & 0x7
            self.actDM1 = (self.reg_value >> 3) & 0x7
            self.actDM0 = self.reg_value & 0x7

    def read_object(self):
        return(self.spsActDM_Object(self.address))

    ## Active driver mode of phase 7
    def actDM7(self):
        value = dma_bits(0xEE29, self.address, 3, 21, None)
        return(value)
    ## Active driver mode of phase 6
    def actDM6(self):
        value = dma_bits(0xEE29, self.address, 3, 18, None)
        return(value)
    ## Active driver mode of phase 5
    def actDM5(self):
        value = dma_bits(0xEE29, self.address, 3, 15, None)
        return(value)
    ## Active driver mode of phase 4
    def actDM4(self):
        value = dma_bits(0xEE29, self.address, 3, 12, None)
        return(value)
    ## Active driver mode of phase 3
    def actDM3(self):
        value = dma_bits(0xEE29, self.address, 3, 9, None)
        return(value)
    ## Active driver mode of phase 2
    def actDM2(self):
        value = dma_bits(0xEE29, self.address, 3, 6, None)
        return(value)
    ## Active driver mode of phase 1
    def actDM1(self):
        value = dma_bits(0xEE29, self.address, 3, 3, None)
        return(value)
    ## Active driver mode of phase 0
    def actDM0(self):
        value = dma_bits(0xEE29, self.address, 3, 0, None)
        return(value)

###################################################################
## Loop 0 uptime
###################################################################
class upTime0_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2A, value)
        return(value)


###################################################################
## Loop 1 uptime
###################################################################
class upTime1_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2B, value)
        return(value)


###################################################################
## Loop 1 uptime
###################################################################
class upTime2_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2C, value)
        return(value)


###################################################################
## Hardware Revision Id
###################################################################
class revId_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2D, value)
        return(value)


###################################################################
## PWM outputs from loop
###################################################################
class pwmStatusEn_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2E, value)
        return(value)


###################################################################
## PWM outputs from loop
###################################################################
class pwmStatus_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEE2F, value)
        return(value)


###################################################################
## 
###################################################################
class ringCnt_class(object):
    def __init__(self, address):
        self.interface = 'stRing'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE30, value)
        return(value)


###################################################################
## 
###################################################################
class clkEnable1_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 18

    def __call__(self, value = None):
        value = dma(self.address, 0xEE31, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class clkEnable1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE31, None)
            self.clkTsCh = (self.reg_value >> 15) & 0x7
            self.clkTsSngl = (self.reg_value >> 12) & 0x7
            self.clkTsDcm = (self.reg_value >> 9) & 0x7
            self.clkTsProcCh = (self.reg_value >> 6) & 0x7
            self.clkTsIs = (self.reg_value >> 2) & 0xF
            self.clkTsProc = (self.reg_value >> 1) & 0x1
            self.clkTsProcPhs = self.reg_value & 0x1

    def read_object(self):
        return(self.clkEnable1_Object(self.address))

    def clkTsCh(self):
        value = dma_bits(0xEE31, self.address, 3, 15, None)
        return(value)
    def clkTsSngl(self):
        value = dma_bits(0xEE31, self.address, 3, 12, None)
        return(value)
    def clkTsDcm(self):
        value = dma_bits(0xEE31, self.address, 3, 9, None)
        return(value)
    def clkTsProcCh(self):
        value = dma_bits(0xEE31, self.address, 3, 6, None)
        return(value)
    def clkTsIs(self):
        value = dma_bits(0xEE31, self.address, 4, 2, None)
        return(value)
    def clkTsProc(self):
        value = dma_bits(0xEE31, self.address, 1, 1, None)
        return(value)
    def clkTsProcPhs(self):
        value = dma_bits(0xEE31, self.address, 1, 0, None)
        return(value)

###################################################################
## 
###################################################################
class clkEnable2_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE32, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class clkEnable2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE32, None)
            self.clkTsPh = (self.reg_value >> 24) & 0xFF
            self.clkTsPhSyn = (self.reg_value >> 16) & 0xFF
            self.clkTsDcmPh = (self.reg_value >> 8) & 0xFF
            self.clkTsChPh = self.reg_value & 0xFF

    def read_object(self):
        return(self.clkEnable2_Object(self.address))

    def clkTsPh(self):
        value = dma_bits(0xEE32, self.address, 8, 24, None)
        return(value)
    def clkTsPhSyn(self):
        value = dma_bits(0xEE32, self.address, 8, 16, None)
        return(value)
    def clkTsDcmPh(self):
        value = dma_bits(0xEE32, self.address, 8, 8, None)
        return(value)
    def clkTsChPh(self):
        value = dma_bits(0xEE32, self.address, 8, 0, None)
        return(value)

###################################################################
## 
###################################################################
class svi3Status_class(object):
    def __init__(self, address):
        self.interface = 'stBus'
        self.address = address
        self.bits = 24

    def __call__(self, value = None):
        value = dma(self.address, 0xEE33, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class svi3Status_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE33, None)
            self.timeout2 = (self.reg_value >> 23) & 0x1
            self.svi3Addr2 = (self.reg_value >> 16) & 0x7F
            self.timeout1 = (self.reg_value >> 15) & 0x1
            self.svi3Addr1 = (self.reg_value >> 8) & 0x7F
            self.timeout0 = (self.reg_value >> 7) & 0x1
            self.svi3Addr0 = self.reg_value & 0x7F

    def read_object(self):
        return(self.svi3Status_Object(self.address))

    def timeout2(self):
        value = dma_bits(0xEE33, self.address, 1, 23, None)
        return(value)
    def svi3Addr2(self):
        value = dma_bits(0xEE33, self.address, 7, 16, None)
        return(value)
    def timeout1(self):
        value = dma_bits(0xEE33, self.address, 1, 15, None)
        return(value)
    def svi3Addr1(self):
        value = dma_bits(0xEE33, self.address, 7, 8, None)
        return(value)
    def timeout0(self):
        value = dma_bits(0xEE33, self.address, 1, 7, None)
        return(value)
    def svi3Addr0(self):
        value = dma_bits(0xEE33, self.address, 7, 0, None)
        return(value)

###################################################################
## 
###################################################################
class otpStatus_class(object):
    def __init__(self, address):
        self.interface = 'stOtp'
        self.address = address
        self.bits = 19

    def __call__(self, value = None):
        value = dma(self.address, 0xEE34, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class otpStatus_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE34, None)
            self.nxtAddr = (self.reg_value >> 7) & 0xFFF
            self.writing = (self.reg_value >> 6) & 0x1
            self.sleep = (self.reg_value >> 5) & 0x1
            self.idle = (self.reg_value >> 4) & 0x1
            self.curMode = self.reg_value & 0xF

    def read_object(self):
        return(self.otpStatus_Object(self.address))

    ## The next write address, or read address, depending on mode.<br>In read mode, if the FIFO is full, this would be the next address to cause a cache miss.<br>In write mode, this is the next write address, regardless of FIFO full or empty
    def nxtAddr(self):
        value = dma_bits(0xEE34, self.address, 12, 7, None)
        return(value)
    ## Indicates the write process has begun, The write address is incorrect until this is true
    def writing(self):
        value = dma_bits(0xEE34, self.address, 1, 6, None)
        return(value)
    ## The controller is in sleep.
    def sleep(self):
        value = dma_bits(0xEE34, self.address, 1, 5, None)
        return(value)
    ## The controller is in idle.
    def idle(self):
        value = dma_bits(0xEE34, self.address, 1, 4, None)
        return(value)
    ## Current Mode value of the controller. These values are the same as those defined in the otpCtrl.mode register
    def curMode(self):
        value = dma_bits(0xEE34, self.address, 4, 0, None)
        return(value)

###################################################################
## Filtered channel Vout reading (high-speed ADC)
###################################################################
class avgVadc0_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE40, value)
        return(value)


###################################################################
## Filtered channel Vout reading (high-speed ADC)
###################################################################
class avgVadc1_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE41, value)
        return(value)


###################################################################
## Filtered channel Vout reading (high-speed ADC)
###################################################################
class avgVadc2_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE42, value)
        return(value)


###################################################################
## Filtered channel output current estimate
###################################################################
class avgIout0_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE43, value)
        return(value)


###################################################################
## Filtered channel output current estimate
###################################################################
class avgIout1_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE44, value)
        return(value)


###################################################################
## Filtered channel output current estimate
###################################################################
class avgIout2_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE45, value)
        return(value)


###################################################################
## Filtered channel output power
###################################################################
class avgPout0_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE46, value)
        return(value)


###################################################################
## Filtered channel output power
###################################################################
class avgPout1_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE47, value)
        return(value)


###################################################################
## Filtered channel output power
###################################################################
class avgPout2_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE48, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph0_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE49, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph1_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4A, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph2_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4B, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph3_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4C, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph4_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4D, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph5_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4E, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph6_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE4F, value)
        return(value)


###################################################################
## Filtered phase current
###################################################################
class avgIph7_class(object):
    def __init__(self, address):
        self.interface = 'lpAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE50, value)
        return(value)


###################################################################
## Unfiltered Vin 0 pin reading
###################################################################
class rawVinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE60, value)
        return(value)


###################################################################
## Unfiltered Iin 0 pin reading
###################################################################
class rawIinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE61, value)
        return(value)


###################################################################
## Unfiltered internal temperature reading
###################################################################
class rawIntTempTel_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE62, value)
        return(value)


###################################################################
## Unfiltered external temperature reading
###################################################################
class rawExtTempTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE63, value)
        return(value)


###################################################################
## Unfiltered external temperature reading
###################################################################
class rawExtTempTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE64, value)
        return(value)


###################################################################
## Unfiltered external temperature reading
###################################################################
class rawExtTempTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE65, value)
        return(value)


###################################################################
## Unfiltered VCC reading
###################################################################
class rawVccTel_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE66, value)
        return(value)


###################################################################
## Unfiltered CONFIG reading
###################################################################
class rawConfigTel_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE67, value)
        return(value)


###################################################################
## Unfiltered VDD1P8 reading
###################################################################
class rawVdd1p8Tel_class(object):
    def __init__(self, address):
        self.interface = 'utcRaw'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE68, value)
        return(value)


###################################################################
## Filtered Vin 0 pin reading
###################################################################
class avgVinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE90, value)
        return(value)


###################################################################
## Filtered Iin 0 pin reading
###################################################################
class avgIinTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE91, value)
        return(value)


###################################################################
## Filtered output voltage reading
###################################################################
class avgVoutTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE92, value)
        return(value)


###################################################################
## Filtered output voltage reading
###################################################################
class avgVoutTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE93, value)
        return(value)


###################################################################
## Filtered output voltage reading
###################################################################
class avgVoutTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE94, value)
        return(value)


###################################################################
## Filtered internal temperature reading
###################################################################
class avgIntTempTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE95, value)
        return(value)


###################################################################
## Filtered external temperature reading
###################################################################
class avgExtTempTel0_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE96, value)
        return(value)


###################################################################
## Filtered external temperature reading
###################################################################
class avgExtTempTel1_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE97, value)
        return(value)


###################################################################
## Filtered external temperature reading
###################################################################
class avgExtTempTel2_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE98, value)
        return(value)


###################################################################
## Filtered ATB reading
###################################################################
class avgAtbTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE99, value)
        return(value)


###################################################################
## Filtered VCC reading
###################################################################
class avgVccTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9A, value)
        return(value)


###################################################################
## Filtered VCCS reading
###################################################################
class avgVccsTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9B, value)
        return(value)


###################################################################
## Filtered VDDIO reading
###################################################################
class avgVddioTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9C, value)
        return(value)


###################################################################
## Filtered ADDRESS reading
###################################################################
class avgAddressTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9D, value)
        return(value)


###################################################################
## Filtered CONFIG reading
###################################################################
class avgConfigTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9E, value)
        return(value)


###################################################################
## Filtered VDD1P8 reading
###################################################################
class avgVdd1p8Tel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEE9F, value)
        return(value)


###################################################################
## Filtered ADC Auto Zero
###################################################################
class avgAutoZeroTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA0, value)
        return(value)


###################################################################
## Filtered ADDRESS Auto Zero
###################################################################
class avgAddrZeroTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA1, value)
        return(value)


###################################################################
## Filtered CONFIGSEL Auto Zero
###################################################################
class avgConfigZeroTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA2, value)
        return(value)


###################################################################
## Filtered Psys V*I
###################################################################
class avgPinViTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA3, value)
        return(value)


###################################################################
## Filtered Vsys normalized telemetry signal
###################################################################
class avgVsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA4, value)
        return(value)


###################################################################
## Filtered Isys normalized telemetry signal
###################################################################
class avgIsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA5, value)
        return(value)


###################################################################
## Filtered Psys normalized telemetry signal
###################################################################
class avgPsysTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA6, value)
        return(value)


###################################################################
## Filtered loop Vin normalized telemetry signal
###################################################################
class avgHsVinTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA7, value)
        return(value)


###################################################################
## Filtered AUX rail external Imon normalized telemetry signal
###################################################################
class avgHsAuxImonTel_class(object):
    def __init__(self, address):
        self.interface = 'utcAvg'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEEA8, value)
        return(value)


###################################################################
## SVI3 NVM Slew rates
###################################################################
class nvmSvi3Reg20_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB0, value)
        return(value)


###################################################################
## SVI3 NVM Load Line Adjust
###################################################################
class nvmSvi3Reg21_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB1, value)
        return(value)


###################################################################
## SVI3 NVM Output Voltage Offset
###################################################################
class nvmSvi3Reg22_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB2, value)
        return(value)


###################################################################
## SVI3 NVM VID Max
###################################################################
class nvmSvi3Reg23_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB3, value)
        return(value)


###################################################################
## SVI3 NVM VID Min
###################################################################
class nvmSvi3Reg24_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB4, value)
        return(value)


###################################################################
## SVI3 NVM TEN_BIT_TEL_EN
###################################################################
class nvmSvi3Reg25_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB5, value)
        return(value)


###################################################################
## SVI3 NVM VRHOT Threshold
###################################################################
class nvmSvi3Reg2A_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB6, value)
        return(value)


###################################################################
## SVI3 NVM OTP Threshold
###################################################################
class nvmSvi3Reg2B_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB7, value)
        return(value)


###################################################################
## SVI3 NVM OVP and UVP Controls
###################################################################
class nvmSvi3Reg2C_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB8, value)
        return(value)


###################################################################
## SVI3 NVM Phase Shed Controls
###################################################################
class nvmSvi3Reg2D_class(object):
    def __init__(self, address):
        self.interface = 'svi3NvmBus'
        self.address = address
        self.bits = 8

    def __call__(self, value = None):
        value = dma(self.address, 0xEEB9, value)
        return(value)


###################################################################
## Snapshot register 0
###################################################################
class snap0_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF80, value)
        return(value)


###################################################################
## Snapshot register 1
###################################################################
class snap1_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF81, value)
        return(value)


###################################################################
## Snapshot register 2
###################################################################
class snap2_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF82, value)
        return(value)


###################################################################
## Snapshot register 3
###################################################################
class snap3_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF83, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF83, None)
            self.firstFltCtrlB = (self.reg_value >> 24) & 0xFF
            self.firstFltCtrlA = self.reg_value & 0xFFFFFF

    def read_object(self):
        return(self.snap3_Object(self.address))

    ## FirstFltCtrlB
    def firstFltCtrlB(self):
        value = dma_bits(0xEF83, self.address, 8, 24, None)
        return(value)
    ## FirstFltCtrlA
    def firstFltCtrlA(self):
        value = dma_bits(0xEF83, self.address, 24, 0, None)
        return(value)

###################################################################
## Snapshot register 4
###################################################################
class snap4_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF84, value)
        return(value)


###################################################################
## Snapshot register 5
###################################################################
class snap5_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF85, value)
        return(value)


###################################################################
## Snapshot register 6
###################################################################
class snap6_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF86, value)
        return(value)


###################################################################
## Snapshot register 7
###################################################################
class snap7_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF87, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap7_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF87, None)
            self.firstPhAdcOcFlt = (self.reg_value >> 24) & 0xFF
            self.firstPhAdcUcFlt = (self.reg_value >> 16) & 0xFF
            self.firstPhPeakOcFlt = (self.reg_value >> 8) & 0xFF
            self.firstPhPeakUcFlt = self.reg_value & 0xFF

    def read_object(self):
        return(self.snap7_Object(self.address))

    ## firstPhAdcOcFlt
    def firstPhAdcOcFlt(self):
        value = dma_bits(0xEF87, self.address, 8, 24, None)
        return(value)
    ## firstPhAdcUcFlt
    def firstPhAdcUcFlt(self):
        value = dma_bits(0xEF87, self.address, 8, 16, None)
        return(value)
    ## firstPhPeakOcFlt
    def firstPhPeakOcFlt(self):
        value = dma_bits(0xEF87, self.address, 8, 8, None)
        return(value)
    ## firstPhPeakUcFlt
    def firstPhPeakUcFlt(self):
        value = dma_bits(0xEF87, self.address, 8, 0, None)
        return(value)

###################################################################
## Snapshot register 8
###################################################################
class snap8_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 16

    def __call__(self, value = None):
        value = dma(self.address, 0xEF88, value)
        return(value)

    ## firstPhiEstFlt
    def firstPhiEstFlt(self):
        value = dma_bits(0xEF88, self.address, 8, 0, None)
        return(value)

###################################################################
## Snapshot register 9
###################################################################
class snap9_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF89, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap9_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF89, None)
            self.statusWord1 = (self.reg_value >> 16) & 0xFFFF
            self.statusWord0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap9_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.statusWord1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.statusWord0 & 0xFFFF)
        dma(self.address, 0xEF89, reg)
    ## StatusWord1
    def statusWord1(self, value = None):
        value = dma_bits(0xEF89, self.address, 16, 16, value)
        return(value)
    ## StatusWord0
    def statusWord0(self, value = None):
        value = dma_bits(0xEF89, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register A
###################################################################
class snapA_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8A, None)
            self.statusWord2 = (self.reg_value >> 16) & 0xFFFF
            self.statusCml = (self.reg_value >> 8) & 0xFF
            self.statusMfr = self.reg_value & 0xFF

    def read_object(self):
        return(self.snapA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.statusWord2 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.statusCml & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.statusMfr & 0xFF)
        dma(self.address, 0xEF8A, reg)
    ## StatusWord2
    def statusWord2(self, value = None):
        value = dma_bits(0xEF8A, self.address, 16, 16, value)
        return(value)
    ## StatusCml
    def statusCml(self, value = None):
        value = dma_bits(0xEF8A, self.address, 8, 8, value)
        return(value)
    ## StatusMfr
    def statusMfr(self, value = None):
        value = dma_bits(0xEF8A, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register B
###################################################################
class snapB_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8B, None)
            self.statusTemp0 = (self.reg_value >> 24) & 0xFF
            self.statusInput0 = (self.reg_value >> 16) & 0xFF
            self.statusIout0 = (self.reg_value >> 8) & 0xFF
            self.statusVout0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snapB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.statusTemp0 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.statusInput0 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.statusIout0 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.statusVout0 & 0xFF)
        dma(self.address, 0xEF8B, reg)
    ## StatusTemp0
    def statusTemp0(self, value = None):
        value = dma_bits(0xEF8B, self.address, 8, 24, value)
        return(value)
    ## StatusInput0
    def statusInput0(self, value = None):
        value = dma_bits(0xEF8B, self.address, 8, 16, value)
        return(value)
    ## StatusIout0
    def statusIout0(self, value = None):
        value = dma_bits(0xEF8B, self.address, 8, 8, value)
        return(value)
    ## StatusVout0
    def statusVout0(self, value = None):
        value = dma_bits(0xEF8B, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register C
###################################################################
class snapC_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapC_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8C, None)
            self.statusTemp1 = (self.reg_value >> 24) & 0xFF
            self.statusInput1 = (self.reg_value >> 16) & 0xFF
            self.statusIout1 = (self.reg_value >> 8) & 0xFF
            self.statusVout1 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snapC_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.statusTemp1 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.statusInput1 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.statusIout1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.statusVout1 & 0xFF)
        dma(self.address, 0xEF8C, reg)
    ## StatusTemp1
    def statusTemp1(self, value = None):
        value = dma_bits(0xEF8C, self.address, 8, 24, value)
        return(value)
    ## StatusInput1
    def statusInput1(self, value = None):
        value = dma_bits(0xEF8C, self.address, 8, 16, value)
        return(value)
    ## StatusIout1
    def statusIout1(self, value = None):
        value = dma_bits(0xEF8C, self.address, 8, 8, value)
        return(value)
    ## StatusVout1
    def statusVout1(self, value = None):
        value = dma_bits(0xEF8C, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register D
###################################################################
class snapD_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapD_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8D, None)
            self.statusTemp2 = (self.reg_value >> 24) & 0xFF
            self.statusInput2 = (self.reg_value >> 16) & 0xFF
            self.statusIout2 = (self.reg_value >> 8) & 0xFF
            self.statusVout2 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snapD_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.statusTemp2 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.statusInput2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.statusIout2 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.statusVout2 & 0xFF)
        dma(self.address, 0xEF8D, reg)
    ## StatusTemp2
    def statusTemp2(self, value = None):
        value = dma_bits(0xEF8D, self.address, 8, 24, value)
        return(value)
    ## StatusInput2
    def statusInput2(self, value = None):
        value = dma_bits(0xEF8D, self.address, 8, 16, value)
        return(value)
    ## StatusIout2
    def statusIout2(self, value = None):
        value = dma_bits(0xEF8D, self.address, 8, 8, value)
        return(value)
    ## StatusVout2
    def statusVout2(self, value = None):
        value = dma_bits(0xEF8D, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register E
###################################################################
class snapE_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8E, None)
            self.iout0 = (self.reg_value >> 16) & 0xFFFF
            self.vout0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snapE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iout0 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vout0 & 0xFFFF)
        dma(self.address, 0xEF8E, reg)
    ## Iout0
    def iout0(self, value = None):
        value = dma_bits(0xEF8E, self.address, 16, 16, value)
        return(value)
    ## Vout0
    def vout0(self, value = None):
        value = dma_bits(0xEF8E, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register F
###################################################################
class snapF_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF8F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snapF_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF8F, None)
            self.iout1 = (self.reg_value >> 16) & 0xFFFF
            self.vout1 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snapF_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iout1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vout1 & 0xFFFF)
        dma(self.address, 0xEF8F, reg)
    ## Iout1
    def iout1(self, value = None):
        value = dma_bits(0xEF8F, self.address, 16, 16, value)
        return(value)
    ## Vout1
    def vout1(self, value = None):
        value = dma_bits(0xEF8F, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 10
###################################################################
class snap10_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF90, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap10_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF90, None)
            self.iout2 = (self.reg_value >> 16) & 0xFFFF
            self.vout2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap10_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iout2 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vout2 & 0xFFFF)
        dma(self.address, 0xEF90, reg)
    ## Iout2
    def iout2(self, value = None):
        value = dma_bits(0xEF90, self.address, 16, 16, value)
        return(value)
    ## Vout2
    def vout2(self, value = None):
        value = dma_bits(0xEF90, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 11
###################################################################
class snap11_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF91, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap11_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF91, None)
            self.iinSen0 = (self.reg_value >> 16) & 0xFFFF
            self.vinSen0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap11_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iinSen0 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vinSen0 & 0xFFFF)
        dma(self.address, 0xEF91, reg)
    ## IinSen0
    def iinSen0(self, value = None):
        value = dma_bits(0xEF91, self.address, 16, 16, value)
        return(value)
    ## VinSen0
    def vinSen0(self, value = None):
        value = dma_bits(0xEF91, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 12
###################################################################
class snap12_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF92, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap12_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF92, None)
            self.tempInt = (self.reg_value >> 24) & 0xFF
            self.temp2 = (self.reg_value >> 16) & 0xFF
            self.temp1 = (self.reg_value >> 8) & 0xFF
            self.temp0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snap12_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.tempInt & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.temp2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.temp1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.temp0 & 0xFF)
        dma(self.address, 0xEF92, reg)
    ## TempInt
    def tempInt(self, value = None):
        value = dma_bits(0xEF92, self.address, 8, 24, value)
        return(value)
    ## Temp2
    def temp2(self, value = None):
        value = dma_bits(0xEF92, self.address, 8, 16, value)
        return(value)
    ## Temp1
    def temp1(self, value = None):
        value = dma_bits(0xEF92, self.address, 8, 8, value)
        return(value)
    ## Temp0
    def temp0(self, value = None):
        value = dma_bits(0xEF92, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register 13
###################################################################
class snap13_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF93, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap13_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF93, None)
            self.phTemp3 = (self.reg_value >> 24) & 0xFF
            self.phTemp2 = (self.reg_value >> 16) & 0xFF
            self.phTemp1 = (self.reg_value >> 8) & 0xFF
            self.phTemp0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snap13_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.phTemp3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.phTemp2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.phTemp1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.phTemp0 & 0xFF)
        dma(self.address, 0xEF93, reg)
    ## PhTemp3
    def phTemp3(self, value = None):
        value = dma_bits(0xEF93, self.address, 8, 24, value)
        return(value)
    ## PhTemp2
    def phTemp2(self, value = None):
        value = dma_bits(0xEF93, self.address, 8, 16, value)
        return(value)
    ## PhTemp1
    def phTemp1(self, value = None):
        value = dma_bits(0xEF93, self.address, 8, 8, value)
        return(value)
    ## PhTemp0
    def phTemp0(self, value = None):
        value = dma_bits(0xEF93, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register 14
###################################################################
class snap14_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF94, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap14_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF94, None)
            self.phTemp7 = (self.reg_value >> 24) & 0xFF
            self.phTemp6 = (self.reg_value >> 16) & 0xFF
            self.phTemp5 = (self.reg_value >> 8) & 0xFF
            self.phTemp4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.snap14_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.phTemp7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.phTemp6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.phTemp5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.phTemp4 & 0xFF)
        dma(self.address, 0xEF94, reg)
    ## PhTemp7
    def phTemp7(self, value = None):
        value = dma_bits(0xEF94, self.address, 8, 24, value)
        return(value)
    ## PhTemp6
    def phTemp6(self, value = None):
        value = dma_bits(0xEF94, self.address, 8, 16, value)
        return(value)
    ## PhTemp5
    def phTemp5(self, value = None):
        value = dma_bits(0xEF94, self.address, 8, 8, value)
        return(value)
    ## PhTemp4
    def phTemp4(self, value = None):
        value = dma_bits(0xEF94, self.address, 8, 0, value)
        return(value)

###################################################################
## Snapshot register 15
###################################################################
class snap15_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF95, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap15_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF95, None)
            self.phCurr1 = (self.reg_value >> 16) & 0xFFFF
            self.phCurr0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap15_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.phCurr1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.phCurr0 & 0xFFFF)
        dma(self.address, 0xEF95, reg)
    ## PhCurr1
    def phCurr1(self, value = None):
        value = dma_bits(0xEF95, self.address, 16, 16, value)
        return(value)
    ## PhCurr0
    def phCurr0(self, value = None):
        value = dma_bits(0xEF95, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 16
###################################################################
class snap16_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF96, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap16_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF96, None)
            self.phCurr3 = (self.reg_value >> 16) & 0xFFFF
            self.phCurr2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap16_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.phCurr3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.phCurr2 & 0xFFFF)
        dma(self.address, 0xEF96, reg)
    ## PhCurr3
    def phCurr3(self, value = None):
        value = dma_bits(0xEF96, self.address, 16, 16, value)
        return(value)
    ## PhCurr2
    def phCurr2(self, value = None):
        value = dma_bits(0xEF96, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 17
###################################################################
class snap17_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF97, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap17_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF97, None)
            self.phCurr5 = (self.reg_value >> 16) & 0xFFFF
            self.phCurr4 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap17_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.phCurr5 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.phCurr4 & 0xFFFF)
        dma(self.address, 0xEF97, reg)
    ## PhCurr5
    def phCurr5(self, value = None):
        value = dma_bits(0xEF97, self.address, 16, 16, value)
        return(value)
    ## PhCurr4
    def phCurr4(self, value = None):
        value = dma_bits(0xEF97, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 18
###################################################################
class snap18_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF98, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class snap18_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF98, None)
            self.phCurr7 = (self.reg_value >> 16) & 0xFFFF
            self.phCurr6 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.snap18_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.phCurr7 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.phCurr6 & 0xFFFF)
        dma(self.address, 0xEF98, reg)
    ## PhCurr7
    def phCurr7(self, value = None):
        value = dma_bits(0xEF98, self.address, 16, 16, value)
        return(value)
    ## PhCurr6
    def phCurr6(self, value = None):
        value = dma_bits(0xEF98, self.address, 16, 0, value)
        return(value)

###################################################################
## Snapshot register 19
###################################################################
class snap19_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF99, value)
        return(value)


###################################################################
## Snapshot register 1A
###################################################################
class snap1A_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9A, value)
        return(value)


###################################################################
## Snapshot register 1B
###################################################################
class snap1B_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9B, value)
        return(value)


###################################################################
## Snapshot register 1C
###################################################################
class snap1C_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9C, value)
        return(value)


###################################################################
## Snapshot register 1D
###################################################################
class snap1D_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9D, value)
        return(value)


###################################################################
## Snapshot register 1E
###################################################################
class snap1E_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9E, value)
        return(value)


###################################################################
## Snapshot register 1F
###################################################################
class snap1F_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF9F, value)
        return(value)


###################################################################
## Snapshot register 20
###################################################################
class snap20_class(object):
    def __init__(self, address):
        self.interface = 'snapBus'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEFA0, value)
        return(value)


###################################################################
## Patch Version
###################################################################
class rPATCHVERSION_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x30, value)
        return(value)


###################################################################
## Firmware Startup State
###################################################################
class rFWSTATE_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x31, value)
        return(value)


###################################################################
## Firmware Status
###################################################################
class rFWSTATUS_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x32, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFWSTATUS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x32, None)
            self.mcuCmd1Complete = (self.reg_value >> 9) & 0x1
            self.startUpComplete = (self.reg_value >> 8) & 0x1
            self.ssArmed = (self.reg_value >> 7) & 0x1
            self.bbArmed = (self.reg_value >> 6) & 0x1
            self.bbInProgress = (self.reg_value >> 5) & 0x1
            self.mfrMode = (self.reg_value >> 1) & 0x1
            self.bbWritten = self.reg_value & 0x1

    def read_object(self):
        return(self.rFWSTATUS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFDFF) + ((register_object.mcuCmd1Complete & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.startUpComplete & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.ssArmed & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.bbArmed & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.bbInProgress & 0x1) << 5)
        reg = (reg & 0xFFFFFFFD) + ((register_object.mfrMode & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.bbWritten & 0x1)
        dma(self.address, 0x32, reg)
    ## FW completed processing MCUCMD1
    def mcuCmd1Complete(self, value = None):
        value = dma_bits(0x32, self.address, 1, 9, value)
        return(value)
    ## Firmware has completed start up sequence (RFWSTATE >= DIAGDONE)
    def startUpComplete(self, value = None):
        value = dma_bits(0x32, self.address, 1, 8, value)
        return(value)
    ## Snap Shot write is armed (SSEN=1, DMA transfer armed)
    def ssArmed(self, value = None):
        value = dma_bits(0x32, self.address, 1, 7, value)
        return(value)
    ## Black Box write is armed (BB_ISR enabled)
    def bbArmed(self, value = None):
        value = dma_bits(0x32, self.address, 1, 6, value)
        return(value)
    ## Black Box write is in progress
    def bbInProgress(self, value = None):
        value = dma_bits(0x32, self.address, 1, 5, value)
        return(value)
    ## Firmware entered manufacturing mode
    def mfrMode(self, value = None):
        value = dma_bits(0x32, self.address, 1, 1, value)
        return(value)
    ## Black Box has been written at least once since POR
    def bbWritten(self, value = None):
        value = dma_bits(0x32, self.address, 1, 0, value)
        return(value)

###################################################################
## Firmware Control
###################################################################
class rFWCTRL_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x33, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFWCTRL_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x33, None)
            self.storePassword = (self.reg_value >> 3) & 0x1
            self.repairOtp = (self.reg_value >> 2) & 0x1
            self.mfrPatchForceWrite = (self.reg_value >> 1) & 0x1
            self.mfrPinToggle = self.reg_value & 0x1

    def read_object(self):
        return(self.rFWCTRL_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF7) + ((register_object.storePassword & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.repairOtp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.mfrPatchForceWrite & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.mfrPinToggle & 0x1)
        dma(self.address, 0x33, reg)
    ## Store password into OTP when writing to PMBus PASSWORD
    def storePassword(self, value = None):
        value = dma_bits(0x33, self.address, 1, 3, value)
        return(value)
    ## Enable firmware repair of OTP using row replacement
    def repairOtp(self, value = None):
        value = dma_bits(0x33, self.address, 1, 2, value)
        return(value)
    ## Force the patch writer to always overwrite existing patch in OTP
    def mfrPatchForceWrite(self, value = None):
        value = dma_bits(0x33, self.address, 1, 1, value)
        return(value)
    ## Disable GPIO toggling (to support programming while regulating)
    def mfrPinToggle(self, value = None):
        value = dma_bits(0x33, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM patch end word address
###################################################################
class rPATCHEND_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x34, value)
        return(value)


###################################################################
## OTP patch end byte address (0x60000000)
###################################################################
class rOTPPATCHEND_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x35, value)
        return(value)


###################################################################
## OTP config end byte address (0x60000000)
###################################################################
class rOTPCFGEND_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x36, value)
        return(value)


###################################################################
## Informational RAM register to help debug configuration load
###################################################################
class rCONFIG_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x37, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCONFIG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x37, None)
            self.prefacIndex = (self.reg_value >> 24) & 0xFF
            self.facIndex = (self.reg_value >> 16) & 0xFF
            self.userBaseNumber = (self.reg_value >> 8) & 0xFF
            self.userNumber = self.reg_value & 0xFF

    def read_object(self):
        return(self.rCONFIG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.prefacIndex & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.facIndex & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.userBaseNumber & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.userNumber & 0xFF)
        dma(self.address, 0x37, reg)
    ## OTP index of pre-factory configuration loaded
    def prefacIndex(self, value = None):
        value = dma_bits(0x37, self.address, 8, 24, value)
        return(value)
    ## OTP index of factory configuration loaded
    def facIndex(self, value = None):
        value = dma_bits(0x37, self.address, 8, 16, value)
        return(value)
    ## ID of base user configuration loaded (-1 means not found)
    def userBaseNumber(self, value = None):
        value = dma_bits(0x37, self.address, 8, 8, value)
        return(value)
    ## ID of user configuration selected
    def userNumber(self, value = None):
        value = dma_bits(0x37, self.address, 8, 0, value)
        return(value)

###################################################################
## Number of configurations available to the user
###################################################################
class rCONFIGAVAILABLE_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x38, value)
        return(value)


###################################################################
## Config Programmer Control Register
###################################################################
class rCFGPROGCTRL_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x39, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGPROGCTRL_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x39, None)
            self.size = (self.reg_value >> 16) & 0xFFFF
            self.increment = (self.reg_value >> 2) & 0x1
            self.load = (self.reg_value >> 1) & 0x1
            self.store = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGPROGCTRL_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.size & 0xFFFF) << 16)
        reg = (reg & 0xFFFFFFFB) + ((register_object.increment & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.load & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.store & 0x1)
        dma(self.address, 0x39, reg)
    ## Size of config in words
    def size(self, value = None):
        value = dma_bits(0x39, self.address, 16, 16, value)
        return(value)
    ## Config loaded in RAM is incremental, must set either the load or store bit
    def increment(self, value = None):
        value = dma_bits(0x39, self.address, 1, 2, value)
        return(value)
    ## Live load config to registers (config unpack)
    def load(self, value = None):
        value = dma_bits(0x39, self.address, 1, 1, value)
        return(value)
    ## Store config bank to OTP
    def store(self, value = None):
        value = dma_bits(0x39, self.address, 1, 0, value)
        return(value)

###################################################################
## Config Programmer Status Register
###################################################################
class rCFGPROGSTAT_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGPROGSTAT_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x3A, None)
            self.invalidBase = (self.reg_value >> 4) & 0x1
            self.otpCrcFail = (self.reg_value >> 3) & 0x1
            self.ramCrcFail = (self.reg_value >> 2) & 0x1
            self.configFull = (self.reg_value >> 1) & 0x1
            self.complete = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGPROGSTAT_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFEF) + ((register_object.invalidBase & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.otpCrcFail & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ramCrcFail & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.configFull & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.complete & 0x1)
        dma(self.address, 0x3A, reg)
    ## Incremental config to be loaded or stored pointed to an invalid base
    def invalidBase(self, value = None):
        value = dma_bits(0x3A, self.address, 1, 4, value)
        return(value)
    ## Programmed config failed OTP CRC check
    def otpCrcFail(self, value = None):
        value = dma_bits(0x3A, self.address, 1, 3, value)
        return(value)
    ## Config bank failed RAM CRC check, OTP not committed
    def ramCrcFail(self, value = None):
        value = dma_bits(0x3A, self.address, 1, 2, value)
        return(value)
    ## Not enough OTP to write config
    def configFull(self, value = None):
        value = dma_bits(0x3A, self.address, 1, 1, value)
        return(value)
    ## Programmer operation completed, check fail status above
    def complete(self, value = None):
        value = dma_bits(0x3A, self.address, 1, 0, value)
        return(value)

###################################################################
## OTP byte address (0x60000000) of base config loaded (0=none, -1=invalid)
###################################################################
class rCFGOTPBASEADDR_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3B, value)
        return(value)


###################################################################
## OTP byte address (0x60000000) of incremental config loaded (0=none, -1=invalid)
###################################################################
class rCFGOTPINCADDR_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3C, value)
        return(value)


###################################################################
## Config OTP Word Address 01
###################################################################
class rCFGOTPADDR01_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x3D, None)
            self.addr1 = (self.reg_value >> 16) & 0xFFFF
            self.addr0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr0 & 0xFFFF)
        dma(self.address, 0x3D, reg)
    ## Config OTP Word Address 1 (0=none, -1=invalid)
    def addr1(self, value = None):
        value = dma_bits(0x3D, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 0 (0=none, -1=invalid)
    def addr0(self, value = None):
        value = dma_bits(0x3D, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 23
###################################################################
class rCFGOTPADDR23_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x3E, None)
            self.addr3 = (self.reg_value >> 16) & 0xFFFF
            self.addr2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr2 & 0xFFFF)
        dma(self.address, 0x3E, reg)
    ## Config OTP Word Address 3 (0=none, -1=invalid)
    def addr3(self, value = None):
        value = dma_bits(0x3E, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 2 (0=none, -1=invalid)
    def addr2(self, value = None):
        value = dma_bits(0x3E, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 45
###################################################################
class rCFGOTPADDR45_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x3F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR45_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x3F, None)
            self.addr5 = (self.reg_value >> 16) & 0xFFFF
            self.addr4 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR45_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr5 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr4 & 0xFFFF)
        dma(self.address, 0x3F, reg)
    ## Config OTP Word Address 5 (0=none, -1=invalid)
    def addr5(self, value = None):
        value = dma_bits(0x3F, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 4 (0=none, -1=invalid)
    def addr4(self, value = None):
        value = dma_bits(0x3F, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 67
###################################################################
class rCFGOTPADDR67_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x40, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR67_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x40, None)
            self.addr7 = (self.reg_value >> 16) & 0xFFFF
            self.addr6 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR67_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr7 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr6 & 0xFFFF)
        dma(self.address, 0x40, reg)
    ## Config OTP Word Address 7 (0=none, -1=invalid)
    def addr7(self, value = None):
        value = dma_bits(0x40, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 6 (0=none, -1=invalid)
    def addr6(self, value = None):
        value = dma_bits(0x40, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 89
###################################################################
class rCFGOTPADDR89_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x41, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR89_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x41, None)
            self.addr9 = (self.reg_value >> 16) & 0xFFFF
            self.addr8 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR89_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr9 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr8 & 0xFFFF)
        dma(self.address, 0x41, reg)
    ## Config OTP Word Address 9 (0=none, -1=invalid)
    def addr9(self, value = None):
        value = dma_bits(0x41, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 8 (0=none, -1=invalid)
    def addr8(self, value = None):
        value = dma_bits(0x41, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 1011
###################################################################
class rCFGOTPADDR1011_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x42, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR1011_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x42, None)
            self.addr11 = (self.reg_value >> 16) & 0xFFFF
            self.addr10 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR1011_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr11 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr10 & 0xFFFF)
        dma(self.address, 0x42, reg)
    ## Config OTP Word Address 11 (0=none, -1=invalid)
    def addr11(self, value = None):
        value = dma_bits(0x42, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 10 (0=none, -1=invalid)
    def addr10(self, value = None):
        value = dma_bits(0x42, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 1213
###################################################################
class rCFGOTPADDR1213_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x43, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR1213_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x43, None)
            self.addr13 = (self.reg_value >> 16) & 0xFFFF
            self.addr12 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR1213_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr13 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr12 & 0xFFFF)
        dma(self.address, 0x43, reg)
    ## Config OTP Word Address 13 (0=none, -1=invalid)
    def addr13(self, value = None):
        value = dma_bits(0x43, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 12 (0=none, -1=invalid)
    def addr12(self, value = None):
        value = dma_bits(0x43, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 1415
###################################################################
class rCFGOTPADDR1415_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x44, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR1415_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x44, None)
            self.addr15 = (self.reg_value >> 16) & 0xFFFF
            self.addr14 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR1415_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr15 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr14 & 0xFFFF)
        dma(self.address, 0x44, reg)
    ## Config OTP Word Address 15 (0=none, -1=invalid)
    def addr15(self, value = None):
        value = dma_bits(0x44, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 14 (0=none, -1=invalid)
    def addr14(self, value = None):
        value = dma_bits(0x44, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 1617
###################################################################
class rCFGOTPADDR1617_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x45, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR1617_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x45, None)
            self.addr17 = (self.reg_value >> 16) & 0xFFFF
            self.addr16 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR1617_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr17 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr16 & 0xFFFF)
        dma(self.address, 0x45, reg)
    ## Config OTP Word Address 17 (0=none, -1=invalid)
    def addr17(self, value = None):
        value = dma_bits(0x45, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 16 (0=none, -1=invalid)
    def addr16(self, value = None):
        value = dma_bits(0x45, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 1819
###################################################################
class rCFGOTPADDR1819_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x46, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR1819_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x46, None)
            self.addr19 = (self.reg_value >> 16) & 0xFFFF
            self.addr18 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR1819_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr19 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr18 & 0xFFFF)
        dma(self.address, 0x46, reg)
    ## Config OTP Word Address 19 (0=none, -1=invalid)
    def addr19(self, value = None):
        value = dma_bits(0x46, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 18 (0=none, -1=invalid)
    def addr18(self, value = None):
        value = dma_bits(0x46, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 2021
###################################################################
class rCFGOTPADDR2021_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x47, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR2021_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x47, None)
            self.addr21 = (self.reg_value >> 16) & 0xFFFF
            self.addr20 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR2021_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr21 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr20 & 0xFFFF)
        dma(self.address, 0x47, reg)
    ## Config OTP Word Address 21 (0=none, -1=invalid)
    def addr21(self, value = None):
        value = dma_bits(0x47, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 20 (0=none, -1=invalid)
    def addr20(self, value = None):
        value = dma_bits(0x47, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 2223
###################################################################
class rCFGOTPADDR2223_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x48, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR2223_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x48, None)
            self.addr23 = (self.reg_value >> 16) & 0xFFFF
            self.addr22 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR2223_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr23 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr22 & 0xFFFF)
        dma(self.address, 0x48, reg)
    ## Config OTP Word Address 23 (0=none, -1=invalid)
    def addr23(self, value = None):
        value = dma_bits(0x48, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 22 (0=none, -1=invalid)
    def addr22(self, value = None):
        value = dma_bits(0x48, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 2425
###################################################################
class rCFGOTPADDR2425_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x49, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR2425_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x49, None)
            self.addr25 = (self.reg_value >> 16) & 0xFFFF
            self.addr24 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR2425_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr25 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr24 & 0xFFFF)
        dma(self.address, 0x49, reg)
    ## Config OTP Word Address 25 (0=none, -1=invalid)
    def addr25(self, value = None):
        value = dma_bits(0x49, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 24 (0=none, -1=invalid)
    def addr24(self, value = None):
        value = dma_bits(0x49, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 2627
###################################################################
class rCFGOTPADDR2627_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR2627_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x4A, None)
            self.addr27 = (self.reg_value >> 16) & 0xFFFF
            self.addr26 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR2627_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr27 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr26 & 0xFFFF)
        dma(self.address, 0x4A, reg)
    ## Config OTP Word Address 27 (0=none, -1=invalid)
    def addr27(self, value = None):
        value = dma_bits(0x4A, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 26 (0=none, -1=invalid)
    def addr26(self, value = None):
        value = dma_bits(0x4A, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 2829
###################################################################
class rCFGOTPADDR2829_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR2829_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x4B, None)
            self.addr29 = (self.reg_value >> 16) & 0xFFFF
            self.addr28 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR2829_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr29 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr28 & 0xFFFF)
        dma(self.address, 0x4B, reg)
    ## Config OTP Word Address 29 (0=none, -1=invalid)
    def addr29(self, value = None):
        value = dma_bits(0x4B, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 28 (0=none, -1=invalid)
    def addr28(self, value = None):
        value = dma_bits(0x4B, self.address, 16, 0, value)
        return(value)

###################################################################
## Config OTP Word Address 3031
###################################################################
class rCFGOTPADDR3031_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGOTPADDR3031_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x4C, None)
            self.addr31 = (self.reg_value >> 16) & 0xFFFF
            self.addr30 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGOTPADDR3031_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.addr31 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr30 & 0xFFFF)
        dma(self.address, 0x4C, reg)
    ## Config OTP Word Address 31 (0=none, -1=invalid)
    def addr31(self, value = None):
        value = dma_bits(0x4C, self.address, 16, 16, value)
        return(value)
    ## Config OTP Word Address 30 (0=none, -1=invalid)
    def addr30(self, value = None):
        value = dma_bits(0x4C, self.address, 16, 0, value)
        return(value)

###################################################################
## pinOpnStatusA firmware read at startup
###################################################################
class rPINOPNSTATUSA_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4D, value)
        return(value)


###################################################################
## pinOpnStatusB firmware read at startup
###################################################################
class rPINOPNSTATUSB_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4E, value)
        return(value)


###################################################################
## Black Box Base Address
###################################################################
class rBBADDR_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x4F, value)
        return(value)


###################################################################
## Snap Shot Base Address
###################################################################
class rSSADDR_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x50, value)
        return(value)


###################################################################
## CRC of Patch image loaded from OTP into RAM
###################################################################
class rPATCHCRC_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x51, value)
        return(value)


###################################################################
## CRC of Pre-MFR configuration and trims loaded from OTP into RAM
###################################################################
class rPREMFRCRC_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x52, value)
        return(value)


###################################################################
## CRC of MFR configuration and trims loaded from OTP into RAM
###################################################################
class rMFRCRC_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x53, value)
        return(value)


###################################################################
## Configuration number selected by CONFIGSEL pinstrap
###################################################################
class rPINSTRAPCONFIGSEL_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x54, value)
        return(value)


###################################################################
## MCUCMD0 Status
###################################################################
class rMCUCMD0STATUS_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x55, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rMCUCMD0STATUS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x55, None)
            self.pass_field = (self.reg_value >> 31) & 0x1
            self.fail = (self.reg_value >> 30) & 0x1
            self.inProgress = (self.reg_value >> 29) & 0x1
            self.complete = (self.reg_value >> 28) & 0x1
            self.cmd = self.reg_value & 0xFFFFFFF

    def read_object(self):
        return(self.rMCUCMD0STATUS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pass_field & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.fail & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.inProgress & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.complete & 0x1) << 28)
        reg = (reg & 0xF0000000) + (register_object.cmd & 0xFFFFFFF)
        dma(self.address, 0x55, reg)
    ## Test passed or action completed successfully
    def pass_field(self, value = None):
        value = dma_bits(0x55, self.address, 1, 31, value)
        return(value)
    ## Test failed or action completed unsuccessfully
    def fail(self, value = None):
        value = dma_bits(0x55, self.address, 1, 30, value)
        return(value)
    ## Test or action in progress
    def inProgress(self, value = None):
        value = dma_bits(0x55, self.address, 1, 29, value)
        return(value)
    ## Test or action completed
    def complete(self, value = None):
        value = dma_bits(0x55, self.address, 1, 28, value)
        return(value)
    ## Command number
    def cmd(self, value = None):
        value = dma_bits(0x55, self.address, 28, 0, value)
        return(value)

###################################################################
## MCUCMD0 Run Vector Type (Function Signature Type)
###################################################################
class rRUNVECTTYPE_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x56, value)
        return(value)


###################################################################
## MCUCMD0 Run Vector Output (Return Value)
###################################################################
class rRUNVECTOUT_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x57, value)
        return(value)


###################################################################
## MCUCMD0 Run Vector Input 1 (First Parameter)
###################################################################
class rRUNVECTIN1_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x58, value)
        return(value)


###################################################################
## MCUCMD0 Run Vector Input 2 (Second Parameter)
###################################################################
class rRUNVECTIN2_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x59, value)
        return(value)


###################################################################
## MCUCMD0 Run Vector Input 3 (Third Parameter)
###################################################################
class rRUNVECTIN3_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5A, value)
        return(value)


###################################################################
## Firmware readings of config and address pins during initialization
###################################################################
class rUTCADDRRD_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCADDRRD_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x5B, None)
            self.configSel = (self.reg_value >> 16) & 0xFFFF
            self.addr = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rUTCADDRRD_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.configSel & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr & 0xFFFF)
        dma(self.address, 0x5B, reg)
    ## Config pin reading
    def configSel(self, value = None):
        value = dma_bits(0x5B, self.address, 16, 16, value)
        return(value)
    ## Address pin reading
    def addr(self, value = None):
        value = dma_bits(0x5B, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTEST_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTEST_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x5C, None)
            self.repeatTest = (self.reg_value >> 16) & 0xFFFF
            self.margin = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTEST_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.repeatTest & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.margin & 0xFFFF)
        dma(self.address, 0x5C, reg)
    def repeatTest(self, value = None):
        value = dma_bits(0x5C, self.address, 16, 16, value)
        return(value)
    def margin(self, value = None):
        value = dma_bits(0x5C, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTEST0_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTEST0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x5D, None)
            self.boottest01 = (self.reg_value >> 16) & 0xFFFF
            self.boottest00 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTEST0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottest01 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottest00 & 0xFFFF)
        dma(self.address, 0x5D, reg)
    def boottest01(self, value = None):
        value = dma_bits(0x5D, self.address, 16, 16, value)
        return(value)
    def boottest00(self, value = None):
        value = dma_bits(0x5D, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTEST1_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTEST1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x5E, None)
            self.boottest03 = (self.reg_value >> 16) & 0xFFFF
            self.boottest02 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTEST1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottest03 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottest02 & 0xFFFF)
        dma(self.address, 0x5E, reg)
    def boottest03(self, value = None):
        value = dma_bits(0x5E, self.address, 16, 16, value)
        return(value)
    def boottest02(self, value = None):
        value = dma_bits(0x5E, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTEST2_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x5F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTEST2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x5F, None)
            self.boottest11 = (self.reg_value >> 16) & 0xFFFF
            self.boottest10 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTEST2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottest11 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottest10 & 0xFFFF)
        dma(self.address, 0x5F, reg)
    def boottest11(self, value = None):
        value = dma_bits(0x5F, self.address, 16, 16, value)
        return(value)
    def boottest10(self, value = None):
        value = dma_bits(0x5F, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTEST3_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x60, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTEST3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x60, None)
            self.boottest13 = (self.reg_value >> 16) & 0xFFFF
            self.boottest12 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTEST3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottest13 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottest12 & 0xFFFF)
        dma(self.address, 0x60, reg)
    def boottest13(self, value = None):
        value = dma_bits(0x60, self.address, 16, 16, value)
        return(value)
    def boottest12(self, value = None):
        value = dma_bits(0x60, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTESTEXP0_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x61, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTEXP0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x61, None)
            self.boottestExp01 = (self.reg_value >> 16) & 0xFFFF
            self.boottestExp00 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTEXP0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottestExp01 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottestExp00 & 0xFFFF)
        dma(self.address, 0x61, reg)
    def boottestExp01(self, value = None):
        value = dma_bits(0x61, self.address, 16, 16, value)
        return(value)
    def boottestExp00(self, value = None):
        value = dma_bits(0x61, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTESTEXP1_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x62, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTEXP1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x62, None)
            self.boottestExp03 = (self.reg_value >> 16) & 0xFFFF
            self.boottestExp02 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTEXP1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottestExp03 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottestExp02 & 0xFFFF)
        dma(self.address, 0x62, reg)
    def boottestExp03(self, value = None):
        value = dma_bits(0x62, self.address, 16, 16, value)
        return(value)
    def boottestExp02(self, value = None):
        value = dma_bits(0x62, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTESTEXP2_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x63, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTEXP2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x63, None)
            self.boottestExp11 = (self.reg_value >> 16) & 0xFFFF
            self.boottestExp10 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTEXP2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottestExp11 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottestExp10 & 0xFFFF)
        dma(self.address, 0x63, reg)
    def boottestExp11(self, value = None):
        value = dma_bits(0x63, self.address, 16, 16, value)
        return(value)
    def boottestExp10(self, value = None):
        value = dma_bits(0x63, self.address, 16, 0, value)
        return(value)

###################################################################
## For Boot Up FB test
###################################################################
class rBOOTTESTEXP3_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x64, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTEXP3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x64, None)
            self.boottestExp13 = (self.reg_value >> 16) & 0xFFFF
            self.boottestExp12 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTEXP3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.boottestExp13 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.boottestExp12 & 0xFFFF)
        dma(self.address, 0x64, reg)
    def boottestExp13(self, value = None):
        value = dma_bits(0x64, self.address, 16, 16, value)
        return(value)
    def boottestExp12(self, value = None):
        value = dma_bits(0x64, self.address, 16, 0, value)
        return(value)

###################################################################
## VoutCmd = Vout_init +- Vout_step
###################################################################
class rBOOTTESTVOUT_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x65, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTVOUT_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x65, None)
            self.delay = (self.reg_value >> 16) & 0xFFFF
            self.init = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTVOUT_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.delay & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.init & 0xFFFF)
        dma(self.address, 0x65, reg)
    ## Delay in us between Vout change (200)
    def delay(self, value = None):
        value = dma_bits(0x65, self.address, 16, 16, value)
        return(value)
    ## Initial Vout (0x400)
    def init(self, value = None):
        value = dma_bits(0x65, self.address, 16, 0, value)
        return(value)

###################################################################
## Vout Steps
###################################################################
class rBOOTTESTSTEP_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x66, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rBOOTTESTSTEP_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x66, None)
            self.step1 = (self.reg_value >> 16) & 0xFFFF
            self.step0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rBOOTTESTSTEP_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.step1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.step0 & 0xFFFF)
        dma(self.address, 0x66, reg)
    ## Vout step0 (0x300)
    def step1(self, value = None):
        value = dma_bits(0x66, self.address, 16, 16, value)
        return(value)
    ## Vout step1 (0x500)
    def step0(self, value = None):
        value = dma_bits(0x66, self.address, 16, 0, value)
        return(value)

###################################################################
## Data logger RAM address and size
###################################################################
class rLOGGERADDR_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x67, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rLOGGERADDR_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x67, None)
            self.size = (self.reg_value >> 16) & 0xFFFF
            self.addr = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rLOGGERADDR_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.size & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.addr & 0xFFFF)
        dma(self.address, 0x67, reg)
    ## Data logger RAM size
    def size(self, value = None):
        value = dma_bits(0x67, self.address, 16, 16, value)
        return(value)
    ## Data logger RAM word address
    def addr(self, value = None):
        value = dma_bits(0x67, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL0A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x68, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL0A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x68, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL0A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x68, reg)
    ## Phase 0 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x68, self.address, 9, 21, value)
        return(value)
    ## Phase 0 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x68, self.address, 9, 12, value)
        return(value)
    ## Phase 0 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x68, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL0B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x69, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL0B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x69, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL0B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x69, reg)
    ## Phase 0 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x69, self.address, 8, 8, value)
        return(value)
    ## Phase 0 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x69, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL1A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL1A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6A, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL1A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x6A, reg)
    ## Phase 1 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x6A, self.address, 9, 21, value)
        return(value)
    ## Phase 1 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x6A, self.address, 9, 12, value)
        return(value)
    ## Phase 1 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x6A, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL1B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL1B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6B, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL1B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x6B, reg)
    ## Phase 1 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x6B, self.address, 8, 8, value)
        return(value)
    ## Phase 1 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x6B, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL2A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL2A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6C, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL2A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x6C, reg)
    ## Phase 2 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x6C, self.address, 9, 21, value)
        return(value)
    ## Phase 2 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x6C, self.address, 9, 12, value)
        return(value)
    ## Phase 2 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x6C, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL2B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL2B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6D, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL2B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x6D, reg)
    ## Phase 2 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x6D, self.address, 8, 8, value)
        return(value)
    ## Phase 2 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x6D, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL3A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL3A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6E, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL3A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x6E, reg)
    ## Phase 3 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x6E, self.address, 9, 21, value)
        return(value)
    ## Phase 3 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x6E, self.address, 9, 12, value)
        return(value)
    ## Phase 3 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x6E, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL3B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x6F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL3B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x6F, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL3B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x6F, reg)
    ## Phase 3 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x6F, self.address, 8, 8, value)
        return(value)
    ## Phase 3 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x6F, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL4A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x70, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL4A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x70, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL4A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x70, reg)
    ## Phase 4 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x70, self.address, 9, 21, value)
        return(value)
    ## Phase 4 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x70, self.address, 9, 12, value)
        return(value)
    ## Phase 4 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x70, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL4B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x71, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL4B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x71, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL4B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x71, reg)
    ## Phase 4 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x71, self.address, 8, 8, value)
        return(value)
    ## Phase 4 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x71, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL5A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x72, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL5A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x72, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL5A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x72, reg)
    ## Phase 5 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x72, self.address, 9, 21, value)
        return(value)
    ## Phase 5 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x72, self.address, 9, 12, value)
        return(value)
    ## Phase 5 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x72, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL5B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x73, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL5B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x73, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL5B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x73, reg)
    ## Phase 5 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x73, self.address, 8, 8, value)
        return(value)
    ## Phase 5 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x73, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL6A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x74, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL6A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x74, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL6A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x74, reg)
    ## Phase 6 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x74, self.address, 9, 21, value)
        return(value)
    ## Phase 6 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x74, self.address, 9, 12, value)
        return(value)
    ## Phase 6 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x74, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL6B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x75, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL6B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x75, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL6B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x75, reg)
    ## Phase 6 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x75, self.address, 8, 8, value)
        return(value)
    ## Phase 6 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x75, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL7A_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x76, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL7A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x76, None)
            self.calData2 = (self.reg_value >> 21) & 0x1FF
            self.calData1 = (self.reg_value >> 12) & 0x1FF
            self.calData0 = self.reg_value & 0xFFF

    def read_object(self):
        return(self.rIMONCAL7A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xC01FFFFF) + ((register_object.calData2 & 0x1FF) << 21)
        reg = (reg & 0xFFE00FFF) + ((register_object.calData1 & 0x1FF) << 12)
        reg = (reg & 0xFFFFF000) + (register_object.calData0 & 0xFFF)
        dma(self.address, 0x76, reg)
    ## Phase 7 IMON cal data read from SDIF SPS device.
    def calData2(self, value = None):
        value = dma_bits(0x76, self.address, 9, 21, value)
        return(value)
    ## Phase 7 IMON cal data read from SDIF SPS device.
    def calData1(self, value = None):
        value = dma_bits(0x76, self.address, 9, 12, value)
        return(value)
    ## Phase 7 IMON cal data read from SDIF SPS device.
    def calData0(self, value = None):
        value = dma_bits(0x76, self.address, 12, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rIMONCAL7B_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x77, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rIMONCAL7B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x77, None)
            self.calData4 = (self.reg_value >> 8) & 0xFF
            self.calData3 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rIMONCAL7B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF00FF) + ((register_object.calData4 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.calData3 & 0xFF)
        dma(self.address, 0x77, reg)
    ## Phase 7 IMON cal data read from SDIF SPS device.
    def calData4(self, value = None):
        value = dma_bits(0x77, self.address, 8, 8, value)
        return(value)
    ## Phase 7 IMON cal data read from SDIF SPS device.
    def calData3(self, value = None):
        value = dma_bits(0x77, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRETRIES0_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x78, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRETRIES0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x78, None)
            self.phase3 = (self.reg_value >> 24) & 0xFF
            self.phase2 = (self.reg_value >> 16) & 0xFF
            self.phase1 = (self.reg_value >> 8) & 0xFF
            self.phase0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rSDIFRETRIES0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.phase3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.phase2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.phase1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.phase0 & 0xFF)
        dma(self.address, 0x78, reg)
    ## Number of times SDIF command has failed for this phase.
    def phase3(self, value = None):
        value = dma_bits(0x78, self.address, 8, 24, value)
        return(value)
    ## Number of times SDIF command has failed for this phase. Channel count for autozero.
    def phase2(self, value = None):
        value = dma_bits(0x78, self.address, 8, 16, value)
        return(value)
    ## Number of times SDIF command has failed for this phase. Channel count for autozero.
    def phase1(self, value = None):
        value = dma_bits(0x78, self.address, 8, 8, value)
        return(value)
    ## Number of times SDIF command has failed for this phase. Channel count for autozero.
    def phase0(self, value = None):
        value = dma_bits(0x78, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRETRIES1_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x79, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRETRIES1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x79, None)
            self.phase7 = (self.reg_value >> 24) & 0xFF
            self.phase6 = (self.reg_value >> 16) & 0xFF
            self.phase5 = (self.reg_value >> 8) & 0xFF
            self.phase4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rSDIFRETRIES1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.phase7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.phase6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.phase5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.phase4 & 0xFF)
        dma(self.address, 0x79, reg)
    ## Number of times SDIF command has failed for this phase.
    def phase7(self, value = None):
        value = dma_bits(0x79, self.address, 8, 24, value)
        return(value)
    ## Number of times SDIF command has failed for this phase.
    def phase6(self, value = None):
        value = dma_bits(0x79, self.address, 8, 16, value)
        return(value)
    ## Number of times SDIF command has failed for this phase.
    def phase5(self, value = None):
        value = dma_bits(0x79, self.address, 8, 8, value)
        return(value)
    ## Number of times SDIF command has failed for this phase.
    def phase4(self, value = None):
        value = dma_bits(0x79, self.address, 8, 0, value)
        return(value)

###################################################################
## SDIF Interface Firmware Status
###################################################################
class rFWSDIFSTATUS_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFWSDIFSTATUS_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7A, None)
            self.tempErrPhase = (self.reg_value >> 24) & 0xFF
            self.crcErrPhase = (self.reg_value >> 16) & 0xFF
            self.initErrPhase = (self.reg_value >> 8) & 0xFF
            self.tempRetryError = (self.reg_value >> 6) & 0x1
            self.tempConfigError = (self.reg_value >> 5) & 0x1
            self.azError = (self.reg_value >> 4) & 0x1
            self.crcError = (self.reg_value >> 3) & 0x1
            self.initError = (self.reg_value >> 2) & 0x1
            self.azInProgress = (self.reg_value >> 1) & 0x1
            self.initInProgress = self.reg_value & 0x1

    def read_object(self):
        return(self.rFWSDIFSTATUS_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.tempErrPhase & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.crcErrPhase & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.initErrPhase & 0xFF) << 8)
        reg = (reg & 0xFFFFFFBF) + ((register_object.tempRetryError & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.tempConfigError & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.azError & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.crcError & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.initError & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.azInProgress & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.initInProgress & 0x1)
        dma(self.address, 0x7A, reg)
    ## Phase 0-7 that NACKed a temp request.
    def tempErrPhase(self, value = None):
        value = dma_bits(0x7A, self.address, 8, 24, value)
        return(value)
    ## Phase 0-7 that had corrupted cal data with bad CRC.
    def crcErrPhase(self, value = None):
        value = dma_bits(0x7A, self.address, 8, 16, value)
        return(value)
    ## Phase 0-7 that NACKed an initialization command.
    def initErrPhase(self, value = None):
        value = dma_bits(0x7A, self.address, 8, 8, value)
        return(value)
    ## A phase has maxed out its retry count for too many NACKs. Check tempErrPhase for phase info.
    def tempRetryError(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 6, value)
        return(value)
    ## A configuration error detected for SDIF TMON setup. Not phase-specific.
    def tempConfigError(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 5, value)
        return(value)
    ## A group has maxed out its retry count for too many NACKs. Only MCUTEMPFLT will reflect errror.
    def azError(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 4, value)
        return(value)
    ## A phase has maxed out its retry count for too many NACKs. Check crcErrPhase for phase info.
    def crcError(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 3, value)
        return(value)
    ## A phase has maxed out its retry count for too many NACKs. Check initErrPhase for phase info.
    def initError(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 2, value)
        return(value)
    ## Startup autozero of SDIF SPS devices is in progress.
    def azInProgress(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 1, value)
        return(value)
    ## Initialization of SDIF SPS devices is in progress.
    def initInProgress(self, value = None):
        value = dma_bits(0x7A, self.address, 1, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRDSON01_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRDSON01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7B, None)
            self.rdson1 = (self.reg_value >> 16) & 0xFFFF
            self.rdson0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFRDSON01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.rdson1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.rdson0 & 0xFFFF)
        dma(self.address, 0x7B, reg)
    ## Per phase
    def rdson1(self, value = None):
        value = dma_bits(0x7B, self.address, 16, 16, value)
        return(value)
    ## Per phase
    def rdson0(self, value = None):
        value = dma_bits(0x7B, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRDSON23_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRDSON23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7C, None)
            self.rdson3 = (self.reg_value >> 16) & 0xFFFF
            self.rdson2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFRDSON23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.rdson3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.rdson2 & 0xFFFF)
        dma(self.address, 0x7C, reg)
    ## Per phase
    def rdson3(self, value = None):
        value = dma_bits(0x7C, self.address, 16, 16, value)
        return(value)
    ## Per phase
    def rdson2(self, value = None):
        value = dma_bits(0x7C, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRDSON45_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRDSON45_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7D, None)
            self.rdson5 = (self.reg_value >> 16) & 0xFFFF
            self.rdson4 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFRDSON45_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.rdson5 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.rdson4 & 0xFFFF)
        dma(self.address, 0x7D, reg)
    ## Per phase
    def rdson5(self, value = None):
        value = dma_bits(0x7D, self.address, 16, 16, value)
        return(value)
    ## Per phase
    def rdson4(self, value = None):
        value = dma_bits(0x7D, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFRDSON67_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFRDSON67_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7E, None)
            self.rdson7 = (self.reg_value >> 16) & 0xFFFF
            self.rdson6 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFRDSON67_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.rdson7 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.rdson6 & 0xFFFF)
        dma(self.address, 0x7E, reg)
    ## Per phase
    def rdson7(self, value = None):
        value = dma_bits(0x7E, self.address, 16, 16, value)
        return(value)
    ## Per phase
    def rdson6(self, value = None):
        value = dma_bits(0x7E, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFVCCRAW01_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x7F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFVCCRAW01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x7F, None)
            self.vcc1 = (self.reg_value >> 16) & 0xFFFF
            self.vcc0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFVCCRAW01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vcc1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vcc0 & 0xFFFF)
        dma(self.address, 0x7F, reg)
    ## Per phase Owl 5V vcc measurement
    def vcc1(self, value = None):
        value = dma_bits(0x7F, self.address, 16, 16, value)
        return(value)
    ## Per phase Owl 5V vcc measurement
    def vcc0(self, value = None):
        value = dma_bits(0x7F, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFVCCRAW23_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x80, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFVCCRAW23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x80, None)
            self.vcc3 = (self.reg_value >> 16) & 0xFFFF
            self.vcc2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFVCCRAW23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vcc3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vcc2 & 0xFFFF)
        dma(self.address, 0x80, reg)
    ## Per phase Owl 5V vcc measurement
    def vcc3(self, value = None):
        value = dma_bits(0x80, self.address, 16, 16, value)
        return(value)
    ## Per phase Owl 5V vcc measurement
    def vcc2(self, value = None):
        value = dma_bits(0x80, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFVCCRAW45_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x81, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFVCCRAW45_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x81, None)
            self.vcc5 = (self.reg_value >> 16) & 0xFFFF
            self.vcc4 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFVCCRAW45_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vcc5 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vcc4 & 0xFFFF)
        dma(self.address, 0x81, reg)
    ## Per phase Owl 5V vcc measurement
    def vcc5(self, value = None):
        value = dma_bits(0x81, self.address, 16, 16, value)
        return(value)
    ## Per phase Owl 5V vcc measurement
    def vcc4(self, value = None):
        value = dma_bits(0x81, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rSDIFVCCRAW67_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x82, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFVCCRAW67_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x82, None)
            self.vcc7 = (self.reg_value >> 16) & 0xFFFF
            self.vcc6 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rSDIFVCCRAW67_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vcc7 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vcc6 & 0xFFFF)
        dma(self.address, 0x82, reg)
    ## Per phase Owl 5V vcc measurement
    def vcc7(self, value = None):
        value = dma_bits(0x82, self.address, 16, 16, value)
        return(value)
    ## Per phase Owl 5V vcc measurement
    def vcc6(self, value = None):
        value = dma_bits(0x82, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rOWLPHFLTSTATA_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x83, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rOWLPHFLTSTATA_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x83, None)
            self.owlFltStatPh3 = (self.reg_value >> 24) & 0xFF
            self.owlFltStatPh2 = (self.reg_value >> 16) & 0xFF
            self.owlFltStatPh1 = (self.reg_value >> 8) & 0xFF
            self.owlFltStatPh0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rOWLPHFLTSTATA_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.owlFltStatPh3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.owlFltStatPh2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.owlFltStatPh1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.owlFltStatPh0 & 0xFF)
        dma(self.address, 0x83, reg)
    ## Phase 3 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh3(self, value = None):
        value = dma_bits(0x83, self.address, 8, 24, value)
        return(value)
    ## Phase 2 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh2(self, value = None):
        value = dma_bits(0x83, self.address, 8, 16, value)
        return(value)
    ## Phase 1 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh1(self, value = None):
        value = dma_bits(0x83, self.address, 8, 8, value)
        return(value)
    ## Phase 0 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh0(self, value = None):
        value = dma_bits(0x83, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rOWLPHFLTSTATB_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x84, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rOWLPHFLTSTATB_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x84, None)
            self.owlFltStatPh7 = (self.reg_value >> 24) & 0xFF
            self.owlFltStatPh6 = (self.reg_value >> 16) & 0xFF
            self.owlFltStatPh5 = (self.reg_value >> 8) & 0xFF
            self.owlFltStatPh4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rOWLPHFLTSTATB_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.owlFltStatPh7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.owlFltStatPh6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.owlFltStatPh5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.owlFltStatPh4 & 0xFF)
        dma(self.address, 0x84, reg)
    ## Phase 7 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh7(self, value = None):
        value = dma_bits(0x84, self.address, 8, 24, value)
        return(value)
    ## Phase 6 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh6(self, value = None):
        value = dma_bits(0x84, self.address, 8, 16, value)
        return(value)
    ## Phase 5 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh5(self, value = None):
        value = dma_bits(0x84, self.address, 8, 8, value)
        return(value)
    ## Phase 4 Owl fltStatus register (0x1C) value upon PHADCOCFLTSTAT detection.
    def owlFltStatPh4(self, value = None):
        value = dma_bits(0x84, self.address, 8, 0, value)
        return(value)

###################################################################
## ADDRESS Pinstrap Table 0
###################################################################
class rADDRPSTRAPTABLE0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x85, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 1
###################################################################
class rADDRPSTRAPTABLE1_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x86, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 2
###################################################################
class rADDRPSTRAPTABLE2_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x87, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 3
###################################################################
class rADDRPSTRAPTABLE3_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x88, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 4
###################################################################
class rADDRPSTRAPTABLE4_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x89, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 5
###################################################################
class rADDRPSTRAPTABLE5_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8A, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 6
###################################################################
class rADDRPSTRAPTABLE6_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8B, value)
        return(value)


###################################################################
## ADDRESS Pinstrap Table 7
###################################################################
class rADDRPSTRAPTABLE7_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8C, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 0
###################################################################
class rCFGPSTRAPTABLE0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8D, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 1
###################################################################
class rCFGPSTRAPTABLE1_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8E, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 2
###################################################################
class rCFGPSTRAPTABLE2_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x8F, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 3
###################################################################
class rCFGPSTRAPTABLE3_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x90, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 4
###################################################################
class rCFGPSTRAPTABLE4_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x91, value)
        return(value)


###################################################################
## CONFIG Pinstrap Table 5
###################################################################
class rCFGPSTRAPTABLE5_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x92, value)
        return(value)


###################################################################
## SVN revision of a patch build
###################################################################
class rPATCHSVNREV_class(object):
    def __init__(self, address):
        self.interface = 'ramV'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x93, value)
        return(value)


###################################################################
## RAM CONFIG ID
###################################################################
class rCONFIGID_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x94, value)
        return(value)


###################################################################
## 
###################################################################
class rFILTERWAIT_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x95, value)
        return(value)


###################################################################
## Channel 0 Temperature Coefficients A
###################################################################
class rTC0A_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x96, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC0A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x96, None)
            self.tempCoA = (self.reg_value >> 16) & 0xFFFF
            self.tempCoB = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC0A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoA & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.tempCoB & 0xFFFF)
        dma(self.address, 0x96, reg)
    ## tempCo A
    def tempCoA(self, value = None):
        value = dma_bits(0x96, self.address, 16, 16, value)
        return(value)
    ## tempCo B
    def tempCoB(self, value = None):
        value = dma_bits(0x96, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel 0 Temperature Coefficients B
###################################################################
class rTC0B_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x97, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC0B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x97, None)
            self.tempCoC = (self.reg_value >> 16) & 0xFFFF
            self.refTemp = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC0B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoC & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.refTemp & 0xFFFF)
        dma(self.address, 0x97, reg)
    ## tempCo C
    def tempCoC(self, value = None):
        value = dma_bits(0x97, self.address, 16, 16, value)
        return(value)
    ## tempCo reference temperature
    def refTemp(self, value = None):
        value = dma_bits(0x97, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel 1 Temperature Coefficients A
###################################################################
class rTC1A_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x98, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC1A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x98, None)
            self.tempCoA = (self.reg_value >> 16) & 0xFFFF
            self.tempCoB = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC1A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoA & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.tempCoB & 0xFFFF)
        dma(self.address, 0x98, reg)
    ## tempCo A
    def tempCoA(self, value = None):
        value = dma_bits(0x98, self.address, 16, 16, value)
        return(value)
    ## tempCo B
    def tempCoB(self, value = None):
        value = dma_bits(0x98, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel 1 Temperature Coefficients B
###################################################################
class rTC1B_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x99, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC1B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x99, None)
            self.tempCoC = (self.reg_value >> 16) & 0xFFFF
            self.refTemp = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC1B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoC & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.refTemp & 0xFFFF)
        dma(self.address, 0x99, reg)
    ## tempCo C
    def tempCoC(self, value = None):
        value = dma_bits(0x99, self.address, 16, 16, value)
        return(value)
    ## tempCo reference temperature
    def refTemp(self, value = None):
        value = dma_bits(0x99, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel 2 Temperature Coefficients A
###################################################################
class rTC2A_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9A, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC2A_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9A, None)
            self.tempCoA = (self.reg_value >> 16) & 0xFFFF
            self.tempCoB = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC2A_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoA & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.tempCoB & 0xFFFF)
        dma(self.address, 0x9A, reg)
    ## tempCo A
    def tempCoA(self, value = None):
        value = dma_bits(0x9A, self.address, 16, 16, value)
        return(value)
    ## tempCo B
    def tempCoB(self, value = None):
        value = dma_bits(0x9A, self.address, 16, 0, value)
        return(value)

###################################################################
## Channel 2 Temperature Coefficients B
###################################################################
class rTC2B_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9B, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTC2B_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9B, None)
            self.tempCoC = (self.reg_value >> 16) & 0xFFFF
            self.refTemp = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTC2B_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoC & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.refTemp & 0xFFFF)
        dma(self.address, 0x9B, reg)
    ## tempCo C
    def tempCoC(self, value = None):
        value = dma_bits(0x9B, self.address, 16, 16, value)
        return(value)
    ## tempCo reference temperature
    def refTemp(self, value = None):
        value = dma_bits(0x9B, self.address, 16, 0, value)
        return(value)

###################################################################
## Temperature thresholds for updating isense tempCo
###################################################################
class rTCTHRESH_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9C, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTCTHRESH_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9C, None)
            self.reserved1 = (self.reg_value >> 24) & 0xFF
            self.tempCoThresh2 = (self.reg_value >> 16) & 0xFF
            self.tempCoThresh1 = (self.reg_value >> 8) & 0xFF
            self.tempCoThresh0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rTCTHRESH_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.reserved1 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.tempCoThresh2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.tempCoThresh1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.tempCoThresh0 & 0xFF)
        dma(self.address, 0x9C, reg)
    ## Reserved
    def reserved1(self, value = None):
        value = dma_bits(0x9C, self.address, 8, 24, value)
        return(value)
    ## CH2 Temperature threshold for updating isense tempCo
    def tempCoThresh2(self, value = None):
        value = dma_bits(0x9C, self.address, 8, 16, value)
        return(value)
    ## CH1 Temperature threshold for updating isense tempCo
    def tempCoThresh1(self, value = None):
        value = dma_bits(0x9C, self.address, 8, 8, value)
        return(value)
    ## CH0 Temperature threshold for updating isense tempCo
    def tempCoThresh0(self, value = None):
        value = dma_bits(0x9C, self.address, 8, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rUSRSYSFULLPWR0_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9D, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSRSYSFULLPWR0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9D, None)
            self.reserved = (self.reg_value >> 3) & 0x1FFFFFFF
            self.useIntVin0DivHV = (self.reg_value >> 2) & 0x1
            self.useExtVin0DivHV = (self.reg_value >> 1) & 0x1
            self.useExtVin0DivLV = self.reg_value & 0x1

    def read_object(self):
        return(self.rUSRSYSFULLPWR0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7) + ((register_object.reserved & 0x1FFFFFFF) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.useIntVin0DivHV & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useExtVin0DivHV & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.useExtVin0DivLV & 0x1)
        dma(self.address, 0x9D, reg)
    ## Reserved.
    def reserved(self, value = None):
        value = dma_bits(0x9D, self.address, 29, 3, value)
        return(value)
    ## SELVINIINTREF Use Internal Divided HV Vin0 Sensor
    def useIntVin0DivHV(self, value = None):
        value = dma_bits(0x9D, self.address, 1, 2, value)
        return(value)
    ## SELVINIINTREF Use External Divided HV Vin0 Sensor
    def useExtVin0DivHV(self, value = None):
        value = dma_bits(0x9D, self.address, 1, 1, value)
        return(value)
    ## SELVINIINTREF Use External Divided LV Vin0 Sensor
    def useExtVin0DivLV(self, value = None):
        value = dma_bits(0x9D, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM GUI saved params channel 0
###################################################################
class rGUI1_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9E, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rGUI1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9E, None)
            self.eslBulk0 = (self.reg_value >> 28) & 0x7
            self.esrCer0 = (self.reg_value >> 25) & 0x7
            self.esrBulk0 = (self.reg_value >> 22) & 0x7
            self.cCer0 = (self.reg_value >> 18) & 0xF
            self.cBulk0 = (self.reg_value >> 12) & 0x3F
            self.nCer0 = (self.reg_value >> 6) & 0x3F
            self.nBulk0 = (self.reg_value >> 2) & 0xF
            self.useDoubler0 = (self.reg_value >> 1) & 0x1
            self.useSps0 = self.reg_value & 0x1

    def read_object(self):
        return(self.rGUI1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x8FFFFFFF) + ((register_object.eslBulk0 & 0x7) << 28)
        reg = (reg & 0xF1FFFFFF) + ((register_object.esrCer0 & 0x7) << 25)
        reg = (reg & 0xFE3FFFFF) + ((register_object.esrBulk0 & 0x7) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.cCer0 & 0xF) << 18)
        reg = (reg & 0xFFFC0FFF) + ((register_object.cBulk0 & 0x3F) << 12)
        reg = (reg & 0xFFFFF03F) + ((register_object.nCer0 & 0x3F) << 6)
        reg = (reg & 0xFFFFFFC3) + ((register_object.nBulk0 & 0xF) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useDoubler0 & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.useSps0 & 0x1)
        dma(self.address, 0x9E, reg)
    ## Bulk cap ESL in nanohenries
    def eslBulk0(self, value = None):
        value = dma_bits(0x9E, self.address, 3, 28, value)
        return(value)
    ## Ceramic cap ESR in milliohms
    def esrCer0(self, value = None):
        value = dma_bits(0x9E, self.address, 3, 25, value)
        return(value)
    ## Bulk cap ESR in milliohms
    def esrBulk0(self, value = None):
        value = dma_bits(0x9E, self.address, 3, 22, value)
        return(value)
    ## Ceramic cap effective value in 8*microfarads
    def cCer0(self, value = None):
        value = dma_bits(0x9E, self.address, 4, 18, value)
        return(value)
    ## Bulk cap effective value in 16*microfarads
    def cBulk0(self, value = None):
        value = dma_bits(0x9E, self.address, 6, 12, value)
        return(value)
    ## Number of ceramic capacitors (or equiv count)
    def nCer0(self, value = None):
        value = dma_bits(0x9E, self.address, 6, 6, value)
        return(value)
    ## Number of bulk capacitors
    def nBulk0(self, value = None):
        value = dma_bits(0x9E, self.address, 4, 2, value)
        return(value)
    ## Use phase doublers if 1
    def useDoubler0(self, value = None):
        value = dma_bits(0x9E, self.address, 1, 1, value)
        return(value)
    ## Use SPS if 1
    def useSps0(self, value = None):
        value = dma_bits(0x9E, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM GUI saved params channel 1
###################################################################
class rGUI2_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0x9F, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rGUI2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0x9F, None)
            self.eslBulk1 = (self.reg_value >> 28) & 0x7
            self.esrCer1 = (self.reg_value >> 25) & 0x7
            self.esrBulk1 = (self.reg_value >> 22) & 0x7
            self.cCer1 = (self.reg_value >> 18) & 0xF
            self.cBulk1 = (self.reg_value >> 12) & 0x3F
            self.nCer1 = (self.reg_value >> 6) & 0x3F
            self.nBulk1 = (self.reg_value >> 2) & 0xF
            self.useDoubler1 = (self.reg_value >> 1) & 0x1
            self.useSps1 = self.reg_value & 0x1

    def read_object(self):
        return(self.rGUI2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x8FFFFFFF) + ((register_object.eslBulk1 & 0x7) << 28)
        reg = (reg & 0xF1FFFFFF) + ((register_object.esrCer1 & 0x7) << 25)
        reg = (reg & 0xFE3FFFFF) + ((register_object.esrBulk1 & 0x7) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.cCer1 & 0xF) << 18)
        reg = (reg & 0xFFFC0FFF) + ((register_object.cBulk1 & 0x3F) << 12)
        reg = (reg & 0xFFFFF03F) + ((register_object.nCer1 & 0x3F) << 6)
        reg = (reg & 0xFFFFFFC3) + ((register_object.nBulk1 & 0xF) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useDoubler1 & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.useSps1 & 0x1)
        dma(self.address, 0x9F, reg)
    ## Bulk cap ESL in nanohenries
    def eslBulk1(self, value = None):
        value = dma_bits(0x9F, self.address, 3, 28, value)
        return(value)
    ## Ceramic cap ESR in milliohms
    def esrCer1(self, value = None):
        value = dma_bits(0x9F, self.address, 3, 25, value)
        return(value)
    ## Bulk cap ESR in milliohms
    def esrBulk1(self, value = None):
        value = dma_bits(0x9F, self.address, 3, 22, value)
        return(value)
    ## Ceramic cap effective value in 8*microfarads
    def cCer1(self, value = None):
        value = dma_bits(0x9F, self.address, 4, 18, value)
        return(value)
    ## Bulk cap effective value in 16*microfarads
    def cBulk1(self, value = None):
        value = dma_bits(0x9F, self.address, 6, 12, value)
        return(value)
    ## Number of ceramic capacitors (or equiv count)
    def nCer1(self, value = None):
        value = dma_bits(0x9F, self.address, 6, 6, value)
        return(value)
    ## Number of bulk capacitors
    def nBulk1(self, value = None):
        value = dma_bits(0x9F, self.address, 4, 2, value)
        return(value)
    ## Use phase doublers if 1
    def useDoubler1(self, value = None):
        value = dma_bits(0x9F, self.address, 1, 1, value)
        return(value)
    ## Use SPS if 1
    def useSps1(self, value = None):
        value = dma_bits(0x9F, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM GUI saved params channel 2
###################################################################
class rGUI3_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rGUI3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA0, None)
            self.eslBulk2 = (self.reg_value >> 28) & 0x7
            self.esrCer2 = (self.reg_value >> 25) & 0x7
            self.esrBulk2 = (self.reg_value >> 22) & 0x7
            self.cCer2 = (self.reg_value >> 18) & 0xF
            self.cBulk2 = (self.reg_value >> 12) & 0x3F
            self.nCer2 = (self.reg_value >> 6) & 0x3F
            self.nBulk2 = (self.reg_value >> 2) & 0xF
            self.useDoubler2 = (self.reg_value >> 1) & 0x1
            self.useSps2 = self.reg_value & 0x1

    def read_object(self):
        return(self.rGUI3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x8FFFFFFF) + ((register_object.eslBulk2 & 0x7) << 28)
        reg = (reg & 0xF1FFFFFF) + ((register_object.esrCer2 & 0x7) << 25)
        reg = (reg & 0xFE3FFFFF) + ((register_object.esrBulk2 & 0x7) << 22)
        reg = (reg & 0xFFC3FFFF) + ((register_object.cCer2 & 0xF) << 18)
        reg = (reg & 0xFFFC0FFF) + ((register_object.cBulk2 & 0x3F) << 12)
        reg = (reg & 0xFFFFF03F) + ((register_object.nCer2 & 0x3F) << 6)
        reg = (reg & 0xFFFFFFC3) + ((register_object.nBulk2 & 0xF) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.useDoubler2 & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.useSps2 & 0x1)
        dma(self.address, 0xA0, reg)
    ## Bulk cap ESL in nanohenries
    def eslBulk2(self, value = None):
        value = dma_bits(0xA0, self.address, 3, 28, value)
        return(value)
    ## Ceramic cap ESR in milliohms
    def esrCer2(self, value = None):
        value = dma_bits(0xA0, self.address, 3, 25, value)
        return(value)
    ## Bulk cap ESR in milliohms
    def esrBulk2(self, value = None):
        value = dma_bits(0xA0, self.address, 3, 22, value)
        return(value)
    ## Ceramic cap effective value in 8*microfarads
    def cCer2(self, value = None):
        value = dma_bits(0xA0, self.address, 4, 18, value)
        return(value)
    ## Bulk cap effective value in 16*microfarads
    def cBulk2(self, value = None):
        value = dma_bits(0xA0, self.address, 6, 12, value)
        return(value)
    ## Number of ceramic capacitors (or equiv count)
    def nCer2(self, value = None):
        value = dma_bits(0xA0, self.address, 6, 6, value)
        return(value)
    ## Number of bulk capacitors
    def nBulk2(self, value = None):
        value = dma_bits(0xA0, self.address, 4, 2, value)
        return(value)
    ## Use phase doublers if 1
    def useDoubler2(self, value = None):
        value = dma_bits(0xA0, self.address, 1, 1, value)
        return(value)
    ## Use SPS if 1
    def useSps2(self, value = None):
        value = dma_bits(0xA0, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM GUI Storage Register 4
###################################################################
class rGUI4_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA1, value)
        return(value)


###################################################################
## RAM GUI Storage Register 5
###################################################################
class rGUI5_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA2, value)
        return(value)


###################################################################
## 
###################################################################
class rTEMPTELCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTEMPTELCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA3, None)
            self.hysteresis = (self.reg_value >> 19) & 0x1F
            self.nvDimmEn = (self.reg_value >> 18) & 0x1
            self.isenTempCoEn = (self.reg_value >> 17) & 0x1
            self.ctlOtfLimit = (self.reg_value >> 9) & 0xFF
            self.tempRail2 = (self.reg_value >> 6) & 0x7
            self.tempRail1 = (self.reg_value >> 3) & 0x7
            self.tempRail0 = self.reg_value & 0x7

    def read_object(self):
        return(self.rTEMPTELCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF07FFFF) + ((register_object.hysteresis & 0x1F) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.nvDimmEn & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.isenTempCoEn & 0x1) << 17)
        reg = (reg & 0xFFFE01FF) + ((register_object.ctlOtfLimit & 0xFF) << 9)
        reg = (reg & 0xFFFFFE3F) + ((register_object.tempRail2 & 0x7) << 6)
        reg = (reg & 0xFFFFFFC7) + ((register_object.tempRail1 & 0x7) << 3)
        reg = (reg & 0xFFFFFFF8) + (register_object.tempRail0 & 0x7)
        dma(self.address, 0xA3, reg)
    ## Temperature fault hysteresis threshold.
    def hysteresis(self, value = None):
        value = dma_bits(0xA3, self.address, 5, 19, value)
        return(value)
    ## SVID IIN measurments are in NV-DIMM mode.
    def nvDimmEn(self, value = None):
        value = dma_bits(0xA3, self.address, 1, 18, value)
        return(value)
    ## Enable ISEN DCR/SPS tempCo.
    def isenTempCoEn(self, value = None):
        value = dma_bits(0xA3, self.address, 1, 17, value)
        return(value)
    ## Internal over temperature fault limit.
    def ctlOtfLimit(self, value = None):
        value = dma_bits(0xA3, self.address, 8, 9, value)
        return(value)
    ## Configure firmware measurment of Rail/Pin 2 temperature: none, TMON, NTC (n/a), phase SPS (n/a), phase SPS+NTC (n/a), or SDIF TMON.
    def tempRail2(self, value = None):
        value = dma_bits(0xA3, self.address, 3, 6, value)
        return(value)
    ## Configure firmware measurment of Rail/Pin 1 temperature: none, TMON, NTC (n/a), phase SPS (n/a), phase SPS+NTC (n/a), or SDIF TMON.
    def tempRail1(self, value = None):
        value = dma_bits(0xA3, self.address, 3, 3, value)
        return(value)
    ## Configure firmware measurment of Rail/Pin 0 temperature: none, TMON, NTC (n/a), phase SPS (n/a), phase SPS+NTC (n/a), or SDIF TMON.
    def tempRail0(self, value = None):
        value = dma_bits(0xA3, self.address, 3, 0, value)
        return(value)

###################################################################
## General User Configurations
###################################################################
class rUSRCONFIG_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSRCONFIG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA4, None)
            self.vsenInvTimeout = (self.reg_value >> 25) & 0x7F
            self.vsenInvUpdateEn = (self.reg_value >> 24) & 0x1
            self.manual = (self.reg_value >> 23) & 0x1
            self.testData = (self.reg_value >> 22) & 0x1
            self.tsCfgSel = (self.reg_value >> 21) & 0x1
            self.tsAddrSel = (self.reg_value >> 20) & 0x1
            self.utcIntEn = (self.reg_value >> 19) & 0x1
            self.int50us = (self.reg_value >> 18) & 0x1
            self.vddmonFilt = (self.reg_value >> 17) & 0x1
            self.priSlotCfgOnly = (self.reg_value >> 16) & 0x1
            self.reserved0 = (self.reg_value >> 10) & 0x3F
            self.smbus2 = (self.reg_value >> 9) & 0x1
            self.bbWarnEn = (self.reg_value >> 8) & 0x1
            self.ssWarnEn = (self.reg_value >> 7) & 0x1
            self.svidLogEn = (self.reg_value >> 5) & 0x1
            self.iinsenAmpPolarity = (self.reg_value >> 4) & 0x1
            self.bbEnPOR = (self.reg_value >> 2) & 0x1
            self.bbEn = (self.reg_value >> 1) & 0x1
            self.ssEn = self.reg_value & 0x1

    def read_object(self):
        return(self.rUSRCONFIG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x1FFFFFF) + ((register_object.vsenInvTimeout & 0x7F) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.vsenInvUpdateEn & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.manual & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.testData & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.tsCfgSel & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.tsAddrSel & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.utcIntEn & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.int50us & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.vddmonFilt & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.priSlotCfgOnly & 0x1) << 16)
        reg = (reg & 0xFFFF03FF) + ((register_object.reserved0 & 0x3F) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.smbus2 & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.bbWarnEn & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.ssWarnEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFDF) + ((register_object.svidLogEn & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.iinsenAmpPolarity & 0x1) << 4)
        reg = (reg & 0xFFFFFFFB) + ((register_object.bbEnPOR & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.bbEn & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.ssEn & 0x1)
        dma(self.address, 0xA4, reg)
    ## Timeout for inv mode on
    def vsenInvTimeout(self, value = None):
        value = dma_bits(0xA4, self.address, 7, 25, value)
        return(value)
    ## Enable algorthm that DCM mode vsen drift
    def vsenInvUpdateEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 24, value)
        return(value)
    ## UTCMGR Temperature sense control 0=auto 1=bit-bang
    def manual(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 23, value)
        return(value)
    ## UTCMGR Enable utility ADC test data write when 1
    def testData(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 22, value)
        return(value)
    ## UTCMGR Manual activate CONFIGSEL pin bias 0=none 1=100ua
    def tsCfgSel(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 21, value)
        return(value)
    ## UTCMGR Manual activate ADDRESS pin bias: 0=none 1=100ua
    def tsAddrSel(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 20, value)
        return(value)
    ## UTCMGR UTC interrupt enable: 0=none 1=active
    def utcIntEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 19, value)
        return(value)
    ## UTCMGR Enable 50us interrupt
    def int50us(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 18, value)
        return(value)
    ## UTCMGR VDDMON detector source data: 0 - raw, 1 - average
    def vddmonFilt(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 17, value)
        return(value)
    ## UTCMGR If set, this bit makes the only config to the tel ADC the primary slots config
    def priSlotCfgOnly(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 16, value)
        return(value)
    ## Reserved
    def reserved0(self, value = None):
        value = dma_bits(0xA4, self.address, 6, 10, value)
        return(value)
    ## User Configuration for SLAVEADDR[0]: smbus2
    def smbus2(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 9, value)
        return(value)
    ## Enable writing Black Box to OTP on warnings, MUST also set ssWarnEn.
    def bbWarnEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 8, value)
        return(value)
    ## Enable writing Snap Shot to RAM on warnings.<br>By default, warnings will NOT trigger Snap Shot
    def ssWarnEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 7, value)
        return(value)
    ## Svid Logger Enable
    def svidLogEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 5, value)
        return(value)
    ## User configuration for BASECFG [21]: iinsenAmpPolarity [Deprecated]
    def iinsenAmpPolarity(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 4, value)
        return(value)
    ## Enable writing Black Box data to OTP once per POR
    def bbEnPOR(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 2, value)
        return(value)
    ## Enable writing Black Box data to OTP
    def bbEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 1, value)
        return(value)
    ## Snap Shot Enable
    def ssEn(self, value = None):
        value = dma_bits(0xA4, self.address, 1, 0, value)
        return(value)

###################################################################
## SDIF general purpose config register.
###################################################################
class rSDIFUSERCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFUSERCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA5, None)
            self.owlRevDEn = (self.reg_value >> 29) & 0x1
            self.owlBrownoutRecoverEn = (self.reg_value >> 27) & 0x1
            self.sdifAzVccGuess = (self.reg_value >> 11) & 0xFFFF
            self.sdifRdsOnEn = (self.reg_value >> 10) & 0x1
            self.sdifAzMode = (self.reg_value >> 6) & 0xF
            self.sdifTimerPeriod = (self.reg_value >> 1) & 0x1F
            self.sdifAutoSpread = self.reg_value & 0x1

    def read_object(self):
        return(self.rSDIFUSERCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xDFFFFFFF) + ((register_object.owlRevDEn & 0x1) << 29)
        reg = (reg & 0xF7FFFFFF) + ((register_object.owlBrownoutRecoverEn & 0x1) << 27)
        reg = (reg & 0xF80007FF) + ((register_object.sdifAzVccGuess & 0xFFFF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.sdifRdsOnEn & 0x1) << 10)
        reg = (reg & 0xFFFFFC3F) + ((register_object.sdifAzMode & 0xF) << 6)
        reg = (reg & 0xFFFFFFC1) + ((register_object.sdifTimerPeriod & 0x1F) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.sdifAutoSpread & 0x1)
        dma(self.address, 0xA5, reg)
    ## Enable Owl Rev D compatibility.
    def owlRevDEn(self, value = None):
        value = dma_bits(0xA5, self.address, 1, 29, value)
        return(value)
    ## Enable recovery of Owls that lose their address.
    def owlBrownoutRecoverEn(self, value = None):
        value = dma_bits(0xA5, self.address, 1, 27, value)
        return(value)
    ## Guess at SPS voltage measurement in codes.
    def sdifAzVccGuess(self, value = None):
        value = dma_bits(0xA5, self.address, 16, 11, value)
        return(value)
    ## Enable rdson updates on rails using Owl SDIF SPS devices.
    def sdifRdsOnEn(self, value = None):
        value = dma_bits(0xA5, self.address, 1, 10, value)
        return(value)
    ## SPS Autozero modes: 0=None, 1=global, 2=global+periodic, 3=global->isenOffset, 4=periodic only.
    def sdifAzMode(self, value = None):
        value = dma_bits(0xA5, self.address, 4, 6, value)
        return(value)
    ## Time period between SDIF temp reads = sdifTimerPeriod * 10 + 20 us.
    def sdifTimerPeriod(self, value = None):
        value = dma_bits(0xA5, self.address, 5, 1, value)
        return(value)
    ## Automatically spread active phase SDIF temp readings based on (8+1)*timerPeriod when fewer than 8 phases are used.
    def sdifAutoSpread(self, value = None):
        value = dma_bits(0xA5, self.address, 1, 0, value)
        return(value)

###################################################################
## UTCPSSA Utility Primary Slot Select A
###################################################################
class rUTCPSSAUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCPSSAUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA6, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCPSSAUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xA6, reg)
    ## UTCPSSA Primary Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xA6, self.address, 8, 24, value)
        return(value)
    ## UTCPSSA Primary Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xA6, self.address, 8, 16, value)
        return(value)
    ## UTCPSSA Primary Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xA6, self.address, 8, 8, value)
        return(value)
    ## UTCPSSA Primary Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xA6, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCPSSB user Utility Primary Slot Select B
###################################################################
class rUTCPSSBUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCPSSBUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA7, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCPSSBUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xA7, reg)
    ## UTCPSSB Primary Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xA7, self.address, 8, 24, value)
        return(value)
    ## UTCPSSB Primary Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xA7, self.address, 8, 16, value)
        return(value)
    ## UTCPSSB Primary Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xA7, self.address, 8, 8, value)
        return(value)
    ## UTCPSSB Primary Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xA7, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS1A user Utility Alternate 1 Slot Select A
###################################################################
class rUTCASS1AUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS1AUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA8, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS1AUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xA8, reg)
    ## UTCASS1A Alternate Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xA8, self.address, 8, 24, value)
        return(value)
    ## UTCASS1A Alternate Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xA8, self.address, 8, 16, value)
        return(value)
    ## UTCASS1A Alternate Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xA8, self.address, 8, 8, value)
        return(value)
    ## UTCASS1A Alternate Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xA8, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS1B user Utility Alternate 1 Slot Select B
###################################################################
class rUTCASS1BUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xA9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS1BUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xA9, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS1BUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xA9, reg)
    ## UTCASS1B Alternate Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xA9, self.address, 8, 24, value)
        return(value)
    ## UTCASS1B Alternate Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xA9, self.address, 8, 16, value)
        return(value)
    ## UTCASS1B Alternate Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xA9, self.address, 8, 8, value)
        return(value)
    ## UTCASS1B Alternate Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xA9, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS2A user Utility Alternate 2 Slot Select A
###################################################################
class rUTCASS2AUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS2AUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAA, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS2AUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xAA, reg)
    ## UTCASS2A Alternate 2 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xAA, self.address, 8, 24, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xAA, self.address, 8, 16, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xAA, self.address, 8, 8, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xAA, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS2B user Utility Alternate 2 Slot Select B
###################################################################
class rUTCASS2BUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS2BUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAB, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS2BUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xAB, reg)
    ## UTCASS2B Alternate 2 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xAB, self.address, 8, 24, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xAB, self.address, 8, 16, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xAB, self.address, 8, 8, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xAB, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCESS user Utility External Slot Select
###################################################################
class rUTCESSUSER_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCESSUSER_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAC, None)
            self.slot7 = (self.reg_value >> 28) & 0xF
            self.slot6 = (self.reg_value >> 24) & 0xF
            self.slot5 = (self.reg_value >> 20) & 0xF
            self.slot4 = (self.reg_value >> 16) & 0xF
            self.slot3 = (self.reg_value >> 12) & 0xF
            self.slot2 = (self.reg_value >> 8) & 0xF
            self.slot1 = (self.reg_value >> 4) & 0xF
            self.slot0 = self.reg_value & 0xF

    def read_object(self):
        return(self.rUTCESSUSER_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.slot7 & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.slot6 & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.slot5 & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.slot4 & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.slot3 & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.slot2 & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.slot1 & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.slot0 & 0xF)
        dma(self.address, 0xAC, reg)
    ## UTCESS External Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 28, value)
        return(value)
    ## UTCESS External Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 24, value)
        return(value)
    ## UTCESS External Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 20, value)
        return(value)
    ## UTCESS External Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 16, value)
        return(value)
    ## UTCESS External Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 12, value)
        return(value)
    ## UTCESS External Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 8, value)
        return(value)
    ## UTCESS External Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 4, value)
        return(value)
    ## UTCESS External Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xAC, self.address, 4, 0, value)
        return(value)

###################################################################
## UTCPSSA Utility Primary Slot Select A -- Slow/Low Power
###################################################################
class rUTCPSSASLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCPSSASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAD, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCPSSASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xAD, reg)
    ## UTCPSSA Primary Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xAD, self.address, 8, 24, value)
        return(value)
    ## UTCPSSA Primary Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xAD, self.address, 8, 16, value)
        return(value)
    ## UTCPSSA Primary Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xAD, self.address, 8, 8, value)
        return(value)
    ## UTCPSSA Primary Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xAD, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCPSSB SLOW Utility Primary Slot Select B -- Slow/Low Power
###################################################################
class rUTCPSSBSLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCPSSBSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAE, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCPSSBSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xAE, reg)
    ## UTCPSSB Primary Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xAE, self.address, 8, 24, value)
        return(value)
    ## UTCPSSB Primary Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xAE, self.address, 8, 16, value)
        return(value)
    ## UTCPSSB Primary Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xAE, self.address, 8, 8, value)
        return(value)
    ## UTCPSSB Primary Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xAE, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS1A SLOW Utility Alternate 1 Slot Select A -- Slow/Low Power
###################################################################
class rUTCASS1ASLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xAF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS1ASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xAF, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS1ASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xAF, reg)
    ## UTCASS1A Alternate Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xAF, self.address, 8, 24, value)
        return(value)
    ## UTCASS1A Alternate Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xAF, self.address, 8, 16, value)
        return(value)
    ## UTCASS1A Alternate Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xAF, self.address, 8, 8, value)
        return(value)
    ## UTCASS1A Alternate Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xAF, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS1B SLOW Utility Alternate 1 Slot Select B -- Slow/Low Power
###################################################################
class rUTCASS1BSLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS1BSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB0, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS1BSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xB0, reg)
    ## UTCASS1B Alternate Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xB0, self.address, 8, 24, value)
        return(value)
    ## UTCASS1B Alternate Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xB0, self.address, 8, 16, value)
        return(value)
    ## UTCASS1B Alternate Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xB0, self.address, 8, 8, value)
        return(value)
    ## UTCASS1B Alternate Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xB0, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS2A SLOW Utility Alternate 2 Slot Select A -- Slow/Low Power
###################################################################
class rUTCASS2ASLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS2ASLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB1, None)
            self.slot3 = (self.reg_value >> 24) & 0xFF
            self.slot2 = (self.reg_value >> 16) & 0xFF
            self.slot1 = (self.reg_value >> 8) & 0xFF
            self.slot0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS2ASLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot0 & 0xFF)
        dma(self.address, 0xB1, reg)
    ## UTCASS2A Alternate 2 Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xB1, self.address, 8, 24, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xB1, self.address, 8, 16, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xB1, self.address, 8, 8, value)
        return(value)
    ## UTCASS2A Alternate 2 Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xB1, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCASS2B SLOW Utility Alternate 2 Slot Select B -- Slow/Low Power
###################################################################
class rUTCASS2BSLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCASS2BSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB2, None)
            self.slot7 = (self.reg_value >> 24) & 0xFF
            self.slot6 = (self.reg_value >> 16) & 0xFF
            self.slot5 = (self.reg_value >> 8) & 0xFF
            self.slot4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUTCASS2BSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.slot7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.slot6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.slot5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.slot4 & 0xFF)
        dma(self.address, 0xB2, reg)
    ## UTCASS2B Alternate 2 Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xB2, self.address, 8, 24, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xB2, self.address, 8, 16, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xB2, self.address, 8, 8, value)
        return(value)
    ## UTCASS2B Alternate 2 Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xB2, self.address, 8, 0, value)
        return(value)

###################################################################
## UTCESS SLOW Utility External Slot Select -- Slow/Low Power
###################################################################
class rUTCESSSLOW_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUTCESSSLOW_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB3, None)
            self.slot7 = (self.reg_value >> 28) & 0xF
            self.slot6 = (self.reg_value >> 24) & 0xF
            self.slot5 = (self.reg_value >> 20) & 0xF
            self.slot4 = (self.reg_value >> 16) & 0xF
            self.slot3 = (self.reg_value >> 12) & 0xF
            self.slot2 = (self.reg_value >> 8) & 0xF
            self.slot1 = (self.reg_value >> 4) & 0xF
            self.slot0 = self.reg_value & 0xF

    def read_object(self):
        return(self.rUTCESSSLOW_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.slot7 & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.slot6 & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.slot5 & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.slot4 & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.slot3 & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.slot2 & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.slot1 & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.slot0 & 0xF)
        dma(self.address, 0xB3, reg)
    ## UTCESS External Slot 7
    def slot7(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 28, value)
        return(value)
    ## UTCESS External Slot 6
    def slot6(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 24, value)
        return(value)
    ## UTCESS External Slot 5
    def slot5(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 20, value)
        return(value)
    ## UTCESS External Slot 4
    def slot4(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 16, value)
        return(value)
    ## UTCESS External Slot 3
    def slot3(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 12, value)
        return(value)
    ## UTCESS External Slot 2
    def slot2(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 8, value)
        return(value)
    ## UTCESS External Slot 1
    def slot1(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 4, value)
        return(value)
    ## UTCESS External Slot 0
    def slot0(self, value = None):
        value = dma_bits(0xB3, self.address, 4, 0, value)
        return(value)

###################################################################
## User configuration value for VINSEN0 and IINSEN0.
###################################################################
class rVIinSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVIinSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB4, None)
            self.iinrsvd = (self.reg_value >> 31) & 0x1
            self.iinAdcOff = (self.reg_value >> 27) & 0xF
            self.iinAZdis = (self.reg_value >> 26) & 0x1
            self.iinLCnvt = (self.reg_value >> 25) & 0x1
            self.iinPdnShft = (self.reg_value >> 23) & 0x3
            self.iinSampShft = (self.reg_value >> 20) & 0x7
            self.iinSampVal = (self.reg_value >> 16) & 0xF
            self.vinrsvd = (self.reg_value >> 15) & 0x1
            self.vinAdcOff = (self.reg_value >> 11) & 0xF
            self.vinAZdis = (self.reg_value >> 10) & 0x1
            self.vinLCnvt = (self.reg_value >> 9) & 0x1
            self.vinSampPdnShft = (self.reg_value >> 7) & 0x3
            self.vinSampShft = (self.reg_value >> 4) & 0x7
            self.vinSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.rVIinSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.iinrsvd & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.iinAdcOff & 0xF) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.iinAZdis & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.iinLCnvt & 0x1) << 25)
        reg = (reg & 0xFE7FFFFF) + ((register_object.iinPdnShft & 0x3) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.iinSampShft & 0x7) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.iinSampVal & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.vinrsvd & 0x1) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.vinAdcOff & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.vinAZdis & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vinLCnvt & 0x1) << 9)
        reg = (reg & 0xFFFFFE7F) + ((register_object.vinSampPdnShft & 0x3) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.vinSampShft & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.vinSampVal & 0xF)
        dma(self.address, 0xB4, reg)
    ## reserved
    def iinrsvd(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 31, value)
        return(value)
    ## IINSEN0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def iinAdcOff(self, value = None):
        value = dma_bits(0xB4, self.address, 4, 27, value)
        return(value)
    ## IINSEN0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def iinAZdis(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 26, value)
        return(value)
    ## IINSEN0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def iinLCnvt(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 25, value)
        return(value)
    ## IINSEN0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def iinPdnShft(self, value = None):
        value = dma_bits(0xB4, self.address, 2, 23, value)
        return(value)
    ## IINSEN0 ADC sample acquisition count shift in clkSys*2
    def iinSampShft(self, value = None):
        value = dma_bits(0xB4, self.address, 3, 20, value)
        return(value)
    ## IINSEN0 ADC sample acquisition count value in clkSys*2
    def iinSampVal(self, value = None):
        value = dma_bits(0xB4, self.address, 4, 16, value)
        return(value)
    ## reserved
    def vinrsvd(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 15, value)
        return(value)
    ## VINSEN0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def vinAdcOff(self, value = None):
        value = dma_bits(0xB4, self.address, 4, 11, value)
        return(value)
    ## VINSEN0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def vinAZdis(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 10, value)
        return(value)
    ## VINSEN0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def vinLCnvt(self, value = None):
        value = dma_bits(0xB4, self.address, 1, 9, value)
        return(value)
    ## VINSEN0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def vinSampPdnShft(self, value = None):
        value = dma_bits(0xB4, self.address, 2, 7, value)
        return(value)
    ## VINSEN0 ADC sample acquisition count shift in clkSys*2
    def vinSampShft(self, value = None):
        value = dma_bits(0xB4, self.address, 3, 4, value)
        return(value)
    ## VINSEN0 ADC sample acquisition count value in clkSys*2
    def vinSampVal(self, value = None):
        value = dma_bits(0xB4, self.address, 4, 0, value)
        return(value)

###################################################################
## User configuration value for TEMP0 and TEMP1
###################################################################
class rTemp01SlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTemp01SlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB5, None)
            self.temp1rsvd = (self.reg_value >> 31) & 0x1
            self.temp1AdcOff = (self.reg_value >> 27) & 0xF
            self.temp1AZdis = (self.reg_value >> 26) & 0x1
            self.temp1LCnvt = (self.reg_value >> 25) & 0x1
            self.temp1PdnShft = (self.reg_value >> 23) & 0x3
            self.temp1SampShft = (self.reg_value >> 20) & 0x7
            self.temp1SampVal = (self.reg_value >> 16) & 0xF
            self.temp0rsvd = (self.reg_value >> 15) & 0x1
            self.temp0AdcOff = (self.reg_value >> 11) & 0xF
            self.temp0AZdis = (self.reg_value >> 10) & 0x1
            self.temp0LCnvt = (self.reg_value >> 9) & 0x1
            self.temp0SampPdnShft = (self.reg_value >> 7) & 0x3
            self.temp0SampShft = (self.reg_value >> 4) & 0x7
            self.temp0SampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.rTemp01SlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.temp1rsvd & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.temp1AdcOff & 0xF) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.temp1AZdis & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.temp1LCnvt & 0x1) << 25)
        reg = (reg & 0xFE7FFFFF) + ((register_object.temp1PdnShft & 0x3) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.temp1SampShft & 0x7) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.temp1SampVal & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.temp0rsvd & 0x1) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.temp0AdcOff & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.temp0AZdis & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.temp0LCnvt & 0x1) << 9)
        reg = (reg & 0xFFFFFE7F) + ((register_object.temp0SampPdnShft & 0x3) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.temp0SampShft & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.temp0SampVal & 0xF)
        dma(self.address, 0xB5, reg)
    ## reserved
    def temp1rsvd(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 31, value)
        return(value)
    ## TEMP1 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp1AdcOff(self, value = None):
        value = dma_bits(0xB5, self.address, 4, 27, value)
        return(value)
    ## TEMP1 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp1AZdis(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 26, value)
        return(value)
    ## TEMP1 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp1LCnvt(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 25, value)
        return(value)
    ## TEMP1 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp1PdnShft(self, value = None):
        value = dma_bits(0xB5, self.address, 2, 23, value)
        return(value)
    ## TEMP1 ADC sample acquisition count shift in clkSys*2
    def temp1SampShft(self, value = None):
        value = dma_bits(0xB5, self.address, 3, 20, value)
        return(value)
    ## TEMP1 ADC sample acquisition count value in clkSys*2
    def temp1SampVal(self, value = None):
        value = dma_bits(0xB5, self.address, 4, 16, value)
        return(value)
    ## reserved
    def temp0rsvd(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 15, value)
        return(value)
    ## TEMP0 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp0AdcOff(self, value = None):
        value = dma_bits(0xB5, self.address, 4, 11, value)
        return(value)
    ## TEMP0 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp0AZdis(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 10, value)
        return(value)
    ## TEMP0 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp0LCnvt(self, value = None):
        value = dma_bits(0xB5, self.address, 1, 9, value)
        return(value)
    ## TEMP0 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp0SampPdnShft(self, value = None):
        value = dma_bits(0xB5, self.address, 2, 7, value)
        return(value)
    ## TEMP0 ADC sample acquisition count shift in clkSys*2
    def temp0SampShft(self, value = None):
        value = dma_bits(0xB5, self.address, 3, 4, value)
        return(value)
    ## TEMP0 ADC sample acquisition count value in clkSys*2
    def temp0SampVal(self, value = None):
        value = dma_bits(0xB5, self.address, 4, 0, value)
        return(value)

###################################################################
## User configuration value for TEMP2 and Internal Temp
###################################################################
class rTemp2ISlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTemp2ISlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB6, None)
            self.intTemprsvd = (self.reg_value >> 31) & 0x1
            self.intTempAdcOff = (self.reg_value >> 27) & 0xF
            self.intTempAZdis = (self.reg_value >> 26) & 0x1
            self.intTempLCnvt = (self.reg_value >> 25) & 0x1
            self.intTempPdnShft = (self.reg_value >> 23) & 0x3
            self.intTempSampShft = (self.reg_value >> 20) & 0x7
            self.intTempSampVal = (self.reg_value >> 16) & 0xF
            self.temp2rsvd = (self.reg_value >> 15) & 0x1
            self.temp2AdcOff = (self.reg_value >> 11) & 0xF
            self.temp2AZdis = (self.reg_value >> 10) & 0x1
            self.temp2LCnvt = (self.reg_value >> 9) & 0x1
            self.temp2SampPdnShft = (self.reg_value >> 7) & 0x3
            self.temp2SampShft = (self.reg_value >> 4) & 0x7
            self.temp2SampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.rTemp2ISlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.intTemprsvd & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.intTempAdcOff & 0xF) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.intTempAZdis & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.intTempLCnvt & 0x1) << 25)
        reg = (reg & 0xFE7FFFFF) + ((register_object.intTempPdnShft & 0x3) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.intTempSampShft & 0x7) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.intTempSampVal & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.temp2rsvd & 0x1) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.temp2AdcOff & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.temp2AZdis & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.temp2LCnvt & 0x1) << 9)
        reg = (reg & 0xFFFFFE7F) + ((register_object.temp2SampPdnShft & 0x3) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.temp2SampShft & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.temp2SampVal & 0xF)
        dma(self.address, 0xB6, reg)
    ## reserved
    def intTemprsvd(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 31, value)
        return(value)
    ## Internal Temp ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def intTempAdcOff(self, value = None):
        value = dma_bits(0xB6, self.address, 4, 27, value)
        return(value)
    ## Internal Temp ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def intTempAZdis(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 26, value)
        return(value)
    ## Internal Temp ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def intTempLCnvt(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 25, value)
        return(value)
    ## Internal Temp ADC sample acquisition count additional shift if in pdn in clkSys*2
    def intTempPdnShft(self, value = None):
        value = dma_bits(0xB6, self.address, 2, 23, value)
        return(value)
    ## Internal Temp ADC sample acquisition count shift in clkSys*2
    def intTempSampShft(self, value = None):
        value = dma_bits(0xB6, self.address, 3, 20, value)
        return(value)
    ## Internal Temp ADC sample acquisition count value in clkSys*2
    def intTempSampVal(self, value = None):
        value = dma_bits(0xB6, self.address, 4, 16, value)
        return(value)
    ## reserved
    def temp2rsvd(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 15, value)
        return(value)
    ## TEMP2 ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def temp2AdcOff(self, value = None):
        value = dma_bits(0xB6, self.address, 4, 11, value)
        return(value)
    ## TEMP2 ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def temp2AZdis(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 10, value)
        return(value)
    ## TEMP2 ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def temp2LCnvt(self, value = None):
        value = dma_bits(0xB6, self.address, 1, 9, value)
        return(value)
    ## TEMP2 ADC sample acquisition count additional shift if in pdn in clkSys*2
    def temp2SampPdnShft(self, value = None):
        value = dma_bits(0xB6, self.address, 2, 7, value)
        return(value)
    ## TEMP2 ADC sample acquisition count shift in clkSys*2
    def temp2SampShft(self, value = None):
        value = dma_bits(0xB6, self.address, 3, 4, value)
        return(value)
    ## TEMP2 ADC sample acquisition count value in clkSys*2
    def temp2SampVal(self, value = None):
        value = dma_bits(0xB6, self.address, 4, 0, value)
        return(value)

###################################################################
## User configuration value for Internal voltage and External Addr/Config readers
###################################################################
class rVintExtSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVintExtSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB7, None)
            self.extrsvd = (self.reg_value >> 31) & 0x1
            self.extAdcOff = (self.reg_value >> 27) & 0xF
            self.extAZdis = (self.reg_value >> 26) & 0x1
            self.extLCnvt = (self.reg_value >> 25) & 0x1
            self.extPdnShft = (self.reg_value >> 23) & 0x3
            self.extSampShft = (self.reg_value >> 20) & 0x7
            self.extSampVal = (self.reg_value >> 16) & 0xF
            self.vIntrsvd = (self.reg_value >> 15) & 0x1
            self.vIntAdcOff = (self.reg_value >> 11) & 0xF
            self.vIntAZdis = (self.reg_value >> 10) & 0x1
            self.vIntLCnvt = (self.reg_value >> 9) & 0x1
            self.vIntSampPdnShft = (self.reg_value >> 7) & 0x3
            self.vIntSampShft = (self.reg_value >> 4) & 0x7
            self.vIntSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.rVintExtSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.extrsvd & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.extAdcOff & 0xF) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.extAZdis & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.extLCnvt & 0x1) << 25)
        reg = (reg & 0xFE7FFFFF) + ((register_object.extPdnShft & 0x3) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.extSampShft & 0x7) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.extSampVal & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.vIntrsvd & 0x1) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.vIntAdcOff & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.vIntAZdis & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vIntLCnvt & 0x1) << 9)
        reg = (reg & 0xFFFFFE7F) + ((register_object.vIntSampPdnShft & 0x3) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.vIntSampShft & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.vIntSampVal & 0xF)
        dma(self.address, 0xB7, reg)
    ## reserved
    def extrsvd(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 31, value)
        return(value)
    ## Address/Config ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def extAdcOff(self, value = None):
        value = dma_bits(0xB7, self.address, 4, 27, value)
        return(value)
    ## Address/Config ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def extAZdis(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 26, value)
        return(value)
    ## Address/Config ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def extLCnvt(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 25, value)
        return(value)
    ## Address/Config ADC sample acquisition count additional shift if in pdn in clkSys*2
    def extPdnShft(self, value = None):
        value = dma_bits(0xB7, self.address, 2, 23, value)
        return(value)
    ## Address/Config ADC sample acquisition count shift in clkSys*2
    def extSampShft(self, value = None):
        value = dma_bits(0xB7, self.address, 3, 20, value)
        return(value)
    ## Address/Config ADC sample acquisition count value in clkSys*2
    def extSampVal(self, value = None):
        value = dma_bits(0xB7, self.address, 4, 16, value)
        return(value)
    ## reserved
    def vIntrsvd(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 15, value)
        return(value)
    ## Internal voltages ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def vIntAdcOff(self, value = None):
        value = dma_bits(0xB7, self.address, 4, 11, value)
        return(value)
    ## Internal voltages ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def vIntAZdis(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 10, value)
        return(value)
    ## Internal voltages ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def vIntLCnvt(self, value = None):
        value = dma_bits(0xB7, self.address, 1, 9, value)
        return(value)
    ## Internal voltages ADC sample acquisition count additional shift if in pdn in clkSys*2
    def vIntSampPdnShft(self, value = None):
        value = dma_bits(0xB7, self.address, 2, 7, value)
        return(value)
    ## Internal voltages ADC sample acquisition count shift in clkSys*2
    def vIntSampShft(self, value = None):
        value = dma_bits(0xB7, self.address, 3, 4, value)
        return(value)
    ## Internal voltages ADC sample acquisition count value in clkSys*2
    def vIntSampVal(self, value = None):
        value = dma_bits(0xB7, self.address, 4, 0, value)
        return(value)

###################################################################
## User configuration value for AutoZero, slow AutoZero
###################################################################
class rAzSlotCfg_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rAzSlotCfg_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB8, None)
            self.azSlowrsvd = (self.reg_value >> 31) & 0x1
            self.azSlowAdcOff = (self.reg_value >> 27) & 0xF
            self.azSlowAZdis = (self.reg_value >> 26) & 0x1
            self.azSlowLCnvt = (self.reg_value >> 25) & 0x1
            self.azSlowPdnShft = (self.reg_value >> 23) & 0x3
            self.azSlowSampShft = (self.reg_value >> 20) & 0x7
            self.azSlowSampVal = (self.reg_value >> 16) & 0xF
            self.azrsvd = (self.reg_value >> 15) & 0x1
            self.azAdcOff = (self.reg_value >> 11) & 0xF
            self.azAZdis = (self.reg_value >> 10) & 0x1
            self.azLCnvt = (self.reg_value >> 9) & 0x1
            self.azSampPdnShft = (self.reg_value >> 7) & 0x3
            self.azSampShft = (self.reg_value >> 4) & 0x7
            self.azSampVal = self.reg_value & 0xF

    def read_object(self):
        return(self.rAzSlotCfg_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.azSlowrsvd & 0x1) << 31)
        reg = (reg & 0x87FFFFFF) + ((register_object.azSlowAdcOff & 0xF) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.azSlowAZdis & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.azSlowLCnvt & 0x1) << 25)
        reg = (reg & 0xFE7FFFFF) + ((register_object.azSlowPdnShft & 0x3) << 23)
        reg = (reg & 0xFF8FFFFF) + ((register_object.azSlowSampShft & 0x7) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.azSlowSampVal & 0xF) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.azrsvd & 0x1) << 15)
        reg = (reg & 0xFFFF87FF) + ((register_object.azAdcOff & 0xF) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.azAZdis & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.azLCnvt & 0x1) << 9)
        reg = (reg & 0xFFFFFE7F) + ((register_object.azSampPdnShft & 0x3) << 7)
        reg = (reg & 0xFFFFFF8F) + ((register_object.azSampShft & 0x7) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.azSampVal & 0xF)
        dma(self.address, 0xB8, reg)
    ## reserved
    def azSlowrsvd(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 31, value)
        return(value)
    ## azSlow ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def azSlowAdcOff(self, value = None):
        value = dma_bits(0xB8, self.address, 4, 27, value)
        return(value)
    ## azSlow ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def azSlowAZdis(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 26, value)
        return(value)
    ## azSlow ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def azSlowLCnvt(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 25, value)
        return(value)
    ## azSlow ADC sample acquisition count additional shift if in pdn in clkSys*2
    def azSlowPdnShft(self, value = None):
        value = dma_bits(0xB8, self.address, 2, 23, value)
        return(value)
    ## azSlow ADC sample acquisition count shift in clkSys*2
    def azSlowSampShft(self, value = None):
        value = dma_bits(0xB8, self.address, 3, 20, value)
        return(value)
    ## azSlow ADC sample acquisition count value in clkSys*2
    def azSlowSampVal(self, value = None):
        value = dma_bits(0xB8, self.address, 4, 16, value)
        return(value)
    ## reserved
    def azrsvd(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 15, value)
        return(value)
    ## AutoZero ADC analog offset to apply during acquision.  Math still assumes zero so results will have offset
    def azAdcOff(self, value = None):
        value = dma_bits(0xB8, self.address, 4, 11, value)
        return(value)
    ## AutoZero ADC Auto-Zero Disable 0:Subtract auto-zero from result 1:Use raw data from ADC
    def azAZdis(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 10, value)
        return(value)
    ## AutoZero ADC select long conversion 1:cnvt for 8 clkSys 0:cnvt for 6 clkSys
    def azLCnvt(self, value = None):
        value = dma_bits(0xB8, self.address, 1, 9, value)
        return(value)
    ## AutoZero ADC sample acquisition count additional shift if in pdn in clkSys*2
    def azSampPdnShft(self, value = None):
        value = dma_bits(0xB8, self.address, 2, 7, value)
        return(value)
    ## AutoZero ADC sample acquisition count shift in clkSys*2
    def azSampShft(self, value = None):
        value = dma_bits(0xB8, self.address, 3, 4, value)
        return(value)
    ## AutoZero ADC sample acquisition count value in clkSys*2
    def azSampVal(self, value = None):
        value = dma_bits(0xB8, self.address, 4, 0, value)
        return(value)

###################################################################
## Controller fault enable bits (copied to CTRLFLTENA and CTRLFLTENB when running)
###################################################################
class rUSRCTRLFLTEN_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xB9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSRCTRLFLTEN_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xB9, None)
            self.adcClkUnlockT = (self.reg_value >> 31) & 0x1
            self.adcClkUnlockI = (self.reg_value >> 30) & 0x1
            self.adcClkUnlockV = (self.reg_value >> 29) & 0x1
            self.psysWarn2 = (self.reg_value >> 28) & 0x1
            self.psysWarn1 = (self.reg_value >> 27) & 0x1
            self.psysCrit = (self.reg_value >> 26) & 0x1
            self.iinSense1 = (self.reg_value >> 25) & 0x1
            self.iinSense0 = (self.reg_value >> 24) & 0x1
            self.pinOpen = (self.reg_value >> 23) & 0x1
            self.mcuDead = (self.reg_value >> 22) & 0x1
            self.pInAlert = (self.reg_value >> 21) & 0x1
            self.external = (self.reg_value >> 20) & 0x1
            self.tmonFlt2 = (self.reg_value >> 19) & 0x1
            self.underTempFlt2 = (self.reg_value >> 18) & 0x1
            self.overTempFlt2 = (self.reg_value >> 17) & 0x1
            self.tmonFlt1 = (self.reg_value >> 16) & 0x1
            self.underTempFlt1 = (self.reg_value >> 15) & 0x1
            self.overTempFlt1 = (self.reg_value >> 14) & 0x1
            self.tmonFlt0 = (self.reg_value >> 13) & 0x1
            self.underTempFlt0 = (self.reg_value >> 12) & 0x1
            self.overTempFlt0 = (self.reg_value >> 11) & 0x1
            self.configLoad = (self.reg_value >> 10) & 0x1
            self.diagFault = (self.reg_value >> 9) & 0x1
            self.watchdog = (self.reg_value >> 8) & 0x1
            self.intTemp = (self.reg_value >> 7) & 0x1
            self.vdd1p8OvTelFlt = (self.reg_value >> 6) & 0x1
            self.avdd18ValidSyncZ = (self.reg_value >> 5) & 0x1
            self.vdd1p8UvTelFlt = (self.reg_value >> 4) & 0x1
            self.vddioUV = (self.reg_value >> 3) & 0x1
            self.vdd12ValidZ = (self.reg_value >> 2) & 0x1
            self.vdd33Brownout = (self.reg_value >> 1) & 0x1
            self.vdd33ValidZ = self.reg_value & 0x1

    def read_object(self):
        return(self.rUSRCTRLFLTEN_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.adcClkUnlockT & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.adcClkUnlockI & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.adcClkUnlockV & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.psysWarn2 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.psysWarn1 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.psysCrit & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.iinSense1 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.iinSense0 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.pinOpen & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.mcuDead & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.pInAlert & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.external & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.tmonFlt2 & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.underTempFlt2 & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.overTempFlt2 & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.tmonFlt1 & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.underTempFlt1 & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.overTempFlt1 & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.tmonFlt0 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.underTempFlt0 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.overTempFlt0 & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.configLoad & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.diagFault & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.watchdog & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.intTemp & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.vdd1p8OvTelFlt & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.avdd18ValidSyncZ & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.vdd1p8UvTelFlt & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.vddioUV & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.vdd12ValidZ & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vdd33Brownout & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.vdd33ValidZ & 0x1)
        dma(self.address, 0xB9, reg)
    ## CTRLFLTENB Tel Adc Clk controller unlock detect while running
    def adcClkUnlockT(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 31, value)
        return(value)
    ## CTRLFLTENB Isen Adc Clk controller unlock detect while running
    def adcClkUnlockI(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 30, value)
        return(value)
    ## CTRLFLTENB Vsen Adc Clk controller unlock detect while running
    def adcClkUnlockV(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 29, value)
        return(value)
    ## CTRLFLTENB PSYS warning 2 level fault
    def psysWarn2(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 28, value)
        return(value)
    ## CTRLFLTENB PSYS warning 1 level fault
    def psysWarn1(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 27, value)
        return(value)
    ## CTRLFLTENB PSYS critical level fault
    def psysCrit(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 26, value)
        return(value)
    ## CTRLFLTENB IIN Sense 1 fault
    def iinSense1(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 25, value)
        return(value)
    ## CTRLFLTENB IIN Sense 0 fault
    def iinSense0(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 24, value)
        return(value)
    ## CTRLFLTENA Open pin detected fault
    def pinOpen(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 23, value)
        return(value)
    ## CTRLFLTENA Hard Fault has occurred (memory bus violation)
    def mcuDead(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 22, value)
        return(value)
    ## CTRLFLTENA Input overcurrent fault
    def pInAlert(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 21, value)
        return(value)
    ## CTRLFLTENA External VTT input pin fault
    def external(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 20, value)
        return(value)
    ## CTRLFLTENA SPS TMON1 fault signal on TEMP2
    def tmonFlt2(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 19, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP2 data
    def underTempFlt2(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 18, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP2 data
    def overTempFlt2(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 17, value)
        return(value)
    ## CTRLFLTENA SPS TMON1 fault signal on TEMP1
    def tmonFlt1(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 16, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP1 data
    def underTempFlt1(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 15, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP1 data
    def overTempFlt1(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 14, value)
        return(value)
    ## CTRLFLTENA SPS TMON0 fault signal on TEMP0
    def tmonFlt0(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 13, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP0 data
    def underTempFlt0(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 12, value)
        return(value)
    ## CTRLFLTENA Fault on TEMP0 data
    def overTempFlt0(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 11, value)
        return(value)
    ## CTRLFLTENA Attempt to load user configuration failed
    def configLoad(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 10, value)
        return(value)
    ## CTRLFLTENA DIAGFTL bit 0 or 2 is active
    def diagFault(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 9, value)
        return(value)
    ## CTRLFLTENA Watchdog timer fault
    def watchdog(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 8, value)
        return(value)
    ## CTRLFLTENA Internal overtemperature fault
    def intTemp(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 7, value)
        return(value)
    ## CTRLFLTENA VDD1.8V over voltage fault
    def vdd1p8OvTelFlt(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 6, value)
        return(value)
    ## CTRLFLTENA VDD1.8 not valid fault
    def avdd18ValidSyncZ(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 5, value)
        return(value)
    ## CTRLFLTENA VDD1.8V under voltage fault
    def vdd1p8UvTelFlt(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 4, value)
        return(value)
    ## CTRLFLTENA VDDIO undervoltage fault
    def vddioUV(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 3, value)
        return(value)
    ## CTRLFLTENA VCCS undervoltage fault
    def vdd12ValidZ(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 2, value)
        return(value)
    ## CTRLFLTENA VCC supply brown out, from telemetry
    def vdd33Brownout(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 1, value)
        return(value)
    ## CTRLFLTENA VCC undervoltage fault
    def vdd33ValidZ(self, value = None):
        value = dma_bits(0xB9, self.address, 1, 0, value)
        return(value)

###################################################################
## User Isen Phase Gain phases 0-1
###################################################################
class rUSERPHGAIN01_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHGAIN01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBA, None)
            self.gain1 = (self.reg_value >> 16) & 0xFFFF
            self.gain0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rUSERPHGAIN01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gain1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain0 & 0xFFFF)
        dma(self.address, 0xBA, reg)
    ## Per phase user current sense gain
    def gain1(self, value = None):
        value = dma_bits(0xBA, self.address, 16, 16, value)
        return(value)
    ## Per phase user current sense gain
    def gain0(self, value = None):
        value = dma_bits(0xBA, self.address, 16, 0, value)
        return(value)

###################################################################
## User Isen Phase Gain phases 2-3
###################################################################
class rUSERPHGAIN23_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHGAIN23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBB, None)
            self.gain3 = (self.reg_value >> 16) & 0xFFFF
            self.gain2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rUSERPHGAIN23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gain3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain2 & 0xFFFF)
        dma(self.address, 0xBB, reg)
    ## Per phase user current sense gain
    def gain3(self, value = None):
        value = dma_bits(0xBB, self.address, 16, 16, value)
        return(value)
    ## Per phase user current sense gain
    def gain2(self, value = None):
        value = dma_bits(0xBB, self.address, 16, 0, value)
        return(value)

###################################################################
## User Isen Phase Gain phases 4-5
###################################################################
class rUSERPHGAIN45_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHGAIN45_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBC, None)
            self.gain5 = (self.reg_value >> 16) & 0xFFFF
            self.gain4 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rUSERPHGAIN45_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gain5 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain4 & 0xFFFF)
        dma(self.address, 0xBC, reg)
    ## Per phase user current sense gain
    def gain5(self, value = None):
        value = dma_bits(0xBC, self.address, 16, 16, value)
        return(value)
    ## Per phase user current sense gain
    def gain4(self, value = None):
        value = dma_bits(0xBC, self.address, 16, 0, value)
        return(value)

###################################################################
## User Isen Phase Gain phases 6-7
###################################################################
class rUSERPHGAIN67_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHGAIN67_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBD, None)
            self.gain7 = (self.reg_value >> 16) & 0xFFFF
            self.gain6 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rUSERPHGAIN67_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gain7 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain6 & 0xFFFF)
        dma(self.address, 0xBD, reg)
    ## Per phase user current sense gain
    def gain7(self, value = None):
        value = dma_bits(0xBD, self.address, 16, 16, value)
        return(value)
    ## Per phase user current sense gain
    def gain6(self, value = None):
        value = dma_bits(0xBD, self.address, 16, 0, value)
        return(value)

###################################################################
## User Isen Phase Offset phases 0-3
###################################################################
class rUSERPHOFFSET0123_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHOFFSET0123_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBE, None)
            self.offset3 = (self.reg_value >> 24) & 0xFF
            self.offset2 = (self.reg_value >> 16) & 0xFF
            self.offset1 = (self.reg_value >> 8) & 0xFF
            self.offset0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUSERPHOFFSET0123_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.offset3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.offset2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.offset1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.offset0 & 0xFF)
        dma(self.address, 0xBE, reg)
    ## Per phase user current sense offset
    def offset3(self, value = None):
        value = dma_bits(0xBE, self.address, 8, 24, value)
        return(value)
    ## Per phase user current sense offset
    def offset2(self, value = None):
        value = dma_bits(0xBE, self.address, 8, 16, value)
        return(value)
    ## Per phase user current sense offset
    def offset1(self, value = None):
        value = dma_bits(0xBE, self.address, 8, 8, value)
        return(value)
    ## Per phase user current sense offset
    def offset0(self, value = None):
        value = dma_bits(0xBE, self.address, 8, 0, value)
        return(value)

###################################################################
## User Isen Phase Offset phases 4-7
###################################################################
class rUSERPHOFFSET47_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xBF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERPHOFFSET47_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xBF, None)
            self.offset7 = (self.reg_value >> 24) & 0xFF
            self.offset6 = (self.reg_value >> 16) & 0xFF
            self.offset5 = (self.reg_value >> 8) & 0xFF
            self.offset4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUSERPHOFFSET47_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.offset7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.offset6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.offset5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.offset4 & 0xFF)
        dma(self.address, 0xBF, reg)
    ## Per phase user current sense offset
    def offset7(self, value = None):
        value = dma_bits(0xBF, self.address, 8, 24, value)
        return(value)
    ## Per phase user current sense offset
    def offset6(self, value = None):
        value = dma_bits(0xBF, self.address, 8, 16, value)
        return(value)
    ## Per phase user current sense offset
    def offset5(self, value = None):
        value = dma_bits(0xBF, self.address, 8, 8, value)
        return(value)
    ## Per phase user current sense offset
    def offset4(self, value = None):
        value = dma_bits(0xBF, self.address, 8, 0, value)
        return(value)

###################################################################
## User Phase Current Balance
###################################################################
class rCURRBALPH03_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCURRBALPH03_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC0, None)
            self.balPh3 = (self.reg_value >> 24) & 0xFF
            self.balPh2 = (self.reg_value >> 16) & 0xFF
            self.balPh1 = (self.reg_value >> 8) & 0xFF
            self.balPh0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rCURRBALPH03_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.balPh3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.balPh2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.balPh1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.balPh0 & 0xFF)
        dma(self.address, 0xC0, reg)
    ## Current balance adjust phase 3
    def balPh3(self, value = None):
        value = dma_bits(0xC0, self.address, 8, 24, value)
        return(value)
    ## Current balance adjust phase 2
    def balPh2(self, value = None):
        value = dma_bits(0xC0, self.address, 8, 16, value)
        return(value)
    ## Current balance adjust phase 1
    def balPh1(self, value = None):
        value = dma_bits(0xC0, self.address, 8, 8, value)
        return(value)
    ## Current balance adjust phase 0
    def balPh0(self, value = None):
        value = dma_bits(0xC0, self.address, 8, 0, value)
        return(value)

###################################################################
## User Phase Current Balance
###################################################################
class rCURRBALPH47_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCURRBALPH47_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC1, None)
            self.balPh7 = (self.reg_value >> 24) & 0xFF
            self.balPh6 = (self.reg_value >> 16) & 0xFF
            self.balPh5 = (self.reg_value >> 8) & 0xFF
            self.balPh4 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rCURRBALPH47_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.balPh7 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.balPh6 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.balPh5 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.balPh4 & 0xFF)
        dma(self.address, 0xC1, reg)
    ## Current balance adjust phase 7
    def balPh7(self, value = None):
        value = dma_bits(0xC1, self.address, 8, 24, value)
        return(value)
    ## Current balance adjust phase 6
    def balPh6(self, value = None):
        value = dma_bits(0xC1, self.address, 8, 16, value)
        return(value)
    ## Current balance adjust phase 5
    def balPh5(self, value = None):
        value = dma_bits(0xC1, self.address, 8, 8, value)
        return(value)
    ## Current balance adjust phase 4
    def balPh4(self, value = None):
        value = dma_bits(0xC1, self.address, 8, 0, value)
        return(value)

###################################################################
## CONFIG pin telemetry filter and gain
###################################################################
class rCFGPINTELFILTGAIN_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGPINTELFILTGAIN_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC2, None)
            self.filtResTelShft = (self.reg_value >> 20) & 0xF
            self.filtResTelMant = (self.reg_value >> 16) & 0xF
            self.gainResVal = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rCFGPINTELFILTGAIN_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF0FFFFF) + ((register_object.filtResTelShft & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.filtResTelMant & 0xF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gainResVal & 0xFFFF)
        dma(self.address, 0xC2, reg)
    ## Time constant right shift
    def filtResTelShft(self, value = None):
        value = dma_bits(0xC2, self.address, 4, 20, value)
        return(value)
    ## Time constant fractional multiplier
    def filtResTelMant(self, value = None):
        value = dma_bits(0xC2, self.address, 4, 16, value)
        return(value)
    ## Reporting scale factor
    def gainResVal(self, value = None):
        value = dma_bits(0xC2, self.address, 16, 0, value)
        return(value)

###################################################################
## Multi-function output pin MFP0 control
###################################################################
class rCFGMFP0_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGMFP0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC3, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGMFP0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xC3, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xC3, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 12, value)
        return(value)
    ## Select PG2 signal
    def pwrg2Out(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 11, value)
        return(value)
    ## Select PG1 signal
    def pwrg1Out(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 10, value)
        return(value)
    ## Select PG0 signal
    def pwrg0Out(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xC3, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin MFP1 control
###################################################################
class rCFGMFP1_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGMFP1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC4, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGMFP1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xC4, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xC4, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 12, value)
        return(value)
    ## Select PG2 signal
    def pwrg2Out(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 11, value)
        return(value)
    ## Select PG1 signal
    def pwrg1Out(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 10, value)
        return(value)
    ## Select PG0 signal
    def pwrg0Out(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xC4, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin MFP2 control
###################################################################
class rCFGMFP2_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGMFP2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC5, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGMFP2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xC5, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xC5, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 12, value)
        return(value)
    ## Select PG2 signal
    def pwrg2Out(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 11, value)
        return(value)
    ## Select PG1 signal
    def pwrg1Out(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 10, value)
        return(value)
    ## Select PG0 signal
    def pwrg0Out(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xC5, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin MFP3 control
###################################################################
class rCFGMFP3_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGMFP3_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC6, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGMFP3_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xC6, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xC6, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 12, value)
        return(value)
    ## Select PG2 signal
    def pwrg2Out(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 11, value)
        return(value)
    ## Select PG1 signal
    def pwrg1Out(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 10, value)
        return(value)
    ## Select PG0 signal
    def pwrg0Out(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xC6, self.address, 1, 0, value)
        return(value)

###################################################################
## Multi-function output pin MFP4 control
###################################################################
class rCFGMFP4_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCFGMFP4_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC7, None)
            self.pol = (self.reg_value >> 31) & 0x1
            self.drvCtrl = (self.reg_value >> 29) & 0x3
            self.gpio7 = (self.reg_value >> 28) & 0x1
            self.gpio6 = (self.reg_value >> 27) & 0x1
            self.gpio5 = (self.reg_value >> 26) & 0x1
            self.gpio4 = (self.reg_value >> 25) & 0x1
            self.gpio3 = (self.reg_value >> 24) & 0x1
            self.gpio2 = (self.reg_value >> 23) & 0x1
            self.gpio1 = (self.reg_value >> 22) & 0x1
            self.gpio0 = (self.reg_value >> 21) & 0x1
            self.sdifClk = (self.reg_value >> 19) & 0x1
            self.sdifData = (self.reg_value >> 18) & 0x1
            self.c2cDvidDown = (self.reg_value >> 17) & 0x1
            self.c2cDvidUp = (self.reg_value >> 16) & 0x1
            self.SWDO = (self.reg_value >> 15) & 0x1
            self.pmalert = (self.reg_value >> 14) & 0x1
            self.pg0AndPg1AndPg2 = (self.reg_value >> 13) & 0x1
            self.pg0AndPg1 = (self.reg_value >> 12) & 0x1
            self.pwrg2Out = (self.reg_value >> 11) & 0x1
            self.pwrg1Out = (self.reg_value >> 10) & 0x1
            self.pwrg0Out = (self.reg_value >> 9) & 0x1
            self.dftTrig = (self.reg_value >> 8) & 0x1
            self.drEn = (self.reg_value >> 7) & 0x1
            self.psysCrit = (self.reg_value >> 6) & 0x1
            self.cfp = (self.reg_value >> 5) & 0x1
            self.p2cl = (self.reg_value >> 4) & 0x1
            self.ocpSlow = (self.reg_value >> 3) & 0x1
            self.ocp = (self.reg_value >> 2) & 0x1
            self.vrhotOut = (self.reg_value >> 1) & 0x1
            self.pInAlertOut = self.reg_value & 0x1

    def read_object(self):
        return(self.rCFGMFP4_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.pol & 0x1) << 31)
        reg = (reg & 0x9FFFFFFF) + ((register_object.drvCtrl & 0x3) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.gpio7 & 0x1) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.gpio6 & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.gpio5 & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.gpio4 & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.gpio3 & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.gpio2 & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.gpio1 & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.gpio0 & 0x1) << 21)
        reg = (reg & 0xFFF7FFFF) + ((register_object.sdifClk & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.sdifData & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.c2cDvidDown & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.c2cDvidUp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.SWDO & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.pmalert & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.pg0AndPg1AndPg2 & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.pg0AndPg1 & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.pwrg2Out & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.pwrg1Out & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.pwrg0Out & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.dftTrig & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.drEn & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.psysCrit & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.cfp & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.p2cl & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.ocpSlow & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.ocp & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vrhotOut & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.pInAlertOut & 0x1)
        dma(self.address, 0xC7, reg)
    ## Polarity control, invert when 1
    def pol(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 31, value)
        return(value)
    ## Driver control: 00=Z, 01=Open drain, 10=OpenSource, 11=Totem pole
    def drvCtrl(self, value = None):
        value = dma_bits(0xC7, self.address, 2, 29, value)
        return(value)
    ## Select the GPIO7 output signal
    def gpio7(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 28, value)
        return(value)
    ## Select the GPIO6 output signal
    def gpio6(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 27, value)
        return(value)
    ## Select the GPIO5 output signal
    def gpio5(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 26, value)
        return(value)
    ## Select the GPIO4 output signal
    def gpio4(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 25, value)
        return(value)
    ## Select the GPIO3 output signal
    def gpio3(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 24, value)
        return(value)
    ## Select the GPIO2 output signal
    def gpio2(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 23, value)
        return(value)
    ## Select the GPIO1 output signal
    def gpio1(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 22, value)
        return(value)
    ## Select the GPIO0 output signal
    def gpio0(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 21, value)
        return(value)
    ## Select SDIF clock
    def sdifClk(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 19, value)
        return(value)
    ## Select SDIF data
    def sdifData(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 18, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID down
    def c2cDvidDown(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 17, value)
        return(value)
    ## Select Cycle-to-cycle limiting during DVID up
    def c2cDvidUp(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 16, value)
        return(value)
    ## Select debugger data signal
    def SWDO(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 15, value)
        return(value)
    ## Select PMBus alert signal - default
    def pmalert(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 14, value)
        return(value)
    ## Select PG0 AND PG1 AND PG2 logic combination
    def pg0AndPg1AndPg2(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 13, value)
        return(value)
    ## Select PG0 AND PG1 logic combination
    def pg0AndPg1(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 12, value)
        return(value)
    ## Select PG2 signal
    def pwrg2Out(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 11, value)
        return(value)
    ## Select PG1 signal
    def pwrg1Out(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 10, value)
        return(value)
    ## Select PG0 signal
    def pwrg0Out(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 9, value)
        return(value)
    ## Select the DFT trigger signal
    def dftTrig(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 8, value)
        return(value)
    ## Select the driver enable
    def drEn(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 7, value)
        return(value)
    ## Select the Intel Psys Crit signal
    def psysCrit(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 6, value)
        return(value)
    ## Select the Intel CFP signal
    def cfp(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 5, value)
        return(value)
    ## Select the Intel P2CL signal
    def p2cl(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 4, value)
        return(value)
    ## Select the OCP Slow signal
    def ocpSlow(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 3, value)
        return(value)
    ## Select the OCP signal
    def ocp(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 2, value)
        return(value)
    ## Select the Intel VRHOT signal
    def vrhotOut(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 1, value)
        return(value)
    ## Select the Intel Pin Alert signal
    def pInAlertOut(self, value = None):
        value = dma_bits(0xC7, self.address, 1, 0, value)
        return(value)

###################################################################
## RAM User Spare Register 0
###################################################################
class rUSERSPARE0_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERSPARE0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC8, None)
            self.spare0 = (self.reg_value >> 18) & 0x3FFF
            self.pmbTelLsb = self.reg_value & 0x3FFFF

    def read_object(self):
        return(self.rUSERSPARE0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFF) + ((register_object.spare0 & 0x3FFF) << 18)
        reg = (reg & 0xFFFC0000) + (register_object.pmbTelLsb & 0x3FFFF)
        dma(self.address, 0xC8, reg)
    def spare0(self, value = None):
        value = dma_bits(0xC8, self.address, 14, 18, value)
        return(value)
    ## pmbTelLsb User store
    def pmbTelLsb(self, value = None):
        value = dma_bits(0xC8, self.address, 18, 0, value)
        return(value)

###################################################################
## RAM User Spare Register 1
###################################################################
class rUSERSPARE1_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xC9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERSPARE1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xC9, None)
            self.tBot1 = (self.reg_value >> 24) & 0xFF
            self.tTop1 = (self.reg_value >> 16) & 0xFF
            self.tBot0 = (self.reg_value >> 8) & 0xFF
            self.tTop0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUSERSPARE1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.tBot1 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.tTop1 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.tBot0 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.tTop0 & 0xFF)
        dma(self.address, 0xC9, reg)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tBot1(self, value = None):
        value = dma_bits(0xC9, self.address, 8, 24, value)
        return(value)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tTop1(self, value = None):
        value = dma_bits(0xC9, self.address, 8, 16, value)
        return(value)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tBot0(self, value = None):
        value = dma_bits(0xC9, self.address, 8, 8, value)
        return(value)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tTop0(self, value = None):
        value = dma_bits(0xC9, self.address, 8, 0, value)
        return(value)

###################################################################
## RAM User Spare Register 2
###################################################################
class rUSERSPARE2_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rUSERSPARE2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xCA, None)
            self.spare2 = (self.reg_value >> 22) & 0x3FF
            self.ps3OnePhOnly2 = (self.reg_value >> 21) & 0x1
            self.ps2OnePhOnly2 = (self.reg_value >> 20) & 0x1
            self.ps3OnePhOnly1 = (self.reg_value >> 19) & 0x1
            self.ps2OnePhOnly1 = (self.reg_value >> 18) & 0x1
            self.ps3OnePhOnly0 = (self.reg_value >> 17) & 0x1
            self.ps2OnePhOnly0 = (self.reg_value >> 16) & 0x1
            self.tBot2 = (self.reg_value >> 8) & 0xFF
            self.tTop2 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rUSERSPARE2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x3FFFFF) + ((register_object.spare2 & 0x3FF) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.ps3OnePhOnly2 & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.ps2OnePhOnly2 & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.ps3OnePhOnly1 & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.ps2OnePhOnly1 & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.ps3OnePhOnly0 & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.ps2OnePhOnly0 & 0x1) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.tBot2 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.tTop2 & 0xFF)
        dma(self.address, 0xCA, reg)
    def spare2(self, value = None):
        value = dma_bits(0xCA, self.address, 10, 22, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps3OnePhOnly2(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 21, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps2OnePhOnly2(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 20, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps3OnePhOnly1(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 19, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps2OnePhOnly1(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 18, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps3OnePhOnly0(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 17, value)
        return(value)
    ## MBIRD_2189 User settings to be restored to hardware user registers
    def ps2OnePhOnly0(self, value = None):
        value = dma_bits(0xCA, self.address, 1, 16, value)
        return(value)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tBot2(self, value = None):
        value = dma_bits(0xCA, self.address, 8, 8, value)
        return(value)
    ## MBIRD_2185 Parameters for DCM adjust algorithm
    def tTop2(self, value = None):
        value = dma_bits(0xCA, self.address, 8, 0, value)
        return(value)

###################################################################
## RAM User Spare Register 3
###################################################################
class rUSERSPARE3_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCB, value)
        return(value)


###################################################################
## RAM User Spare Register 4
###################################################################
class rUSERSPARE4_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCC, value)
        return(value)


###################################################################
## RAM User Spare Register 5
###################################################################
class rUSERSPARE5_class(object):
    def __init__(self, address):
        self.interface = 'ramC'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCD, value)
        return(value)


###################################################################
## 
###################################################################
class rPARTID_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCE, value)
        return(value)


###################################################################
## 
###################################################################
class rISOURCETRIM_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xCF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISOURCETRIM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xCF, None)
            self.ntcTrim = (self.reg_value >> 16) & 0xFFFF
            self.pinstrapTrim = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISOURCETRIM_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.ntcTrim & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.pinstrapTrim & 0xFFFF)
        dma(self.address, 0xCF, reg)
    ## Current source trim for NTC measurements. 16:11 fixed point.
    def ntcTrim(self, value = None):
        value = dma_bits(0xCF, self.address, 16, 16, value)
        return(value)
    ## Current source trim for pinstrap measurements. 16:11 fixed point.
    def pinstrapTrim(self, value = None):
        value = dma_bits(0xCF, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rINTTEMPTRIM_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rINTTEMPTRIM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD0, None)
            self.slope = (self.reg_value >> 16) & 0xFFFF
            self.offset = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rINTTEMPTRIM_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.slope & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.offset & 0xFFFF)
        dma(self.address, 0xD0, reg)
    ## 16.12 format Internal temp slope.
    def slope(self, value = None):
        value = dma_bits(0xD0, self.address, 16, 16, value)
        return(value)
    ## Internal temp telemetry ADC offset in codes at room.
    def offset(self, value = None):
        value = dma_bits(0xD0, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENGAIN01_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENGAIN01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD1, None)
            self.gain1 = (self.reg_value >> 16) & 0xFFFF
            self.gain0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENGAIN01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.gain1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain0 & 0xFFFF)
        dma(self.address, 0xD1, reg)
    ## Rail 1 gain for VSEN tempCo.
    def gain1(self, value = None):
        value = dma_bits(0xD1, self.address, 16, 16, value)
        return(value)
    ## Rail 0 gain for VSEN tempCo.
    def gain0(self, value = None):
        value = dma_bits(0xD1, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENCURVE_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENCURVE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD2, None)
            self.curve = (self.reg_value >> 16) & 0xFFFF
            self.gain2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENCURVE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.curve & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain2 & 0xFFFF)
        dma(self.address, 0xD2, reg)
    ## Curve required for VSEN tempCo.
    def curve(self, value = None):
        value = dma_bits(0xD2, self.address, 16, 16, value)
        return(value)
    ## Rail 2 gain for VSEN tempCo.
    def gain2(self, value = None):
        value = dma_bits(0xD2, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENRATIO0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENRATIO0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD3, None)
            self.msbRatio = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENRATIO0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.msbRatio & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio & 0xFFFF)
        dma(self.address, 0xD3, reg)
    ## MSB ratio for VSEN tempCo.
    def msbRatio(self, value = None):
        value = dma_bits(0xD3, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for VSEN tempCo.
    def xsbRatio(self, value = None):
        value = dma_bits(0xD3, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENRATIO1_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENRATIO1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD4, None)
            self.msbRatio = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENRATIO1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.msbRatio & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio & 0xFFFF)
        dma(self.address, 0xD4, reg)
    ## MSB ratio for VSEN tempCo.
    def msbRatio(self, value = None):
        value = dma_bits(0xD4, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for VSEN tempCo.
    def xsbRatio(self, value = None):
        value = dma_bits(0xD4, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENRATIO2_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENRATIO2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD5, None)
            self.msbRatio = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENRATIO2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.msbRatio & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio & 0xFFFF)
        dma(self.address, 0xD5, reg)
    ## MSB ratio for VSEN tempCo.
    def msbRatio(self, value = None):
        value = dma_bits(0xD5, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for VSEN tempCo.
    def xsbRatio(self, value = None):
        value = dma_bits(0xD5, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENTEMPCO_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENTEMPCO_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD6, None)
            self.offset = (self.reg_value >> 16) & 0xFFFF
            self.slope = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENTEMPCO_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.offset & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.slope & 0xFFFF)
        dma(self.address, 0xD6, reg)
    ## Offset for VSEN tempCo.
    def offset(self, value = None):
        value = dma_bits(0xD6, self.address, 16, 16, value)
        return(value)
    ## Slope for VSEN tempCo.
    def slope(self, value = None):
        value = dma_bits(0xD6, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rTELADCCURVEGAIN_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTELADCCURVEGAIN_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD7, None)
            self.curve = (self.reg_value >> 16) & 0xFFFF
            self.gain = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTELADCCURVEGAIN_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.curve & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain & 0xFFFF)
        dma(self.address, 0xD7, reg)
    ## Curve required for Telemetry ADC tempCo.
    def curve(self, value = None):
        value = dma_bits(0xD7, self.address, 16, 16, value)
        return(value)
    ## Gain for Telemetry ADC tempCo.
    def gain(self, value = None):
        value = dma_bits(0xD7, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rTELADCRATIO_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTELADCRATIO_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD8, None)
            self.msbRatio = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTELADCRATIO_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.msbRatio & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio & 0xFFFF)
        dma(self.address, 0xD8, reg)
    ## MSB ratio for Telemetry ADC tempCo.
    def msbRatio(self, value = None):
        value = dma_bits(0xD8, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for Telemetry ADC tempCo.
    def xsbRatio(self, value = None):
        value = dma_bits(0xD8, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rTELADCTEMPCO_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xD9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rTELADCTEMPCO_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xD9, None)
            self.offset = (self.reg_value >> 16) & 0xFFFF
            self.slope = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rTELADCTEMPCO_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.offset & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.slope & 0xFFFF)
        dma(self.address, 0xD9, reg)
    ## Offset for Telemetry ADC tempCo.
    def offset(self, value = None):
        value = dma_bits(0xD9, self.address, 16, 16, value)
        return(value)
    ## Slope for Telemetry ADC tempCo.
    def slope(self, value = None):
        value = dma_bits(0xD9, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVSENOFFSET01_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVSENOFFSET01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDA, None)
            self.vSenOffset1 = (self.reg_value >> 16) & 0xFFFF
            self.vSenOffset0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVSENOFFSET01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.vSenOffset1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vSenOffset0 & 0xFFFF)
        dma(self.address, 0xDA, reg)
    ## Trimmed Vsen offset for channel 0.
    def vSenOffset1(self, value = None):
        value = dma_bits(0xDA, self.address, 16, 16, value)
        return(value)
    ## Trimmed Vsen offset for channel 1.
    def vSenOffset0(self, value = None):
        value = dma_bits(0xDA, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENCURVE_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENCURVE_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDB, None)
            self.iSenCurve = (self.reg_value >> 16) & 0xFFFF
            self.vSenOffset2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENCURVE_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.iSenCurve & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vSenOffset2 & 0xFFFF)
        dma(self.address, 0xDB, reg)
    ## Curve required for ISEN ADC tempCo.
    def iSenCurve(self, value = None):
        value = dma_bits(0xDB, self.address, 16, 16, value)
        return(value)
    ## Trimmed Vsen offset for channel 2.
    def vSenOffset2(self, value = None):
        value = dma_bits(0xDB, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rVCCGAINOFFSET_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rVCCGAINOFFSET_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDC, None)
            self.offset = (self.reg_value >> 16) & 0xFFFF
            self.gain = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rVCCGAINOFFSET_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.offset & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gain & 0xFFFF)
        dma(self.address, 0xDC, reg)
    ## VCC measurement at test (3.3V).
    def offset(self, value = None):
        value = dma_bits(0xDC, self.address, 16, 16, value)
        return(value)
    ## Signed, 16.15 Gain term for Vsen offset VCC dependence. Max value +/- 1/64th.
    def gain(self, value = None):
        value = dma_bits(0xDC, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENTEMPCO_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDD, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENTEMPCO_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDD, None)
            self.offset = (self.reg_value >> 16) & 0xFFFF
            self.slope = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENTEMPCO_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.offset & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.slope & 0xFFFF)
        dma(self.address, 0xDD, reg)
    ## Offset for ISEN tempCo.
    def offset(self, value = None):
        value = dma_bits(0xDD, self.address, 16, 16, value)
        return(value)
    ## Slope for ISEN tempCo.
    def slope(self, value = None):
        value = dma_bits(0xDD, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENRATIO01_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENRATIO01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDE, None)
            self.xsbRatio1 = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENRATIO01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.xsbRatio1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio0 & 0xFFFF)
        dma(self.address, 0xDE, reg)
    ## XSB ratio for Isen ADC 1.
    def xsbRatio1(self, value = None):
        value = dma_bits(0xDE, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for Isen ADC 0.
    def xsbRatio0(self, value = None):
        value = dma_bits(0xDE, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENRATIO23_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xDF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENRATIO23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xDF, None)
            self.xsbRatio3 = (self.reg_value >> 16) & 0xFFFF
            self.xsbRatio2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENRATIO23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.xsbRatio3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.xsbRatio2 & 0xFFFF)
        dma(self.address, 0xDF, reg)
    ## XSB ratio for Isen ADC 3.
    def xsbRatio3(self, value = None):
        value = dma_bits(0xDF, self.address, 16, 16, value)
        return(value)
    ## XSB ratio for Isen ADC 2.
    def xsbRatio2(self, value = None):
        value = dma_bits(0xDF, self.address, 16, 0, value)
        return(value)

###################################################################
## General Factory Configuration
###################################################################
class rFACCONFIG0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACCONFIG0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE0, None)
            self.enSysPwrInt = (self.reg_value >> 28) & 0x1
            self.tempCoThreshInt = (self.reg_value >> 20) & 0xFF
            self.telAdcTempCoEn = (self.reg_value >> 19) & 0x1
            self.iSenUpdateEn = (self.reg_value >> 18) & 0x1
            self.isenAdcTempCoEn = (self.reg_value >> 17) & 0x1
            self.vsenTempCoEn = (self.reg_value >> 16) & 0x1
            self.sysTickPeriod = (self.reg_value >> 8) & 0xFF
            self.adcTempCoRange = self.reg_value & 0xFF

    def read_object(self):
        return(self.rFACCONFIG0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xEFFFFFFF) + ((register_object.enSysPwrInt & 0x1) << 28)
        reg = (reg & 0xF00FFFFF) + ((register_object.tempCoThreshInt & 0xFF) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.telAdcTempCoEn & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.iSenUpdateEn & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.isenAdcTempCoEn & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.vsenTempCoEn & 0x1) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.sysTickPeriod & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.adcTempCoRange & 0xFF)
        dma(self.address, 0xE0, reg)
    ## Enable system power interrupt for PS4 transitions.
    def enSysPwrInt(self, value = None):
        value = dma_bits(0xE0, self.address, 1, 28, value)
        return(value)
    ## Internal Temperature threshold for updating resistor tempCo
    def tempCoThreshInt(self, value = None):
        value = dma_bits(0xE0, self.address, 8, 20, value)
        return(value)
    ## Enable Telemetry ADC tempCo.
    def telAdcTempCoEn(self, value = None):
        value = dma_bits(0xE0, self.address, 1, 19, value)
        return(value)
    ## Enable gain and offset updates to Isen ADC.
    def iSenUpdateEn(self, value = None):
        value = dma_bits(0xE0, self.address, 1, 18, value)
        return(value)
    ## Enable ISEN ADC tempCo.
    def isenAdcTempCoEn(self, value = None):
        value = dma_bits(0xE0, self.address, 1, 17, value)
        return(value)
    ## Enable VSEN ADC tempCo.
    def vsenTempCoEn(self, value = None):
        value = dma_bits(0xE0, self.address, 1, 16, value)
        return(value)
    ## Systick Timer Period, minimum 100us plus 50us * sysTickPeriod
    def sysTickPeriod(self, value = None):
        value = dma_bits(0xE0, self.address, 8, 8, value)
        return(value)
    ## TempCo correction range limit for telemtry, vsense and isense ADCs. 0x8000 +/- (range << 4)
    def adcTempCoRange(self, value = None):
        value = dma_bits(0xE0, self.address, 8, 0, value)
        return(value)

###################################################################
## General Factory Configuration
###################################################################
class rFACCONFIG_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACCONFIG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE1, None)
            self.reserved0 = (self.reg_value >> 31) & 0x1
            self.pinstrapAddrOnly = (self.reg_value >> 30) & 0x1
            self.ntcTrim = (self.reg_value >> 26) & 0xF
            self.pinstrapTrim = (self.reg_value >> 22) & 0xF
            self.vccValid = (self.reg_value >> 13) & 0x1FF
            self.pinstrapDelay = (self.reg_value >> 5) & 0xFF
            self.otpRetries = self.reg_value & 0x1F

    def read_object(self):
        return(self.rFACCONFIG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.reserved0 & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.pinstrapAddrOnly & 0x1) << 30)
        reg = (reg & 0xC3FFFFFF) + ((register_object.ntcTrim & 0xF) << 26)
        reg = (reg & 0xFC3FFFFF) + ((register_object.pinstrapTrim & 0xF) << 22)
        reg = (reg & 0xFFC01FFF) + ((register_object.vccValid & 0x1FF) << 13)
        reg = (reg & 0xFFFFE01F) + ((register_object.pinstrapDelay & 0xFF) << 5)
        reg = (reg & 0xFFFFFFE0) + (register_object.otpRetries & 0x1F)
        dma(self.address, 0xE1, reg)
    ## Reserved
    def reserved0(self, value = None):
        value = dma_bits(0xE1, self.address, 1, 31, value)
        return(value)
    ## 0: Measure both ADDRESS and CONFIG pinstraps (default), 1: Measure ADDRESS pinstrap ONLY
    def pinstrapAddrOnly(self, value = None):
        value = dma_bits(0xE1, self.address, 1, 30, value)
        return(value)
    ## tempTrim.extTempTrim value for NTC 70uA pump.
    def ntcTrim(self, value = None):
        value = dma_bits(0xE1, self.address, 4, 26, value)
        return(value)
    ## tempTrim.extTempTrim value for Pinstrap 55uA pump.
    def pinstrapTrim(self, value = None):
        value = dma_bits(0xE1, self.address, 4, 22, value)
        return(value)
    ## VCC valid threshold in 10mV steps, default is 2.8V
    def vccValid(self, value = None):
        value = dma_bits(0xE1, self.address, 9, 13, value)
        return(value)
    ## Pinstrap Delay in 32us increments
    def pinstrapDelay(self, value = None):
        value = dma_bits(0xE1, self.address, 8, 5, value)
        return(value)
    ## Max number of OTP write retries mapped to OTPCTRL
    def otpRetries(self, value = None):
        value = dma_bits(0xE1, self.address, 5, 0, value)
        return(value)

###################################################################
## Factory configuration value for VCC and IntTemp. for VCC "good" measurements at startup.
###################################################################
class rFACVINTTEMPSLOTCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE2, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACVINTTEMPSLOTCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE2, None)
            self.intTempSlotCfg = (self.reg_value >> 16) & 0xFFFF
            self.vIntSlotCfg = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rFACVINTTEMPSLOTCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.intTempSlotCfg & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.vIntSlotCfg & 0xFFFF)
        dma(self.address, 0xE2, reg)
    ## Internal Temp
    def intTempSlotCfg(self, value = None):
        value = dma_bits(0xE2, self.address, 16, 16, value)
        return(value)
    ## VCC and other internal voltages
    def vIntSlotCfg(self, value = None):
        value = dma_bits(0xE2, self.address, 16, 0, value)
        return(value)

###################################################################
## Factory configuration for AZSLOTCFG and EXTSLOTCFG for ADC auto-zero and pinstrapping at startup.
###################################################################
class rFACAZEXTSLOTCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE3, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACAZEXTSLOTCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE3, None)
            self.extSlotCfg = (self.reg_value >> 16) & 0xFFFF
            self.azSlotCfg = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rFACAZEXTSLOTCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.extSlotCfg & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.azSlotCfg & 0xFFFF)
        dma(self.address, 0xE3, reg)
    ## EXTSLOTCFG
    def extSlotCfg(self, value = None):
        value = dma_bits(0xE3, self.address, 16, 16, value)
        return(value)
    ## AZSLOTCFG
    def azSlotCfg(self, value = None):
        value = dma_bits(0xE3, self.address, 16, 0, value)
        return(value)

###################################################################
## Settings to use for ADC enable register CHXCTL in full power mode (manual control)
###################################################################
class rCHXCTLFULLPWR_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE4, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rCHXCTLFULLPWR_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE4, None)
            self.reserved = (self.reg_value >> 28) & 0xF
            self.manTelPsysEnable = (self.reg_value >> 27) & 0x1
            self.manDllEnable = (self.reg_value >> 26) & 0x1
            self.manBgEnable = (self.reg_value >> 25) & 0x1
            self.manOscEnable = (self.reg_value >> 24) & 0x1
            self.telCompEnable = (self.reg_value >> 23) & 0x1
            self.isen3CompEnable = (self.reg_value >> 22) & 0x1
            self.isen2CompEnable = (self.reg_value >> 21) & 0x1
            self.isen1CompEnable = (self.reg_value >> 20) & 0x1
            self.isen0CompEnable = (self.reg_value >> 19) & 0x1
            self.vsen2CompEnable = (self.reg_value >> 18) & 0x1
            self.vsen1CompEnable = (self.reg_value >> 17) & 0x1
            self.vsen0CompEnable = (self.reg_value >> 16) & 0x1
            self.telDigEnable = (self.reg_value >> 15) & 0x1
            self.isen3DigEnable = (self.reg_value >> 14) & 0x1
            self.isen2DigEnable = (self.reg_value >> 13) & 0x1
            self.isen1DigEnable = (self.reg_value >> 12) & 0x1
            self.isen0DigEnable = (self.reg_value >> 11) & 0x1
            self.vsen2DigEnable = (self.reg_value >> 10) & 0x1
            self.vsen1DigEnable = (self.reg_value >> 9) & 0x1
            self.vsen0DigEnable = (self.reg_value >> 8) & 0x1
            self.telAdcEnable = (self.reg_value >> 7) & 0x1
            self.isen3AdcEnable = (self.reg_value >> 6) & 0x1
            self.isen2AdcEnable = (self.reg_value >> 5) & 0x1
            self.isen1AdcEnable = (self.reg_value >> 4) & 0x1
            self.isen0AdcEnable = (self.reg_value >> 3) & 0x1
            self.vsen2AdcEnable = (self.reg_value >> 2) & 0x1
            self.vsen1AdcEnable = (self.reg_value >> 1) & 0x1
            self.vsen0AdcEnable = self.reg_value & 0x1

    def read_object(self):
        return(self.rCHXCTLFULLPWR_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.reserved & 0xF) << 28)
        reg = (reg & 0xF7FFFFFF) + ((register_object.manTelPsysEnable & 0x1) << 27)
        reg = (reg & 0xFBFFFFFF) + ((register_object.manDllEnable & 0x1) << 26)
        reg = (reg & 0xFDFFFFFF) + ((register_object.manBgEnable & 0x1) << 25)
        reg = (reg & 0xFEFFFFFF) + ((register_object.manOscEnable & 0x1) << 24)
        reg = (reg & 0xFF7FFFFF) + ((register_object.telCompEnable & 0x1) << 23)
        reg = (reg & 0xFFBFFFFF) + ((register_object.isen3CompEnable & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.isen2CompEnable & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.isen1CompEnable & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.isen0CompEnable & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.vsen2CompEnable & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.vsen1CompEnable & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.vsen0CompEnable & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.telDigEnable & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.isen3DigEnable & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.isen2DigEnable & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.isen1DigEnable & 0x1) << 12)
        reg = (reg & 0xFFFFF7FF) + ((register_object.isen0DigEnable & 0x1) << 11)
        reg = (reg & 0xFFFFFBFF) + ((register_object.vsen2DigEnable & 0x1) << 10)
        reg = (reg & 0xFFFFFDFF) + ((register_object.vsen1DigEnable & 0x1) << 9)
        reg = (reg & 0xFFFFFEFF) + ((register_object.vsen0DigEnable & 0x1) << 8)
        reg = (reg & 0xFFFFFF7F) + ((register_object.telAdcEnable & 0x1) << 7)
        reg = (reg & 0xFFFFFFBF) + ((register_object.isen3AdcEnable & 0x1) << 6)
        reg = (reg & 0xFFFFFFDF) + ((register_object.isen2AdcEnable & 0x1) << 5)
        reg = (reg & 0xFFFFFFEF) + ((register_object.isen1AdcEnable & 0x1) << 4)
        reg = (reg & 0xFFFFFFF7) + ((register_object.isen0AdcEnable & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.vsen2AdcEnable & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vsen1AdcEnable & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.vsen0AdcEnable & 0x1)
        dma(self.address, 0xE4, reg)
    ## reserved
    def reserved(self, value = None):
        value = dma_bits(0xE4, self.address, 4, 28, value)
        return(value)
    ## Full power mode manual enable for high-speed PSYS comparators
    def manTelPsysEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 27, value)
        return(value)
    ## Full power mode manual enable for DLL
    def manDllEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 26, value)
        return(value)
    ## Full power mode manual enable for Switched cap Bandgap
    def manBgEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 25, value)
        return(value)
    ## Full power mode manual enable for Oscillator power
    def manOscEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 24, value)
        return(value)
    ## Full power mode manual enable for TEL ADC (anaTelAdc comparator)
    def telCompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 23, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen3CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 22, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen2CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 21, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc comparator)
    def isen1CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 20, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC0 (anaIsenAdc comparator)
    def isen0CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 19, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC2 (anaVsenAdc2 comparator)
    def vsen2CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 18, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC1 (anaVsenAdc1 comparator)
    def vsen1CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 17, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC0 (anaVsenAdc0 comparator)
    def vsen0CompEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 16, value)
        return(value)
    ## Full power mode digital enable for TEL ADC (anaTelAdc controller)
    def telDigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 15, value)
        return(value)
    ## Full power mode digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen3DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 14, value)
        return(value)
    ## Full power mode digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen2DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 13, value)
        return(value)
    ## Full power mode digital enable for ISEN ADC1 (anaIsenAdc controller)
    def isen1DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 12, value)
        return(value)
    ## Full power mode digital enable for ISEN ADC0 (anaIsenAdc controller)
    def isen0DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 11, value)
        return(value)
    ## Full power mode digital enable for VSEN ADC2 (anaVsenAdc2 controller)
    def vsen2DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 10, value)
        return(value)
    ## Full power mode digital enable for VSEN ADC1 (anaVsenAdc1 controller)
    def vsen1DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 9, value)
        return(value)
    ## Full power mode digital enable for VSEN ADC0 (anaVsenAdc0 controller)
    def vsen0DigEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 8, value)
        return(value)
    ## Full power mode manual enable for TEL ADC (anaTelAdc module)
    def telAdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 7, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc module)
    def isen3AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 6, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc module)
    def isen2AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 5, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC1 (anaIsenAdc module)
    def isen1AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 4, value)
        return(value)
    ## Full power mode manual enable for ISEN ADC0 (anaIsenAdc module)
    def isen0AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 3, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC2 (anaVsenAdc2 module)
    def vsen2AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 2, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC1 (anaVsenAdc1 module)
    def vsen1AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 1, value)
        return(value)
    ## Full power mode manual enable for VSEN ADC0 (anaVsenAdc0 module)
    def vsen0AdcEnable(self, value = None):
        value = dma_bits(0xE4, self.address, 1, 0, value)
        return(value)

###################################################################
## Pinstrap Internal Temperature Coefficients
###################################################################
class RTCINT_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE5, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class RTCINT_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE5, None)
            self.tempCoIntA = (self.reg_value >> 16) & 0xFFFF
            self.tempCoIntB = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.RTCINT_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.tempCoIntA & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.tempCoIntB & 0xFFFF)
        dma(self.address, 0xE5, reg)
    ## tempCo A
    def tempCoIntA(self, value = None):
        value = dma_bits(0xE5, self.address, 16, 16, value)
        return(value)
    ## tempCo B
    def tempCoIntB(self, value = None):
        value = dma_bits(0xE5, self.address, 16, 0, value)
        return(value)

###################################################################
## Pinstrap Temperature Coefficients 2
###################################################################
class RTCINT2_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE6, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class RTCINT2_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE6, None)
            self.reserved = (self.reg_value >> 16) & 0xFFFF
            self.tempCoIntC = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.RTCINT2_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.reserved & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.tempCoIntC & 0xFFFF)
        dma(self.address, 0xE6, reg)
    ## Reserved
    def reserved(self, value = None):
        value = dma_bits(0xE6, self.address, 16, 16, value)
        return(value)
    ## tempCo C
    def tempCoIntC(self, value = None):
        value = dma_bits(0xE6, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class RVSENDIGOFFSET_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE7, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class RVSENDIGOFFSET_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE7, None)
            self.psysLvlOffset = (self.reg_value >> 24) & 0xFF
            self.offset2 = (self.reg_value >> 16) & 0xFF
            self.offset1 = (self.reg_value >> 8) & 0xFF
            self.offset0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.RVSENDIGOFFSET_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.psysLvlOffset & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.offset2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.offset1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.offset0 & 0xFF)
        dma(self.address, 0xE7, reg)
    ## Psys limit msb/xsb/lsb conversion offset
    def psysLvlOffset(self, value = None):
        value = dma_bits(0xE7, self.address, 8, 24, value)
        return(value)
    ## Signed Digital Offset applied to vSen2 ADC
    def offset2(self, value = None):
        value = dma_bits(0xE7, self.address, 8, 16, value)
        return(value)
    ## Signed Digital Offset applied to vSen1 ADC
    def offset1(self, value = None):
        value = dma_bits(0xE7, self.address, 8, 8, value)
        return(value)
    ## Signed Digital Offset applied to vSen0 ADC
    def offset0(self, value = None):
        value = dma_bits(0xE7, self.address, 8, 0, value)
        return(value)

###################################################################
## Another general purpose config register.
###################################################################
class rFACCONFIG1_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE8, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACCONFIG1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE8, None)
            self.svcWakeupDisable = (self.reg_value >> 22) & 0x1
            self.vddioBufEn = (self.reg_value >> 21) & 0x1
            self.vddioUvEn = (self.reg_value >> 20) & 0x1
            self.svidBiasEn = (self.reg_value >> 19) & 0x1
            self.refBg2Pdn = (self.reg_value >> 18) & 0x1
            self.LdoPdn = (self.reg_value >> 17) & 0x1
            self.intTmp = (self.reg_value >> 16) & 0x1
            self.oscEnable = (self.reg_value >> 15) & 0x1
            self.currDistEn = (self.reg_value >> 14) & 0x1
            self.anaIinBufEn = (self.reg_value >> 13) & 0x1
            self.anaVinBufEn = (self.reg_value >> 12) & 0x1
            self.dllBuf1p8Sel = (self.reg_value >> 3) & 0x1
            self.iSenBuf1p8Sel = (self.reg_value >> 2) & 0x1
            self.vSenBuf1p8Sel = (self.reg_value >> 1) & 0x1
            self.telBuf1p8Sel = self.reg_value & 0x1

    def read_object(self):
        return(self.rFACCONFIG1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFBFFFFF) + ((register_object.svcWakeupDisable & 0x1) << 22)
        reg = (reg & 0xFFDFFFFF) + ((register_object.vddioBufEn & 0x1) << 21)
        reg = (reg & 0xFFEFFFFF) + ((register_object.vddioUvEn & 0x1) << 20)
        reg = (reg & 0xFFF7FFFF) + ((register_object.svidBiasEn & 0x1) << 19)
        reg = (reg & 0xFFFBFFFF) + ((register_object.refBg2Pdn & 0x1) << 18)
        reg = (reg & 0xFFFDFFFF) + ((register_object.LdoPdn & 0x1) << 17)
        reg = (reg & 0xFFFEFFFF) + ((register_object.intTmp & 0x1) << 16)
        reg = (reg & 0xFFFF7FFF) + ((register_object.oscEnable & 0x1) << 15)
        reg = (reg & 0xFFFFBFFF) + ((register_object.currDistEn & 0x1) << 14)
        reg = (reg & 0xFFFFDFFF) + ((register_object.anaIinBufEn & 0x1) << 13)
        reg = (reg & 0xFFFFEFFF) + ((register_object.anaVinBufEn & 0x1) << 12)
        reg = (reg & 0xFFFFFFF7) + ((register_object.dllBuf1p8Sel & 0x1) << 3)
        reg = (reg & 0xFFFFFFFB) + ((register_object.iSenBuf1p8Sel & 0x1) << 2)
        reg = (reg & 0xFFFFFFFD) + ((register_object.vSenBuf1p8Sel & 0x1) << 1)
        reg = (reg & 0xFFFFFFFE) + (register_object.telBuf1p8Sel & 0x1)
        dma(self.address, 0xE8, reg)
    ## Full power value of PWREN0[10]:  0 - Automatic SVID/SVI3 wakeup circut enabled (default)<br>1 - Disable the Automatic SVID/SVI3 powerdown, force svidBiasEn=1
    def svcWakeupDisable(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 22, value)
        return(value)
    ## Full power value of PWREN0[9]:  0 - Disable VDDIO Buffer<br>1 - Enable VDDIO Buffer
    def vddioBufEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 21, value)
        return(value)
    ## Full power value of PWREN0[8]:  0 - Disable VDDIO UV Comparator<br>1 - Enable VDDIO UV Comparator
    def vddioUvEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 20, value)
        return(value)
    ## Full power value of PWREN0[7]:  Active high enable for bias currents and reference voltage for SVID pad cells; Set low for IDDQ testing
    def svidBiasEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 19, value)
        return(value)
    ## Full power value of PWREN0[6]:  Active high power down (active low enable) for secondary bandgap (anaComRefBg2 module)
    def refBg2Pdn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 18, value)
        return(value)
    ## Full power value of PWREN0[5]:  Active high power down (active low enable) for LDO regulator (anaLdo module)
    def LdoPdn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 17, value)
        return(value)
    ## Full power value of PWREN0[4]:  Active high enable for internal temperature sensor (anaComRefTmp module)
    def intTmp(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 16, value)
        return(value)
    ## Full power value of PWREN0[3]:  Active high enable for oscillator (anaComClkOsc module)
    def oscEnable(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 15, value)
        return(value)
    ## Full power value of PWREN0[2]:  Enable the current distributor
    def currDistEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 14, value)
        return(value)
    ## Full power value of PWREN0[1]:  Enable the buffer for the IIN sense
    def anaIinBufEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 13, value)
        return(value)
    ## Full power value of PWREN0[0]:  Enable the buffer for the VIN sense
    def anaVinBufEn(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 12, value)
        return(value)
    ## Factory setting for Sel DLL LDO power supply, if 0=> 3.3V  if1=>1.8V.
    def dllBuf1p8Sel(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 3, value)
        return(value)
    ## Factory setting for Master enable for anaAddrCfg.
    def iSenBuf1p8Sel(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 2, value)
        return(value)
    ## Factory setting for select 1.8V as source for vSen buffer for low power if 1, otherwise use 3.3V.
    def vSenBuf1p8Sel(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 1, value)
        return(value)
    ## Factory setting for select 1.8V as source for tel buffer for low power if 1, otherwise use 3.3V
    def telBuf1p8Sel(self, value = None):
        value = dma_bits(0xE8, self.address, 1, 0, value)
        return(value)

###################################################################
## UTC Telem resistor reader filter
###################################################################
class rPINRESFILTGAIN_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xE9, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rPINRESFILTGAIN_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xE9, None)
            self.filtResTelShft = (self.reg_value >> 20) & 0xF
            self.filtResTelMant = (self.reg_value >> 16) & 0xF
            self.gainResVal = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rPINRESFILTGAIN_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF0FFFFF) + ((register_object.filtResTelShft & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.filtResTelMant & 0xF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.gainResVal & 0xFFFF)
        dma(self.address, 0xE9, reg)
    ## Time constant right shift
    def filtResTelShft(self, value = None):
        value = dma_bits(0xE9, self.address, 4, 20, value)
        return(value)
    ## Time constant fractional multiplier
    def filtResTelMant(self, value = None):
        value = dma_bits(0xE9, self.address, 4, 16, value)
        return(value)
    ## Reporting scale factor
    def gainResVal(self, value = None):
        value = dma_bits(0xE9, self.address, 16, 0, value)
        return(value)

###################################################################
## SDIF Fault Policy Configuration
###################################################################
class rSDIFFLTCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEA, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFFLTCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEA, None)
            self.azFltEn = (self.reg_value >> 31) & 0x1
            self.telemRqstFlten = (self.reg_value >> 30) & 0x1
            self.trimDataFltEn = (self.reg_value >> 29) & 0x1
            self.initFltEn = (self.reg_value >> 28) & 0x1
            self.telemRetries = (self.reg_value >> 16) & 0xFF
            self.trimRetries = (self.reg_value >> 8) & 0xFF
            self.initRetries = self.reg_value & 0xFF

    def read_object(self):
        return(self.rSDIFFLTCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0x7FFFFFFF) + ((register_object.azFltEn & 0x1) << 31)
        reg = (reg & 0xBFFFFFFF) + ((register_object.telemRqstFlten & 0x1) << 30)
        reg = (reg & 0xDFFFFFFF) + ((register_object.trimDataFltEn & 0x1) << 29)
        reg = (reg & 0xEFFFFFFF) + ((register_object.initFltEn & 0x1) << 28)
        reg = (reg & 0xFF00FFFF) + ((register_object.telemRetries & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.trimRetries & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.initRetries & 0xFF)
        dma(self.address, 0xEA, reg)
    ## Set MCUTEMPFLT fault after retries fail when starting auto-zero.
    def azFltEn(self, value = None):
        value = dma_bits(0xEA, self.address, 1, 31, value)
        return(value)
    ## Set MCUTEMPFLT fault after retries fail when requesting telemetry.
    def telemRqstFlten(self, value = None):
        value = dma_bits(0xEA, self.address, 1, 30, value)
        return(value)
    ## Set MCUTEMPFLT fault after retries fail while reading trim data.
    def trimDataFltEn(self, value = None):
        value = dma_bits(0xEA, self.address, 1, 29, value)
        return(value)
    ## Set MCUTEMPFLT fault after retries fail at initialization.
    def initFltEn(self, value = None):
        value = dma_bits(0xEA, self.address, 1, 28, value)
        return(value)
    ## Retry count for requesting temperature telemetry before setting fault.
    def telemRetries(self, value = None):
        value = dma_bits(0xEA, self.address, 8, 16, value)
        return(value)
    ## Retry count for Reading Owl trim data.
    def trimRetries(self, value = None):
        value = dma_bits(0xEA, self.address, 8, 8, value)
        return(value)
    ## Retry count for Owl initialization including autozero.
    def initRetries(self, value = None):
        value = dma_bits(0xEA, self.address, 8, 0, value)
        return(value)

###################################################################
## SDIF Fault Policy Configuration
###################################################################
class rSDIFFACCFG_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEB, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rSDIFFACCFG_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEB, None)
            self.sdifSysPwrRdsOnEn = (self.reg_value >> 9) & 0x1
            self.sdifSysPwrTempThresh = (self.reg_value >> 4) & 0x1F
            self.sdifCfgAzClkDiv = (self.reg_value >> 2) & 0x3
            self.sdifCfgClkDiv = self.reg_value & 0x3

    def read_object(self):
        return(self.rSDIFFACCFG_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFDFF) + ((register_object.sdifSysPwrRdsOnEn & 0x1) << 9)
        reg = (reg & 0xFFFFFE0F) + ((register_object.sdifSysPwrTempThresh & 0x1F) << 4)
        reg = (reg & 0xFFFFFFF3) + ((register_object.sdifCfgAzClkDiv & 0x3) << 2)
        reg = (reg & 0xFFFFFFFC) + (register_object.sdifCfgClkDiv & 0x3)
        dma(self.address, 0xEB, reg)
    ## Allow RdsOn updates during PS4 exit.
    def sdifSysPwrRdsOnEn(self, value = None):
        value = dma_bits(0xEB, self.address, 1, 9, value)
        return(value)
    ## Temperature difference threshold for updating Owl RdsOn based on internal temp during PS4 exit.
    def sdifSysPwrTempThresh(self, value = None):
        value = dma_bits(0xEB, self.address, 5, 4, value)
        return(value)
    ## SDIFCFG autozero clock divider written by FW to HW.
    def sdifCfgAzClkDiv(self, value = None):
        value = dma_bits(0xEB, self.address, 2, 2, value)
        return(value)
    ## SDIFCFG clock divider written by FW to HW.
    def sdifCfgClkDiv(self, value = None):
        value = dma_bits(0xEB, self.address, 2, 0, value)
        return(value)

###################################################################
## Factory digital pin mapping 0
###################################################################
class rFACDIOMAP0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEC, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACDIOMAP0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEC, None)
            self.vccInAux1FromDio = (self.reg_value >> 28) & 0xF
            self.vccInAux0FromDio = (self.reg_value >> 24) & 0xF
            self.sdifDatFromDio = (self.reg_value >> 20) & 0xF
            self.sdifClkFromDio = (self.reg_value >> 16) & 0xF
            self.rstlFromDio = (self.reg_value >> 12) & 0xF
            self.en2FromDio = (self.reg_value >> 8) & 0xF
            self.en1FromDio = (self.reg_value >> 4) & 0xF
            self.en0FromDio = self.reg_value & 0xF

    def read_object(self):
        return(self.rFACDIOMAP0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.vccInAux1FromDio & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.vccInAux0FromDio & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.sdifDatFromDio & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.sdifClkFromDio & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.rstlFromDio & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.en2FromDio & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.en1FromDio & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.en0FromDio & 0xF)
        dma(self.address, 0xEC, reg)
    ## Get VCCIN_AUX[1] (GPIO3) signal from DIO0-11, 15=none
    def vccInAux1FromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 28, value)
        return(value)
    ## Get VCCIN_AUX[0] (GPIO2) signal from DIO0-11, 15=none
    def vccInAux0FromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 24, value)
        return(value)
    ## Get SDIF_DAT (GPIO5) signal from DIO0-11, 15=none
    def sdifDatFromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 20, value)
        return(value)
    ## Get SDIF_CLK (GPIO4) signal from DIO0-11, 15=none
    def sdifClkFromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 16, value)
        return(value)
    ## Get RESET_L (GPIO1) signal from DIO0-11, 15=none
    def rstlFromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 12, value)
        return(value)
    ## Get EN2 signal from DIO0-11, 15=none
    def en2FromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 8, value)
        return(value)
    ## Get EN1 signal from DIO0-11, 15=none
    def en1FromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 4, value)
        return(value)
    ## Get EN0 signal from DIO0-11, 15=none
    def en0FromDio(self, value = None):
        value = dma_bits(0xEC, self.address, 4, 0, value)
        return(value)

###################################################################
## Factory digital pin mapping 1
###################################################################
class rFACDIOMAP1_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xED, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACDIOMAP1_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xED, None)
            self.pg2ToDio = (self.reg_value >> 28) & 0xF
            self.pg1ToDio = (self.reg_value >> 24) & 0xF
            self.pg0ToDio = (self.reg_value >> 20) & 0xF
            self.mfp4ToDio = (self.reg_value >> 16) & 0xF
            self.mfp3ToDio = (self.reg_value >> 12) & 0xF
            self.mfp2ToDio = (self.reg_value >> 8) & 0xF
            self.mfp1ToDio = (self.reg_value >> 4) & 0xF
            self.mfp0ToDio = self.reg_value & 0xF

    def read_object(self):
        return(self.rFACDIOMAP1_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFFF) + ((register_object.pg2ToDio & 0xF) << 28)
        reg = (reg & 0xF0FFFFFF) + ((register_object.pg1ToDio & 0xF) << 24)
        reg = (reg & 0xFF0FFFFF) + ((register_object.pg0ToDio & 0xF) << 20)
        reg = (reg & 0xFFF0FFFF) + ((register_object.mfp4ToDio & 0xF) << 16)
        reg = (reg & 0xFFFF0FFF) + ((register_object.mfp3ToDio & 0xF) << 12)
        reg = (reg & 0xFFFFF0FF) + ((register_object.mfp2ToDio & 0xF) << 8)
        reg = (reg & 0xFFFFFF0F) + ((register_object.mfp1ToDio & 0xF) << 4)
        reg = (reg & 0xFFFFFFF0) + (register_object.mfp0ToDio & 0xF)
        dma(self.address, 0xED, reg)
    ## Send PG2 function to DIO0-11, 15=none
    def pg2ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 28, value)
        return(value)
    ## Send PG1 function to DIO0-11, 15=none
    def pg1ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 24, value)
        return(value)
    ## Send PG0 function to DIO0-11, 15=none
    def pg0ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 20, value)
        return(value)
    ## Send MFP4 (typ. spare) function to DIO0-11, 15=none
    def mfp4ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 16, value)
        return(value)
    ## Send MFP3 (typ. CFP/P2CL) function to DIO0-11, 15=none
    def mfp3ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 12, value)
        return(value)
    ## Send MFP2 (typ. nPMALERT/DR_EN) function to DIO0-11, 15=none
    def mfp2ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 8, value)
        return(value)
    ## Send MFP1 (typ. nVRHOT/OCP_L) function to DIO0-11, 15=none
    def mfp1ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 4, value)
        return(value)
    ## Send MFP0 (typ. nPinAlert/nPsysCrit) function to DIO0-11, 15=none
    def mfp0ToDio(self, value = None):
        value = dma_bits(0xED, self.address, 4, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENGAINTRIM01_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEE, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENGAINTRIM01_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEE, None)
            self.isenGain1 = (self.reg_value >> 16) & 0xFFFF
            self.isenGain0 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENGAINTRIM01_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.isenGain1 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.isenGain0 & 0xFFFF)
        dma(self.address, 0xEE, reg)
    ## Isen Gain Trim for Isen ADC 1.
    def isenGain1(self, value = None):
        value = dma_bits(0xEE, self.address, 16, 16, value)
        return(value)
    ## Isen Gain Trim for Isen ADC 0.
    def isenGain0(self, value = None):
        value = dma_bits(0xEE, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rISENGAINTRIM23_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xEF, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rISENGAINTRIM23_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xEF, None)
            self.isenGain3 = (self.reg_value >> 16) & 0xFFFF
            self.isenGain2 = self.reg_value & 0xFFFF

    def read_object(self):
        return(self.rISENGAINTRIM23_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFF) + ((register_object.isenGain3 & 0xFFFF) << 16)
        reg = (reg & 0xFFFF0000) + (register_object.isenGain2 & 0xFFFF)
        dma(self.address, 0xEF, reg)
    ## Isen Gain Trim for Isen ADC 3.
    def isenGain3(self, value = None):
        value = dma_bits(0xEF, self.address, 16, 16, value)
        return(value)
    ## Isen Gain Trim for Isen ADC 2.
    def isenGain2(self, value = None):
        value = dma_bits(0xEF, self.address, 16, 0, value)
        return(value)

###################################################################
## 
###################################################################
class rPHADCOFFTRIM_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xF0, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rPHADCOFFTRIM_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xF0, None)
            self.offsetIsenAdc3 = (self.reg_value >> 24) & 0xFF
            self.offsetIsenAdc2 = (self.reg_value >> 16) & 0xFF
            self.offsetIsenAdc1 = (self.reg_value >> 8) & 0xFF
            self.offsetIsenAdc0 = self.reg_value & 0xFF

    def read_object(self):
        return(self.rPHADCOFFTRIM_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFFFFFF) + ((register_object.offsetIsenAdc3 & 0xFF) << 24)
        reg = (reg & 0xFF00FFFF) + ((register_object.offsetIsenAdc2 & 0xFF) << 16)
        reg = (reg & 0xFFFF00FF) + ((register_object.offsetIsenAdc1 & 0xFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.offsetIsenAdc0 & 0xFF)
        dma(self.address, 0xF0, reg)
    ## Offset trim for Isen ADC 3.
    def offsetIsenAdc3(self, value = None):
        value = dma_bits(0xF0, self.address, 8, 24, value)
        return(value)
    ## Offset trim for Isen ADC 2.
    def offsetIsenAdc2(self, value = None):
        value = dma_bits(0xF0, self.address, 8, 16, value)
        return(value)
    ## Offset trim for Isen ADC 1.
    def offsetIsenAdc1(self, value = None):
        value = dma_bits(0xF0, self.address, 8, 8, value)
        return(value)
    ## Offset trim for Isen ADC 0.
    def offsetIsenAdc0(self, value = None):
        value = dma_bits(0xF0, self.address, 8, 0, value)
        return(value)

###################################################################
## RAM Factory Spare Register 0
###################################################################
class rFACSPARE0_class(object):
    def __init__(self, address):
        self.interface = 'ramF'
        self.address = address
        self.bits = 32

    def __call__(self, value = None):
        value = dma(self.address, 0xF1, value)
        return(value)

    #  Object class used to read the register one time and
    #  fill in all of the bit fields.
    class rFACSPARE0_Object:
        def __init__(self, i2c_address):
            self.reg_value = dma(i2c_address, 0xF1, None)
            self.spare0 = (self.reg_value >> 8) & 0xFFFFFF
            self.vsysLvlOffset = self.reg_value & 0xFF

    def read_object(self):
        return(self.rFACSPARE0_Object(self.address))

    def write_object(self, register_object):
        reg = 0
        reg = (reg & 0xFF) + ((register_object.spare0 & 0xFFFFFF) << 8)
        reg = (reg & 0xFFFFFF00) + (register_object.vsysLvlOffset & 0xFF)
        dma(self.address, 0xF1, reg)
    def spare0(self, value = None):
        value = dma_bits(0xF1, self.address, 24, 8, value)
        return(value)
    ## Vsys limit msb/xsb/lsb conversion offset
    def vsysLvlOffset(self, value = None):
        value = dma_bits(0xF1, self.address, 8, 0, value)
        return(value)

##############################################
#
##############################################
class create(object):
    def __init__(self, address):
        self.address = address
        
        self.page = page_class(self.address)
        self.oper = oper_class(self.address)
        self.onOff = onOff_class(self.address)
        self.clearFault = clearFault_class(self.address)
        self.phase = phase_class(self.address)
        self.pagePlusWr = pagePlusWr_class(self.address)
        self.pagePlusRd = pagePlusRd_class(self.address)
        self.zoneConfig = zoneConfig_class(self.address)
        self.zoneActive = zoneActive_class(self.address)
        self.wrtProt = wrtProt_class(self.address)
        self.strUsrAll = strUsrAll_class(self.address)
        self.rstUsrAll = rstUsrAll_class(self.address)
        self.capability = capability_class(self.address)
        self.smbAlrtMask = smbAlrtMask_class(self.address)
        self.voutMode = voutMode_class(self.address)
        self.voutCmd = voutCmd_class(self.address)
        self.voutTrim = voutTrim_class(self.address)
        self.voutCalOff = voutCalOff_class(self.address)
        self.voutMax = voutMax_class(self.address)
        self.voutMargHi = voutMargHi_class(self.address)
        self.voutMargLo = voutMargLo_class(self.address)
        self.slewRate = slewRate_class(self.address)
        self.droop = droop_class(self.address)
        self.voutMin = voutMin_class(self.address)
        self.freqSw = freqSw_class(self.address)
        self.powerMode = powerMode_class(self.address)
        self.vinOn = vinOn_class(self.address)
        self.vinOff = vinOff_class(self.address)
        self.oovLimit = oovLimit_class(self.address)
        self.oovResp = oovResp_class(self.address)
        self.ouvLimit = ouvLimit_class(self.address)
        self.ouvResp = ouvResp_class(self.address)
        self.oocLimit = oocLimit_class(self.address)
        self.oocResp = oocResp_class(self.address)
        self.oocWarnLimit = oocWarnLimit_class(self.address)
        self.otfLimit = otfLimit_class(self.address)
        self.otfResp = otfResp_class(self.address)
        self.otwLimit = otwLimit_class(self.address)
        self.utfLimit = utfLimit_class(self.address)
        self.utfResp = utfResp_class(self.address)
        self.iovLimit = iovLimit_class(self.address)
        self.iovResp = iovResp_class(self.address)
        self.iovWarnLimit = iovWarnLimit_class(self.address)
        self.iuvWarnLimit = iuvWarnLimit_class(self.address)
        self.iuvLimit = iuvLimit_class(self.address)
        self.iuvResp = iuvResp_class(self.address)
        self.iocLimit = iocLimit_class(self.address)
        self.iocResp = iocResp_class(self.address)
        self.iocWarnLimit = iocWarnLimit_class(self.address)
        self.tOnDelay = tOnDelay_class(self.address)
        self.tOnRise = tOnRise_class(self.address)
        self.tOffDelay = tOffDelay_class(self.address)
        self.tOffFall = tOffFall_class(self.address)
        self.statusByte = statusByte_class(self.address)
        self.statusWord = statusWord_class(self.address)
        self.statusVout = statusVout_class(self.address)
        self.statusIout = statusIout_class(self.address)
        self.statusInput = statusInput_class(self.address)
        self.statusTemp = statusTemp_class(self.address)
        self.statusCml = statusCml_class(self.address)
        self.statusMfr = statusMfr_class(self.address)
        self.rdVin = rdVin_class(self.address)
        self.rdIin = rdIin_class(self.address)
        self.rdVout = rdVout_class(self.address)
        self.rdIout = rdIout_class(self.address)
        self.rdDrTemp = rdDrTemp_class(self.address)
        self.rdCtlTemp = rdCtlTemp_class(self.address)
        self.rdAmbTemp = rdAmbTemp_class(self.address)
        self.rdPout = rdPout_class(self.address)
        self.rdPin = rdPin_class(self.address)
        self.pmbRev = pmbRev_class(self.address)
        self.mfrID = mfrID_class(self.address)
        self.mfrMod = mfrMod_class(self.address)
        self.mfrRev = mfrRev_class(self.address)
        self.mfrDate = mfrDate_class(self.address)
        self.appProfile = appProfile_class(self.address)
        self.icDevId = icDevId_class(self.address)
        self.icDevRev = icDevRev_class(self.address)
        self.userData0 = userData0_class(self.address)
        self.userData1 = userData1_class(self.address)
        self.dmaFix = dmaFix_class(self.address)
        self.dmaSeq = dmaSeq_class(self.address)
        self.dmaAddr = dmaAddr_class(self.address)
        self.rdIinSen0 = rdIinSen0_class(self.address)
        self.rdIinSen1 = rdIinSen1_class(self.address)
        self.siocResp1 = siocResp1_class(self.address)
        self.siocLimit1 = siocLimit1_class(self.address)
        self.bootRate = bootRate_class(self.address)
        self.peakOcLimit = peakOcLimit_class(self.address)
        self.peakUcLimit = peakUcLimit_class(self.address)
        self.vddMonOn = vddMonOn_class(self.address)
        self.vddMonOff = vddMonOff_class(self.address)
        self.rdVinSen0 = rdVinSen0_class(self.address)
        self.rdVinSen1 = rdVinSen1_class(self.address)
        self.rdVoutTele = rdVoutTele_class(self.address)
        self.voutAdj = voutAdj_class(self.address)
        self.password = password_class(self.address)
        self.siocResp0 = siocResp0_class(self.address)
        self.droopAdj = droopAdj_class(self.address)
        self.siocLimit0 = siocLimit0_class(self.address)
        self.ioutEvent = ioutEvent_class(self.address)
        self.rdSumIin0 = rdSumIin0_class(self.address)
        self.rdSumIin1 = rdSumIin1_class(self.address)
        self.compProp = compProp_class(self.address)
        self.compInteg = compInteg_class(self.address)
        self.compDiff = compDiff_class(self.address)
        self.compCFB = compCFB_class(self.address)
        self.railDebug = railDebug_class(self.address)
        self.pwrMode = pwrMode_class(self.address)
        self.hsBusCurScale = hsBusCurScale_class(self.address)
        self.phCurr = phCurr_class(self.address)
        self.phTemp = phTemp_class(self.address)
        self.mcuCmd0 = mcuCmd0_class(self.address)
        self.mcuCmd1 = mcuCmd1_class(self.address)
        self.peakOcUcCount = peakOcUcCount_class(self.address)
        self.slowOcLimit = slowOcLimit_class(self.address)
        self.fastOcFiltCount = fastOcFiltCount_class(self.address)
        self.slowOcFiltCount = slowOcFiltCount_class(self.address)
        self.lmsCfg = lmsCfg_class(self.address)
        self.svidAddr = svidAddr_class(self.address)
        self.pmbSvidVboot = pmbSvidVboot_class(self.address)
        self.loopCfg = loopCfg_class(self.address)
        self.storeCfg = storeCfg_class(self.address)
        self.restoreCfg = restoreCfg_class(self.address)
        self.slaveAddr = slaveAddr_class(self.address)
        self.baseCfg = baseCfg_class(self.address)
        self.voutPeak = voutPeak_class(self.address)
        self.voutLow = voutLow_class(self.address)
        self.ioutPeak = ioutPeak_class(self.address)
        self.ioutOffset = ioutOffset_class(self.address)
        self.inPwrOffset = inPwrOffset_class(self.address)
        self.psvid = psvid_class(self.address)
        self.ioutPkVout = ioutPkVout_class(self.address)
        self.avsVout = avsVout_class(self.address)
        self.avsVoutTrans = avsVoutTrans_class(self.address)
        self.avsTelIoutMcu = avsTelIoutMcu_class(self.address)
        self.avsTempDrMcu = avsTempDrMcu_class(self.address)
        self.avsRstRailVolt = avsRstRailVolt_class(self.address)
        self.avsPowerMode = avsPowerMode_class(self.address)
        self.avs6hx = avs6hx_class(self.address)
        self.avs7hx = avs7hx_class(self.address)
        self.avs8hx = avs8hx_class(self.address)
        self.avs9hx = avs9hx_class(self.address)
        self.avsAhx = avsAhx_class(self.address)
        self.avsBhx = avsBhx_class(self.address)
        self.avsChx = avsChx_class(self.address)
        self.avsDhx = avsDhx_class(self.address)
        self.avsBusStatus = avsBusStatus_class(self.address)
        self.avsBusVersion = avsBusVersion_class(self.address)
        self.phTemp0 = phTemp0_class(self.address)
        self.phTemp1 = phTemp1_class(self.address)
        self.phTemp2 = phTemp2_class(self.address)
        self.phTemp3 = phTemp3_class(self.address)
        self.phTemp4 = phTemp4_class(self.address)
        self.phTemp5 = phTemp5_class(self.address)
        self.phTemp6 = phTemp6_class(self.address)
        self.phTemp7 = phTemp7_class(self.address)
        self.voutAdjBuf0 = voutAdjBuf0_class(self.address)
        self.voutAdjBuf1 = voutAdjBuf1_class(self.address)
        self.voutAdjBuf2 = voutAdjBuf2_class(self.address)
        self.droopAdjBuf0 = droopAdjBuf0_class(self.address)
        self.droopAdjBuf1 = droopAdjBuf1_class(self.address)
        self.droopAdjBuf2 = droopAdjBuf2_class(self.address)
        self.svidSlewTtBuf0 = svidSlewTtBuf0_class(self.address)
        self.svidSlewTtBuf1 = svidSlewTtBuf1_class(self.address)
        self.svidSlewTtBuf2 = svidSlewTtBuf2_class(self.address)
        self.nvmOcpThresh0 = nvmOcpThresh0_class(self.address)
        self.nvmOcpThresh1 = nvmOcpThresh1_class(self.address)
        self.nvmOcpThresh2 = nvmOcpThresh2_class(self.address)
        self.nvmOcpWarnThresh0 = nvmOcpWarnThresh0_class(self.address)
        self.nvmOcpWarnThresh1 = nvmOcpWarnThresh1_class(self.address)
        self.nvmOcpWarnThresh2 = nvmOcpWarnThresh2_class(self.address)
        self.nvmOcpWnMnPlsFtDl0 = nvmOcpWnMnPlsFtDl0_class(self.address)
        self.nvmOcpWnMnPlsFtDl1 = nvmOcpWnMnPlsFtDl1_class(self.address)
        self.nvmOcpWnMnPlsFtDl2 = nvmOcpWnMnPlsFtDl2_class(self.address)
        self.svidReg0FBuf0 = svidReg0FBuf0_class(self.address)
        self.vrReady0vBuf0 = vrReady0vBuf0_class(self.address)
        self.svidReg30Buf0 = svidReg30Buf0_class(self.address)
        self.extPhShedCtrlBuf0 = extPhShedCtrlBuf0_class(self.address)
        self.extNegVrEnRespBuf0 = extNegVrEnRespBuf0_class(self.address)
        self.svidReg0FBuf1 = svidReg0FBuf1_class(self.address)
        self.vrReady0vBuf1 = vrReady0vBuf1_class(self.address)
        self.svidReg30Buf1 = svidReg30Buf1_class(self.address)
        self.extPhShedCtrlBuf1 = extPhShedCtrlBuf1_class(self.address)
        self.extNegVrEnRespBuf1 = extNegVrEnRespBuf1_class(self.address)
        self.svidReg0FBuf2 = svidReg0FBuf2_class(self.address)
        self.vrReady0vBuf2 = vrReady0vBuf2_class(self.address)
        self.svidReg30Buf2 = svidReg30Buf2_class(self.address)
        self.extPhShedCtrlBuf2 = extPhShedCtrlBuf2_class(self.address)
        self.extNegVrEnRespBuf2 = extNegVrEnRespBuf2_class(self.address)
        self.svidReg0FBuf3 = svidReg0FBuf3_class(self.address)
        self.vrReady0vBuf3 = vrReady0vBuf3_class(self.address)
        self.svidReg2aBuf0 = svidReg2aBuf0_class(self.address)
        self.svidReg2aBuf1 = svidReg2aBuf1_class(self.address)
        self.svidReg2aBuf2 = svidReg2aBuf2_class(self.address)
        self.watchCnt = watchCnt_class(self.address)
        self.watchCtrl = watchCtrl_class(self.address)
        self.irqTest = irqTest_class(self.address)
        self.irqTestTrig = irqTestTrig_class(self.address)
        self.pmbLastCmd = pmbLastCmd_class(self.address)
        self.gpioAck = gpioAck_class(self.address)
        self.gpioIntCtrl = gpioIntCtrl_class(self.address)
        self.gpioCtrl = gpioCtrl_class(self.address)
        self.ringCtrl = ringCtrl_class(self.address)
        self.tunnelCmd = tunnelCmd_class(self.address)
        self.tunnelData = tunnelData_class(self.address)
        self.gpioCtrlB = gpioCtrlB_class(self.address)
        self.svi3CrcEn = svi3CrcEn_class(self.address)
        self.nvmSvi3CrcEn = nvmSvi3CrcEn_class(self.address)
        self.statusTest0 = statusTest0_class(self.address)
        self.statusTest1 = statusTest1_class(self.address)
        self.statusTest2 = statusTest2_class(self.address)
        self.statusTestCom = statusTestCom_class(self.address)
        self.AccessAddrStatus = AccessAddrStatus_class(self.address)
        self.tmSel = tmSel_class(self.address)
        self.tmCfg1 = tmCfg1_class(self.address)
        self.tmCfg2 = tmCfg2_class(self.address)
        self.tmEna = tmEna_class(self.address)
        self.addressTrigger = addressTrigger_class(self.address)
        self.storedPw = storedPw_class(self.address)
        self.serialLogA = serialLogA_class(self.address)
        self.serialLogB = serialLogB_class(self.address)
        self.serialLogC = serialLogC_class(self.address)
        self.pmbLogA = pmbLogA_class(self.address)
        self.pmbLogB = pmbLogB_class(self.address)
        self.encryptedPw = encryptedPw_class(self.address)
        self.pwLockStatus = pwLockStatus_class(self.address)
        self.avsMfrSpcfcSetting = avsMfrSpcfcSetting_class(self.address)
        self.avsMfrSpcfcReg = avsMfrSpcfcReg_class(self.address)
        self.svi2Reg0 = svi2Reg0_class(self.address)
        self.svi2Reg1 = svi2Reg1_class(self.address)
        self.svi2Cfg = svi2Cfg_class(self.address)
        self.svi2CV = svi2CV_class(self.address)
        self.svi2CI = svi2CI_class(self.address)
        self.svi2GV = svi2GV_class(self.address)
        self.svi2GI = svi2GI_class(self.address)
        self.vendorId = vendorId_class(self.address)
        self.prodId = prodId_class(self.address)
        self.prodRev = prodRev_class(self.address)
        self.prodDate = prodDate_class(self.address)
        self.prodLot = prodLot_class(self.address)
        self.protocolId = protocolId_class(self.address)
        self.vrCapability = vrCapability_class(self.address)
        self.svidStepSize = svidStepSize_class(self.address)
        self.svidOffsetVID = svidOffsetVID_class(self.address)
        self.svidVIDOMAXH = svidVIDOMAXH_class(self.address)
        self.svidVIDOMAXL = svidVIDOMAXL_class(self.address)
        self.svidVinFFH = svidVinFFH_class(self.address)
        self.svidVinFFL = svidVinFFL_class(self.address)
        self.svidVoutFFH = svidVoutFFH_class(self.address)
        self.svidVoutFFL = svidVoutFFL_class(self.address)
        self.svidAllCallResp = svidAllCallResp_class(self.address)
        self.svidStatus1Lp = svidStatus1Lp_class(self.address)
        self.svidStatus2Lp = svidStatus2Lp_class(self.address)
        self.svidTempZone = svidTempZone_class(self.address)
        self.pmicGblStatus = pmicGblStatus_class(self.address)
        self.lastReadLp = lastReadLp_class(self.address)
        self.svidIout = svidIout_class(self.address)
        self.svidVout = svidVout_class(self.address)
        self.svidVrTemp = svidVrTemp_class(self.address)
        self.svidPout = svidPout_class(self.address)
        self.svidIin = svidIin_class(self.address)
        self.svidVin = svidVin_class(self.address)
        self.svidPin = svidPin_class(self.address)
        self.svidStatus2Last = svidStatus2Last_class(self.address)
        self.cfgFileId = cfgFileId_class(self.address)
        self.cycToCycLimit = cycToCycLimit_class(self.address)
        self.svidIccInMax = svidIccInMax_class(self.address)
        self.svidIccMax = svidIccMax_class(self.address)
        self.svidTempMax = svidTempMax_class(self.address)
        self.svidDcLl = svidDcLl_class(self.address)
        self.svidSrFast = svidSrFast_class(self.address)
        self.svidSrSlow = svidSrSlow_class(self.address)
        self.svidVboot = svidVboot_class(self.address)
        self.svidVrTol = svidVrTol_class(self.address)
        self.svidSlSlSel = svidSlSlSel_class(self.address)
        self.svidPs4ExLat = svidPs4ExLat_class(self.address)
        self.svidPs3ExLat = svidPs3ExLat_class(self.address)
        self.svidEnToSvid = svidEnToSvid_class(self.address)
        self.svidPinMax = svidPinMax_class(self.address)
        self.svidPinAlrtThrsh = svidPinAlrtThrsh_class(self.address)
        self.svidVoutMax = svidVoutMax_class(self.address)
        self.svidVidSet = svidVidSet_class(self.address)
        self.svidPsLp = svidPsLp_class(self.address)
        self.svidOffset = svidOffset_class(self.address)
        self.svidMultiVR = svidMultiVR_class(self.address)
        self.svidScratch = svidScratch_class(self.address)
        self.dcLlFine = dcLlFine_class(self.address)
        self.trkVid = trkVid_class(self.address)
        self.svidWP0Lp = svidWP0Lp_class(self.address)
        self.svidWP1Lp = svidWP1Lp_class(self.address)
        self.svidWP2Lp = svidWP2Lp_class(self.address)
        self.svidWP3Lp = svidWP3Lp_class(self.address)
        self.svidWP4Lp = svidWP4Lp_class(self.address)
        self.svidWP5Lp = svidWP5Lp_class(self.address)
        self.svidWP6Lp = svidWP6Lp_class(self.address)
        self.svidWP7Lp = svidWP7Lp_class(self.address)
        self.svidIVID1V = svidIVID1V_class(self.address)
        self.svidIVID1I = svidIVID1I_class(self.address)
        self.svidIVID2V = svidIVID2V_class(self.address)
        self.svidIVID2I = svidIVID2I_class(self.address)
        self.svidIVID3V = svidIVID3V_class(self.address)
        self.svidIVID3I = svidIVID3I_class(self.address)
        self.extCapability1Lp = extCapability1Lp_class(self.address)
        self.extCapability2Lp = extCapability2Lp_class(self.address)
        self.extCapability3Lp = extCapability3Lp_class(self.address)
        self.extPhShedCtrl = extPhShedCtrl_class(self.address)
        self.extNegVrEnCtrl = extNegVrEnCtrl_class(self.address)
        self.extNegVrEnResp = extNegVrEnResp_class(self.address)
        self.digOutStatus = digOutStatus_class(self.address)
        self.wpSlew0 = wpSlew0_class(self.address)
        self.wpSlew1 = wpSlew1_class(self.address)
        self.wpSlew2 = wpSlew2_class(self.address)
        self.wpSlew3 = wpSlew3_class(self.address)
        self.wpSlewTt = wpSlewTt_class(self.address)
        self.cycToCycEvntCnt = cycToCycEvntCnt_class(self.address)
        self.imonCapability = imonCapability_class(self.address)
        self.imonRequest = imonRequest_class(self.address)
        self.imonCurrentA = imonCurrentA_class(self.address)
        self.imonCurrentB = imonCurrentB_class(self.address)
        self.imonCalStatus = imonCalStatus_class(self.address)
        self.expAccuracy = expAccuracy_class(self.address)
        self.svidIoutL = svidIoutL_class(self.address)
        self.svidVoutL = svidVoutL_class(self.address)
        self.svidPoutL = svidPoutL_class(self.address)
        self.svidIinL = svidIinL_class(self.address)
        self.svidVinL = svidVinL_class(self.address)
        self.svidPinL = svidPinL_class(self.address)
        self.vendorId3 = vendorId3_class(self.address)
        self.prodId3 = prodId3_class(self.address)
        self.prodRev3 = prodRev3_class(self.address)
        self.prodDate3 = prodDate3_class(self.address)
        self.prodLot3 = prodLot3_class(self.address)
        self.protocolId3 = protocolId3_class(self.address)
        self.vrCapabilityLp3 = vrCapabilityLp3_class(self.address)
        self.svidVIDOMAXHLp3 = svidVIDOMAXHLp3_class(self.address)
        self.svidVinFFHLp3 = svidVinFFHLp3_class(self.address)
        self.svidVinFFLLp3 = svidVinFFLLp3_class(self.address)
        self.svidAllCallRespLp3 = svidAllCallRespLp3_class(self.address)
        self.svidStatus1Lp3 = svidStatus1Lp3_class(self.address)
        self.svidStatus2Lp3 = svidStatus2Lp3_class(self.address)
        self.lastReadPsys = lastReadPsys_class(self.address)
        self.svidIout3 = svidIout3_class(self.address)
        self.svidIin3 = svidIin3_class(self.address)
        self.svidVin3 = svidVin3_class(self.address)
        self.svidPin3 = svidPin3_class(self.address)
        self.svidStatus2Last0D = svidStatus2Last0D_class(self.address)
        self.svidIccInMax3 = svidIccInMax3_class(self.address)
        self.svidIccMax3 = svidIccMax3_class(self.address)
        self.svidPinMax3 = svidPinMax3_class(self.address)
        self.svidPinAlrtThrsh3 = svidPinAlrtThrsh3_class(self.address)
        self.svidPsLp3 = svidPsLp3_class(self.address)
        self.svidMultiVR3 = svidMultiVR3_class(self.address)
        self.svidScratch3 = svidScratch3_class(self.address)
        self.psysDebDeassert = psysDebDeassert_class(self.address)
        self.psysCritLvl3 = psysCritLvl3_class(self.address)
        self.psysWarn2lvl3 = psysWarn2lvl3_class(self.address)
        self.psysWarn1lvl3 = psysWarn1lvl3_class(self.address)
        self.psysWarn2cnt3 = psysWarn2cnt3_class(self.address)
        self.psysWarn1cnt3 = psysWarn1cnt3_class(self.address)
        self.psysDebAssert = psysDebAssert_class(self.address)
        self.svidExtCap1Lp3 = svidExtCap1Lp3_class(self.address)
        self.svidExtCap2Lp3 = svidExtCap2Lp3_class(self.address)
        self.digOutStatus3 = digOutStatus3_class(self.address)
        self.svidExpAccuracy = svidExpAccuracy_class(self.address)
        self.svidIoutL3 = svidIoutL3_class(self.address)
        self.svidIinL3 = svidIinL3_class(self.address)
        self.svidVinL3 = svidVinL3_class(self.address)
        self.svidPinL3 = svidPinL3_class(self.address)
        self.psysCritLvlL3 = psysCritLvlL3_class(self.address)
        self.psysWarn2LvlL3 = psysWarn2LvlL3_class(self.address)
        self.psysWarn1LvlL3 = psysWarn1LvlL3_class(self.address)
        self.chXCtl = chXCtl_class(self.address)
        self.pwrEn0 = pwrEn0_class(self.address)
        self.comRefTrim = comRefTrim_class(self.address)
        self.otpCtrl1 = otpCtrl1_class(self.address)
        self.comClkTrim1 = comClkTrim1_class(self.address)
        self.extTmpTrim = extTmpTrim_class(self.address)
        self.comRefBgSwC = comRefBgSwC_class(self.address)
        self.tmpTrim = tmpTrim_class(self.address)
        self.dllClkTrim = dllClkTrim_class(self.address)
        self.dllPwmTrim = dllPwmTrim_class(self.address)
        self.dllData = dllData_class(self.address)
        self.vinIinFiltTrim = vinIinFiltTrim_class(self.address)
        self.svidTrim = svidTrim_class(self.address)
        self.vSenMode = vSenMode_class(self.address)
        self.telMode = telMode_class(self.address)
        self.phXIsenMode = phXIsenMode_class(self.address)
        self.phCnvt8 = phCnvt8_class(self.address)
        self.vSenTrim = vSenTrim_class(self.address)
        self.telTrim = telTrim_class(self.address)
        self.iSenTrim = iSenTrim_class(self.address)
        self.telPsysCrit = telPsysCrit_class(self.address)
        self.telPsysWarn = telPsysWarn_class(self.address)
        self.vSenTest = vSenTest_class(self.address)
        self.adcTest = adcTest_class(self.address)
        self.phIsenValue = phIsenValue_class(self.address)
        self.phIsenMask = phIsenMask_class(self.address)
        self.telAdcTrim = telAdcTrim_class(self.address)
        self.telByteTrim = telByteTrim_class(self.address)
        self.telDacTrim = telDacTrim_class(self.address)
        self.vSenDigOffset = vSenDigOffset_class(self.address)
        self.selVinIinTref = selVinIinTref_class(self.address)
        self.comClkTest = comClkTest_class(self.address)
        self.telCfg = telCfg_class(self.address)
        self.ana1Shot = ana1Shot_class(self.address)
        self.telTest = telTest_class(self.address)
        self.iSenTest = iSenTest_class(self.address)
        self.testCtl = testCtl_class(self.address)
        self.anaClkLock = anaClkLock_class(self.address)
        self.anaIsenClip = anaIsenClip_class(self.address)
        self.atbSelMisc = atbSelMisc_class(self.address)
        self.testMisc = testMisc_class(self.address)
        self.atbSelCom = atbSelCom_class(self.address)
        self.atbSelAdc = atbSelAdc_class(self.address)
        self.atbSelIsenComp = atbSelIsenComp_class(self.address)
        self.atbSelIsen = atbSelIsen_class(self.address)
        self.atbMux = atbMux_class(self.address)
        self.pullDownCs = pullDownCs_class(self.address)
        self.pullDownPwm = pullDownPwm_class(self.address)
        self.pullDownA = pullDownA_class(self.address)
        self.vSen0Data = vSen0Data_class(self.address)
        self.vSen1Data = vSen1Data_class(self.address)
        self.vSen2Data = vSen2Data_class(self.address)
        self.iSen10Data = iSen10Data_class(self.address)
        self.iSen32Data = iSen32Data_class(self.address)
        self.pwrStatusAna = pwrStatusAna_class(self.address)
        self.pwrStatusAdc = pwrStatusAdc_class(self.address)
        self.psysStatus = psysStatus_class(self.address)
        self.statusVsenFlt = statusVsenFlt_class(self.address)
        self.vSen0CompMode = vSen0CompMode_class(self.address)
        self.vSen1CompMode = vSen1CompMode_class(self.address)
        self.vSen2CompMode = vSen2CompMode_class(self.address)
        self.telData = telData_class(self.address)
        self.iSenDacTrim = iSenDacTrim_class(self.address)
        self.phIsenAdcGain = phIsenAdcGain_class(self.address)
        self.vSenDacTrim = vSenDacTrim_class(self.address)
        self.vSenLpDacTrim = vSenLpDacTrim_class(self.address)
        self.vSenSarTrim = vSenSarTrim_class(self.address)
        self.chIsenCfg = chIsenCfg_class(self.address)
        self.vSenByteTrim = vSenByteTrim_class(self.address)
        self.utcMgr = utcMgr_class(self.address)
        self.utcFiltRst = utcFiltRst_class(self.address)
        self.utcTelTest = utcTelTest_class(self.address)
        self.sleepTemp = sleepTemp_class(self.address)
        self.vinSlotCfg = vinSlotCfg_class(self.address)
        self.iinSlotCfg = iinSlotCfg_class(self.address)
        self.temp0SlotCfg = temp0SlotCfg_class(self.address)
        self.temp1SlotCfg = temp1SlotCfg_class(self.address)
        self.temp2SlotCfg = temp2SlotCfg_class(self.address)
        self.vIntSlotCfg = vIntSlotCfg_class(self.address)
        self.intTempSlotCfg = intTempSlotCfg_class(self.address)
        self.extSlotCfg = extSlotCfg_class(self.address)
        self.azSlotCfg = azSlotCfg_class(self.address)
        self.azSlowCfg = azSlowCfg_class(self.address)
        self.utcPSSA = utcPSSA_class(self.address)
        self.utcPSSB = utcPSSB_class(self.address)
        self.utcASS1A = utcASS1A_class(self.address)
        self.utcASS1B = utcASS1B_class(self.address)
        self.utcASS2A = utcASS2A_class(self.address)
        self.utcASS2B = utcASS2B_class(self.address)
        self.utcESS = utcESS_class(self.address)
        self.utcPSSASLOW = utcPSSASLOW_class(self.address)
        self.utcPSSBSLOW = utcPSSBSLOW_class(self.address)
        self.utcASS1ASLOW = utcASS1ASLOW_class(self.address)
        self.utcASS1BSLOW = utcASS1BSLOW_class(self.address)
        self.utcASS2ASLOW = utcASS2ASLOW_class(self.address)
        self.utcASS2BSLOW = utcASS2BSLOW_class(self.address)
        self.utcESSSLOW = utcESSSLOW_class(self.address)
        self.filtVinTel0 = filtVinTel0_class(self.address)
        self.filtIinTel0 = filtIinTel0_class(self.address)
        self.filtVoutTel = filtVoutTel_class(self.address)
        self.filtIntTempTel = filtIntTempTel_class(self.address)
        self.filtTempTel0 = filtTempTel0_class(self.address)
        self.filtTempTel1 = filtTempTel1_class(self.address)
        self.filtTempTel2 = filtTempTel2_class(self.address)
        self.filtInternalTel = filtInternalTel_class(self.address)
        self.filtResTel = filtResTel_class(self.address)
        self.filtPinViTel = filtPinViTel_class(self.address)
        self.filtAzTel = filtAzTel_class(self.address)
        self.gainVinTel0 = gainVinTel0_class(self.address)
        self.gainIinTel0 = gainIinTel0_class(self.address)
        self.gainVoutTel0 = gainVoutTel0_class(self.address)
        self.gainVoutTel1 = gainVoutTel1_class(self.address)
        self.gainVoutTel2 = gainVoutTel2_class(self.address)
        self.gainPinViTel = gainPinViTel_class(self.address)
        self.gainVsysTel = gainVsysTel_class(self.address)
        self.gainIsysTel = gainIsysTel_class(self.address)
        self.gainPsysTel = gainPsysTel_class(self.address)
        self.gainHsVin = gainHsVin_class(self.address)
        self.offHsVin = offHsVin_class(self.address)
        self.gainHsIauxTel = gainHsIauxTel_class(self.address)
        self.gainExtTempTel0 = gainExtTempTel0_class(self.address)
        self.gainExtTempTel1 = gainExtTempTel1_class(self.address)
        self.gainExtTempTel2 = gainExtTempTel2_class(self.address)
        self.gainRes = gainRes_class(self.address)
        self.vin0DivBuffGainTel = vin0DivBuffGainTel_class(self.address)
        self.vin0BuffGainTel = vin0BuffGainTel_class(self.address)
        self.iin0BuffGainTel = iin0BuffGainTel_class(self.address)
        self.vddioBuffGainTel = vddioBuffGainTel_class(self.address)
        self.vin0DivBuffOffsetTel = vin0DivBuffOffsetTel_class(self.address)
        self.vin0BuffOffsetTel = vin0BuffOffsetTel_class(self.address)
        self.iin0BuffOffsetTel = iin0BuffOffsetTel_class(self.address)
        self.vddioBuffOffsetTel = vddioBuffOffsetTel_class(self.address)
        self.offVinTel0 = offVinTel0_class(self.address)
        self.offIinTel0 = offIinTel0_class(self.address)
        self.offTempTel0 = offTempTel0_class(self.address)
        self.offTempTel1 = offTempTel1_class(self.address)
        self.offTempTel2 = offTempTel2_class(self.address)
        self.offAddressTel = offAddressTel_class(self.address)
        self.offConfigTel = offConfigTel_class(self.address)
        self.hwBypass = hwBypass_class(self.address)
        self.mcuHsVin = mcuHsVin_class(self.address)
        self.mcuHsVsys = mcuHsVsys_class(self.address)
        self.mcuHsIsys = mcuHsIsys_class(self.address)
        self.mcuHsPsys = mcuHsPsys_class(self.address)
        self.mcuHsAuxImon = mcuHsAuxImon_class(self.address)
        self.mcuHsVout0 = mcuHsVout0_class(self.address)
        self.mcuHsVout1 = mcuHsVout1_class(self.address)
        self.mcuHsVout2 = mcuHsVout2_class(self.address)
        self.mcuHsIout0 = mcuHsIout0_class(self.address)
        self.mcuHsIout1 = mcuHsIout1_class(self.address)
        self.mcuHsIout2 = mcuHsIout2_class(self.address)
        self.mcuHsPout0 = mcuHsPout0_class(self.address)
        self.mcuHsPout1 = mcuHsPout1_class(self.address)
        self.mcuHsPout2 = mcuHsPout2_class(self.address)
        self.telIrqTicks = telIrqTicks_class(self.address)
        self.tConfig = tConfig_class(self.address)
        self.tCounterReload = tCounterReload_class(self.address)
        self.tStatus = tStatus_class(self.address)
        self.tCntVal = tCntVal_class(self.address)
        self.tTsCaptureMask = tTsCaptureMask_class(self.address)
        self.tTsCapture = tTsCapture_class(self.address)
        self.phaseTelTest = phaseTelTest_class(self.address)
        self.phaseTestData = phaseTestData_class(self.address)
        self.iSenRange0 = iSenRange0_class(self.address)
        self.iSenRange1 = iSenRange1_class(self.address)
        self.iSenRange2 = iSenRange2_class(self.address)
        self.filtIph = filtIph_class(self.address)
        self.filtVadc = filtVadc_class(self.address)
        self.filtIout = filtIout_class(self.address)
        self.filtPout = filtPout_class(self.address)
        self.gainPin0 = gainPin0_class(self.address)
        self.gainPin1 = gainPin1_class(self.address)
        self.gainVadc0 = gainVadc0_class(self.address)
        self.gainVadc1 = gainVadc1_class(self.address)
        self.gainVadc2 = gainVadc2_class(self.address)
        self.gainPout0 = gainPout0_class(self.address)
        self.gainPout1 = gainPout1_class(self.address)
        self.gainPout2 = gainPout2_class(self.address)
        self.gainPinAlert = gainPinAlert_class(self.address)
        self.gainHsVout = gainHsVout_class(self.address)
        self.offHsVout = offHsVout_class(self.address)
        self.gainHsIout0 = gainHsIout0_class(self.address)
        self.offHsIout0 = offHsIout0_class(self.address)
        self.gainHsIout1 = gainHsIout1_class(self.address)
        self.offHsIout1 = offHsIout1_class(self.address)
        self.gainHsIout2 = gainHsIout2_class(self.address)
        self.offHsIout2 = offHsIout2_class(self.address)
        self.gainHsPout0 = gainHsPout0_class(self.address)
        self.gainHsPout1 = gainHsPout1_class(self.address)
        self.gainHsPout2 = gainHsPout2_class(self.address)
        self.pmbTelLsb = pmbTelLsb_class(self.address)
        self.voutMask0 = voutMask0_class(self.address)
        self.voutMask1 = voutMask1_class(self.address)
        self.voutMask2 = voutMask2_class(self.address)
        self.ioutMask0 = ioutMask0_class(self.address)
        self.ioutMask1 = ioutMask1_class(self.address)
        self.ioutMask2 = ioutMask2_class(self.address)
        self.inputMask0 = inputMask0_class(self.address)
        self.inputMask1 = inputMask1_class(self.address)
        self.inputMask2 = inputMask2_class(self.address)
        self.tempMask0 = tempMask0_class(self.address)
        self.tempMask1 = tempMask1_class(self.address)
        self.tempMask2 = tempMask2_class(self.address)
        self.cmlMask = cmlMask_class(self.address)
        self.mfrMask = mfrMask_class(self.address)
        self.multiFunInSwditms = multiFunInSwditms_class(self.address)
        self.multiFunInSwclktck = multiFunInSwclktck_class(self.address)
        self.multiFunInEn0 = multiFunInEn0_class(self.address)
        self.multiFunInEn1 = multiFunInEn1_class(self.address)
        self.multiFunInEn2 = multiFunInEn2_class(self.address)
        self.multiFunInGpio0 = multiFunInGpio0_class(self.address)
        self.multiFunInGpio1 = multiFunInGpio1_class(self.address)
        self.multiFunInGpio2 = multiFunInGpio2_class(self.address)
        self.multiFunInGpio3 = multiFunInGpio3_class(self.address)
        self.multiFunInGpio4 = multiFunInGpio4_class(self.address)
        self.multiFunInGpio5 = multiFunInGpio5_class(self.address)
        self.multiFunInGpio6 = multiFunInGpio6_class(self.address)
        self.multiFunInGpio7 = multiFunInGpio7_class(self.address)
        self.multiFunOutDio0 = multiFunOutDio0_class(self.address)
        self.multiFunOutDioPg1 = multiFunOutDioPg1_class(self.address)
        self.multiFunOutDioE2 = multiFunOutDioE2_class(self.address)
        self.multiFunOutDioPg3 = multiFunOutDioPg3_class(self.address)
        self.multiFunOutDioE4 = multiFunOutDioE4_class(self.address)
        self.multiFunOutDio5 = multiFunOutDio5_class(self.address)
        self.multiFunOutDio6 = multiFunOutDio6_class(self.address)
        self.multiFunOutDioPg7 = multiFunOutDioPg7_class(self.address)
        self.multiFunOutDioR8 = multiFunOutDioR8_class(self.address)
        self.multiFunOutDio9 = multiFunOutDio9_class(self.address)
        self.multiFunOutDio10 = multiFunOutDio10_class(self.address)
        self.multiFunOutDioE11 = multiFunOutDioE11_class(self.address)
        self.dioInputCtrl = dioInputCtrl_class(self.address)
        self.dioDriveCtrl = dioDriveCtrl_class(self.address)
        self.multiFunOutSig = multiFunOutSig_class(self.address)
        self.fltCtrl = fltCtrl_class(self.address)
        self.vccUvFltCtrl = vccUvFltCtrl_class(self.address)
        self.pinOpnEnableA = pinOpnEnableA_class(self.address)
        self.pinOpnEnableB = pinOpnEnableB_class(self.address)
        self.vdd1p8FltCtrl = vdd1p8FltCtrl_class(self.address)
        self.ctrlFltEnA = ctrlFltEnA_class(self.address)
        self.ctrlFltEnB = ctrlFltEnB_class(self.address)
        self.railFltEn0 = railFltEn0_class(self.address)
        self.railFltEn1 = railFltEn1_class(self.address)
        self.railFltEn2 = railFltEn2_class(self.address)
        self.phPeakUcFltEn = phPeakUcFltEn_class(self.address)
        self.phPeakOcFltEn = phPeakOcFltEn_class(self.address)
        self.phAdcUcFltEn = phAdcUcFltEn_class(self.address)
        self.phAdcOcFltEn = phAdcOcFltEn_class(self.address)
        self.phiEstFltEn = phiEstFltEn_class(self.address)
        self.ctrlFltSrcA = ctrlFltSrcA_class(self.address)
        self.ctrlFltSrcB = ctrlFltSrcB_class(self.address)
        self.railFltSrc0 = railFltSrc0_class(self.address)
        self.railFltSrc1 = railFltSrc1_class(self.address)
        self.railFltSrc2 = railFltSrc2_class(self.address)
        self.phPeakUcFltSrc = phPeakUcFltSrc_class(self.address)
        self.phPeakOcFltSrc = phPeakOcFltSrc_class(self.address)
        self.phAdcUcFltSrc = phAdcUcFltSrc_class(self.address)
        self.phAdcOcFltSrc = phAdcOcFltSrc_class(self.address)
        self.phiEstFltSrc = phiEstFltSrc_class(self.address)
        self.ctrlFltRegA = ctrlFltRegA_class(self.address)
        self.ctrlFltRegB = ctrlFltRegB_class(self.address)
        self.railFltReg0 = railFltReg0_class(self.address)
        self.railFltReg1 = railFltReg1_class(self.address)
        self.railFltReg2 = railFltReg2_class(self.address)
        self.phPeakUcFltReg = phPeakUcFltReg_class(self.address)
        self.phPeakOcFltReg = phPeakOcFltReg_class(self.address)
        self.phAdcUcFltReg = phAdcUcFltReg_class(self.address)
        self.phAdcOcFltReg = phAdcOcFltReg_class(self.address)
        self.phiEstFltReg = phiEstFltReg_class(self.address)
        self.ctrlFltStatA = ctrlFltStatA_class(self.address)
        self.ctrlFltStatB = ctrlFltStatB_class(self.address)
        self.railFltStat0 = railFltStat0_class(self.address)
        self.railFltStat1 = railFltStat1_class(self.address)
        self.railFltStat2 = railFltStat2_class(self.address)
        self.phPeakUcFltStat = phPeakUcFltStat_class(self.address)
        self.phPeakOcFltStat = phPeakOcFltStat_class(self.address)
        self.phAdcUcFltStat = phAdcUcFltStat_class(self.address)
        self.phAdcOcFltStat = phAdcOcFltStat_class(self.address)
        self.phiEstFltStat = phiEstFltStat_class(self.address)
        self.ctrlFltTestA = ctrlFltTestA_class(self.address)
        self.ctrlFltTestB = ctrlFltTestB_class(self.address)
        self.railFltTest0 = railFltTest0_class(self.address)
        self.railFltTest1 = railFltTest1_class(self.address)
        self.railFltTest2 = railFltTest2_class(self.address)
        self.phPeakUcFltTest = phPeakUcFltTest_class(self.address)
        self.phPeakOcFltTest = phPeakOcFltTest_class(self.address)
        self.phAdcUcFltTest = phAdcUcFltTest_class(self.address)
        self.phAdcOcFltTest = phAdcOcFltTest_class(self.address)
        self.phiEstFltTest = phiEstFltTest_class(self.address)
        self.cfpCtrlFltEnA = cfpCtrlFltEnA_class(self.address)
        self.cfpCtrlFltEnB = cfpCtrlFltEnB_class(self.address)
        self.cfpRailFltEn0 = cfpRailFltEn0_class(self.address)
        self.cfpRailFltEn1 = cfpRailFltEn1_class(self.address)
        self.cfpRailFltEn2 = cfpRailFltEn2_class(self.address)
        self.cfpPhPeakUcFltEn = cfpPhPeakUcFltEn_class(self.address)
        self.cfpPhPeakOcFltEn = cfpPhPeakOcFltEn_class(self.address)
        self.cfpPhAdcUcFltEn = cfpPhAdcUcFltEn_class(self.address)
        self.cfpPhAdcOcFltEn = cfpPhAdcOcFltEn_class(self.address)
        self.cfpPhiEstFltEn = cfpPhiEstFltEn_class(self.address)
        self.cfpCtrlFltStatA = cfpCtrlFltStatA_class(self.address)
        self.cfpCtrlFltStatB = cfpCtrlFltStatB_class(self.address)
        self.cfpRailFltStat0 = cfpRailFltStat0_class(self.address)
        self.cfpRailFltStat1 = cfpRailFltStat1_class(self.address)
        self.cfpRailFltStat2 = cfpRailFltStat2_class(self.address)
        self.cfpPhPeakUcFltStat = cfpPhPeakUcFltStat_class(self.address)
        self.cfpPhPeakOcFltStat = cfpPhPeakOcFltStat_class(self.address)
        self.cfpPhAdcUcFltStat = cfpPhAdcUcFltStat_class(self.address)
        self.cfpPhAdcOcFltStat = cfpPhAdcOcFltStat_class(self.address)
        self.cfpPhiEstFltStat = cfpPhiEstFltStat_class(self.address)
        self.ctrlFirstFltRegA = ctrlFirstFltRegA_class(self.address)
        self.ctrlFirstFltRegB = ctrlFirstFltRegB_class(self.address)
        self.railFirstFltReg0 = railFirstFltReg0_class(self.address)
        self.railFirstFltReg1 = railFirstFltReg1_class(self.address)
        self.railFirstFltReg2 = railFirstFltReg2_class(self.address)
        self.firstPhPeakUcFltReg = firstPhPeakUcFltReg_class(self.address)
        self.firstPhPeakOcFltReg = firstPhPeakOcFltReg_class(self.address)
        self.firstPhAdcUcFltStat = firstPhAdcUcFltStat_class(self.address)
        self.firstPhAdcOcFltStat = firstPhAdcOcFltStat_class(self.address)
        self.firstPhiEstFltStat = firstPhiEstFltStat_class(self.address)
        self.lmpiAssoc2 = lmpiAssoc2_class(self.address)
        self.lmpiAssoc = lmpiAssoc_class(self.address)
        self.lmpiAvail = lmpiAvail_class(self.address)
        self.phMapPwm = phMapPwm_class(self.address)
        self.phMapIsen = phMapIsen_class(self.address)
        self.lmbs = lmbs_class(self.address)
        self.psysCfg = psysCfg_class(self.address)
        self.dftCfg = dftCfg_class(self.address)
        self.pInAlert = pInAlert_class(self.address)
        self.clickValues = clickValues_class(self.address)
        self.adcConfig = adcConfig_class(self.address)
        self.midDriveCtrl = midDriveCtrl_class(self.address)
        self.sysPwrMgtEn = sysPwrMgtEn_class(self.address)
        self.vsenFltCtrlGl = vsenFltCtrlGl_class(self.address)
        self.phPwrTest = phPwrTest_class(self.address)
        self.chPwrStUCFG = chPwrStUCFG_class(self.address)
        self.chPwrStNON = chPwrStNON_class(self.address)
        self.chPwrStFLT = chPwrStFLT_class(self.address)
        self.chPwrStDIS = chPwrStDIS_class(self.address)
        self.chPwrStPRI = chPwrStPRI_class(self.address)
        self.chPwrStACT = chPwrStACT_class(self.address)
        self.chPwrStONE = chPwrStONE_class(self.address)
        self.chPwrStDCM = chPwrStDCM_class(self.address)
        self.chPwrStDZC = chPwrStDZC_class(self.address)
        self.chPwrStZVF = chPwrStZVF_class(self.address)
        self.chPwrStZVM = chPwrStZVM_class(self.address)
        self.chPwrStZVS = chPwrStZVS_class(self.address)
        self.chPwrStSTBY = chPwrStSTBY_class(self.address)
        self.bgPwrSeq0 = bgPwrSeq0_class(self.address)
        self.bgPwrSeq1 = bgPwrSeq1_class(self.address)
        self.dllPwrSeq0 = dllPwrSeq0_class(self.address)
        self.dllPwrSeq1 = dllPwrSeq1_class(self.address)
        self.vsenPwrSeq0 = vsenPwrSeq0_class(self.address)
        self.vsenPwrSeq1 = vsenPwrSeq1_class(self.address)
        self.vsenPwrSeq2 = vsenPwrSeq2_class(self.address)
        self.vsenPwrSeq3 = vsenPwrSeq3_class(self.address)
        self.isenPwrSeq0 = isenPwrSeq0_class(self.address)
        self.isenPwrSeq1 = isenPwrSeq1_class(self.address)
        self.isenPwrSeq2 = isenPwrSeq2_class(self.address)
        self.telPwrSeq0 = telPwrSeq0_class(self.address)
        self.telPwrSeq1 = telPwrSeq1_class(self.address)
        self.telPwrSeq2 = telPwrSeq2_class(self.address)
        self.oscPwrMgt = oscPwrMgt_class(self.address)
        self.phase1AddDrop = phase1AddDrop_class(self.address)
        self.phase2AddDrop = phase2AddDrop_class(self.address)
        self.phase3AddDrop = phase3AddDrop_class(self.address)
        self.phase4AddDrop = phase4AddDrop_class(self.address)
        self.phase5AddDrop = phase5AddDrop_class(self.address)
        self.phase6AddDrop = phase6AddDrop_class(self.address)
        self.phase7AddDrop = phase7AddDrop_class(self.address)
        self.lmgrIntAnd = lmgrIntAnd_class(self.address)
        self.lmgrIntRE = lmgrIntRE_class(self.address)
        self.lmgrIntFE = lmgrIntFE_class(self.address)
        self.compFilt0A = compFilt0A_class(self.address)
        self.compFilt0B = compFilt0B_class(self.address)
        self.hcNlll0 = hcNlll0_class(self.address)
        self.compFilt1B = compFilt1B_class(self.address)
        self.hcNlll1 = hcNlll1_class(self.address)
        self.compFilt2B = compFilt2B_class(self.address)
        self.hcNlll2 = hcNlll2_class(self.address)
        self.compFilt3B = compFilt3B_class(self.address)
        self.estSeq = estSeq_class(self.address)
        self.phAssocRtn0 = phAssocRtn0_class(self.address)
        self.phAssocRtn1 = phAssocRtn1_class(self.address)
        self.phAssocRtnInternal = phAssocRtnInternal_class(self.address)
        self.asyncWakeCtrl = asyncWakeCtrl_class(self.address)
        self.serialNum = serialNum_class(self.address)
        self.compFiltPDSel = compFiltPDSel_class(self.address)
        self.integratorLimits = integratorLimits_class(self.address)
        self.integCfg = integCfg_class(self.address)
        self.digDroop = digDroop_class(self.address)
        self.pulseAdvance = pulseAdvance_class(self.address)
        self.targCurr = targCurr_class(self.address)
        self.clipCurr = clipCurr_class(self.address)
        self.brakeA = brakeA_class(self.address)
        self.brakeB = brakeB_class(self.address)
        self.brakeC = brakeC_class(self.address)
        self.brakeD = brakeD_class(self.address)
        self.dynDroop = dynDroop_class(self.address)
        self.fastAddCtrl = fastAddCtrl_class(self.address)
        self.dcmOnlyCfg = dcmOnlyCfg_class(self.address)
        self.dcmOnlyCfgB = dcmOnlyCfgB_class(self.address)
        self.onePhCfg = onePhCfg_class(self.address)
        self.modCfg = modCfg_class(self.address)
        self.rrCfg = rrCfg_class(self.address)
        self.fllWindow = fllWindow_class(self.address)
        self.maxSwPer = maxSwPer_class(self.address)
        self.peakTimeCalc = peakTimeCalc_class(self.address)
        self.minPeakOnTime = minPeakOnTime_class(self.address)
        self.minNegTime = minNegTime_class(self.address)
        self.minOnTime = minOnTime_class(self.address)
        self.maxOnTime = maxOnTime_class(self.address)
        self.minOffTime = minOffTime_class(self.address)
        self.minOffTimeCcm = minOffTimeCcm_class(self.address)
        self.minOffTimeZcd = minOffTimeZcd_class(self.address)
        self.minHiZTime = minHiZTime_class(self.address)
        self.earlyFinish = earlyFinish_class(self.address)
        self.minOnTimeLate = minOnTimeLate_class(self.address)
        self.phaseTurnOff = phaseTurnOff_class(self.address)
        self.dcrFstSetup = dcrFstSetup_class(self.address)
        self.dcrSetup = dcrSetup_class(self.address)
        self.diodeEmuDelay = diodeEmuDelay_class(self.address)
        self.diodeEmulation = diodeEmulation_class(self.address)
        self.ps2ExitSpeedUp = ps2ExitSpeedUp_class(self.address)
        self.limitedDecay = limitedDecay_class(self.address)
        self.configLp = configLp_class(self.address)
        self.kPredOff = kPredOff_class(self.address)
        self.kiDutyInv = kiDutyInv_class(self.address)
        self.kDio = kDio_class(self.address)
        self.estLoss = estLoss_class(self.address)
        self.estSetup = estSetup_class(self.address)
        self.estFilt = estFilt_class(self.address)
        self.estGain = estGain_class(self.address)
        self.estConfig = estConfig_class(self.address)
        self.estOffset = estOffset_class(self.address)
        self.vAdcComp = vAdcComp_class(self.address)
        self.vTrigDcm = vTrigDcm_class(self.address)
        self.rampCfg = rampCfg_class(self.address)
        self.iInEstCfg = iInEstCfg_class(self.address)
        self.estFault = estFault_class(self.address)
        self.rampCompBulkA = rampCompBulkA_class(self.address)
        self.rampCompBulkB = rampCompBulkB_class(self.address)
        self.rampCompCerA = rampCompCerA_class(self.address)
        self.rampCompCerB = rampCompCerB_class(self.address)
        self.peakOcCalc = peakOcCalc_class(self.address)
        self.peakOcCfg = peakOcCfg_class(self.address)
        self.vrefOverride = vrefOverride_class(self.address)
        self.fixedPwm = fixedPwm_class(self.address)
        self.diagnostics = diagnostics_class(self.address)
        self.loopTelTest = loopTelTest_class(self.address)
        self.trigCtrl = trigCtrl_class(self.address)
        self.phaseBal = phaseBal_class(self.address)
        self.ovFaultCtrl = ovFaultCtrl_class(self.address)
        self.ouvTol = ouvTol_class(self.address)
        self.oovTol = oovTol_class(self.address)
        self.ovHyst = ovHyst_class(self.address)
        self.freqCtrl = freqCtrl_class(self.address)
        self.bootcapOpt = bootcapOpt_class(self.address)
        self.bootcap = bootcap_class(self.address)
        self.alertDelay = alertDelay_class(self.address)
        self.alertTOB = alertTOB_class(self.address)
        self.bootData = bootData_class(self.address)
        self.addDropDelay = addDropDelay_class(self.address)
        self.absVoutMax = absVoutMax_class(self.address)
        self.partFastAdd = partFastAdd_class(self.address)
        self.fastIccMax = fastIccMax_class(self.address)
        self.spsPwrMgt = spsPwrMgt_class(self.address)
        self.chPwrMgtEn = chPwrMgtEn_class(self.address)
        self.chPwrTest = chPwrTest_class(self.address)
        self.svi3Version = svi3Version_class(self.address)
        self.mfgId = mfgId_class(self.address)
        self.modelId = modelId_class(self.address)
        self.tenBitTelAvail = tenBitTelAvail_class(self.address)
        self.sixteenBitTelAvail = sixteenBitTelAvail_class(self.address)
        self.crcPsiVid = crcPsiVid_class(self.address)
        self.vid = vid_class(self.address)
        self.svi3BootData = svi3BootData_class(self.address)
        self.teleScale = teleScale_class(self.address)
        self.maxVoutSupport = maxVoutSupport_class(self.address)
        self.minVoutSupport = minVoutSupport_class(self.address)
        self.psysScale = psysScale_class(self.address)
        self.faultStatus = faultStatus_class(self.address)
        self.nackStatus = nackStatus_class(self.address)
        self.rateSelect = rateSelect_class(self.address)
        self.llAdjust = llAdjust_class(self.address)
        self.voutOffset = voutOffset_class(self.address)
        self.vidMax = vidMax_class(self.address)
        self.vidMin = vidMin_class(self.address)
        self.tenBitTelEn = tenBitTelEn_class(self.address)
        self.sixteenBitTelEn = sixteenBitTelEn_class(self.address)
        self.ocpThresh = ocpThresh_class(self.address)
        self.ocpWarnThresh = ocpWarnThresh_class(self.address)
        self.ocpWnMnPlsFtDl = ocpWnMnPlsFtDl_class(self.address)
        self.vrhotThresh = vrhotThresh_class(self.address)
        self.otpThresh = otpThresh_class(self.address)
        self.voltProt = voltProt_class(self.address)
        self.phaseShed = phaseShed_class(self.address)
        self.debugEn = debugEn_class(self.address)
        self.debugTemp1 = debugTemp1_class(self.address)
        self.debugVoutH = debugVoutH_class(self.address)
        self.debugVoutL = debugVoutL_class(self.address)
        self.debugIoutH = debugIoutH_class(self.address)
        self.debugIoutL = debugIoutL_class(self.address)
        self.debugOutput = debugOutput_class(self.address)
        self.genPurpose0 = genPurpose0_class(self.address)
        self.genPurpose1 = genPurpose1_class(self.address)
        self.genPurpose2 = genPurpose2_class(self.address)
        self.genPurpose3 = genPurpose3_class(self.address)
        self.genPurpose4 = genPurpose4_class(self.address)
        self.genPurpose5 = genPurpose5_class(self.address)
        self.genPurpose6 = genPurpose6_class(self.address)
        self.genPurpose7 = genPurpose7_class(self.address)
        self.mcuTempFlt = mcuTempFlt_class(self.address)
        self.mcuFlt = mcuFlt_class(self.address)
        self.diagFlt = diagFlt_class(self.address)
        self.mcuLpc = mcuLpc_class(self.address)
        self.mcuCtl = mcuCtl_class(self.address)
        self.currBalPh03 = currBalPh03_class(self.address)
        self.currBalPh47 = currBalPh47_class(self.address)
        self.currBalCtrl = currBalCtrl_class(self.address)
        self.mcuBadPhase = mcuBadPhase_class(self.address)
        self.mcuPhPwrMgt = mcuPhPwrMgt_class(self.address)
        self.mcuPwrMgt = mcuPwrMgt_class(self.address)
        self.pmbIrqMask0 = pmbIrqMask0_class(self.address)
        self.pmbIrqMask1 = pmbIrqMask1_class(self.address)
        self.pmbIrqMask2 = pmbIrqMask2_class(self.address)
        self.pmbIrqMask3 = pmbIrqMask3_class(self.address)
        self.pmbIrqMask4 = pmbIrqMask4_class(self.address)
        self.pmbIrqMask5 = pmbIrqMask5_class(self.address)
        self.pmbIrqMask6 = pmbIrqMask6_class(self.address)
        self.pmbIrqMask7 = pmbIrqMask7_class(self.address)
        self.mcuSumVolt = mcuSumVolt_class(self.address)
        self.mcuOnRise = mcuOnRise_class(self.address)
        self.mcuOffFall = mcuOffFall_class(self.address)
        self.dMACIntStatus = dMACIntStatus_class(self.address)
        self.dMACIntTCStatus = dMACIntTCStatus_class(self.address)
        self.dMACIntTCClear = dMACIntTCClear_class(self.address)
        self.dMACIntErrorStatus = dMACIntErrorStatus_class(self.address)
        self.dMACIntErrClr = dMACIntErrClr_class(self.address)
        self.dMACRawIntTCStatus = dMACRawIntTCStatus_class(self.address)
        self.dMACRawIntErrorStatus = dMACRawIntErrorStatus_class(self.address)
        self.dMACEnbldChns = dMACEnbldChns_class(self.address)
        self.dMACSoftSReq = dMACSoftSReq_class(self.address)
        self.dMACConfiguration = dMACConfiguration_class(self.address)
        self.dMACCRC = dMACCRC_class(self.address)
        self.dMACC1SrcAddr = dMACC1SrcAddr_class(self.address)
        self.dMACC1DstAddr = dMACC1DstAddr_class(self.address)
        self.dMACC1Control = dMACC1Control_class(self.address)
        self.dMACC1Configuration = dMACC1Configuration_class(self.address)
        self.dMACC2SrcAddr = dMACC2SrcAddr_class(self.address)
        self.dMACC2DstAddr = dMACC2DstAddr_class(self.address)
        self.dMACC2Control = dMACC2Control_class(self.address)
        self.dMACC2Configuration = dMACC2Configuration_class(self.address)
        self.dMACC3SrcAddr = dMACC3SrcAddr_class(self.address)
        self.dMACC3DstAddr = dMACC3DstAddr_class(self.address)
        self.dMACC3Control = dMACC3Control_class(self.address)
        self.dMACC3Configuration = dMACC3Configuration_class(self.address)
        self.dMACC4SrcAddr = dMACC4SrcAddr_class(self.address)
        self.dMACC4DstAddr = dMACC4DstAddr_class(self.address)
        self.dMACC4Control = dMACC4Control_class(self.address)
        self.dMACC4Configuration = dMACC4Configuration_class(self.address)
        self.dMACC5SrcAddr = dMACC5SrcAddr_class(self.address)
        self.dMACC5DstAddr = dMACC5DstAddr_class(self.address)
        self.dMACC5Control = dMACC5Control_class(self.address)
        self.dMACC5Configuration = dMACC5Configuration_class(self.address)
        self.dMACC6SrcAddr = dMACC6SrcAddr_class(self.address)
        self.dMACC6DstAddr = dMACC6DstAddr_class(self.address)
        self.dMACC6Control = dMACC6Control_class(self.address)
        self.dMACC6Configuration = dMACC6Configuration_class(self.address)
        self.dMACC7SrcAddr = dMACC7SrcAddr_class(self.address)
        self.dMACC7DstAddr = dMACC7DstAddr_class(self.address)
        self.dMACC7Control = dMACC7Control_class(self.address)
        self.dMACC7Configuration = dMACC7Configuration_class(self.address)
        self.serLogCmdMask = serLogCmdMask_class(self.address)
        self.serLogAddrMask = serLogAddrMask_class(self.address)
        self.serLogCfg = serLogCfg_class(self.address)
        self.serLogPtr = serLogPtr_class(self.address)
        self.dcbTimeStamp = dcbTimeStamp_class(self.address)
        self.dcbTrigReg = dcbTrigReg_class(self.address)
        self.dcbCfg = dcbCfg_class(self.address)
        self.dcbIsenCfg = dcbIsenCfg_class(self.address)
        self.dpbCfg = dpbCfg_class(self.address)
        self.sdifCfg = sdifCfg_class(self.address)
        self.sdifMsg = sdifMsg_class(self.address)
        self.sdifStatus = sdifStatus_class(self.address)
        self.sdifGrpAddr = sdifGrpAddr_class(self.address)
        self.spsMgrCfg = spsMgrCfg_class(self.address)
        self.spsMgrStatus = spsMgrStatus_class(self.address)
        self.spsTmonCfg = spsTmonCfg_class(self.address)
        self.overrideOc = overrideOc_class(self.address)
        self.overrideUc = overrideUc_class(self.address)
        self.ctrlOverride = ctrlOverride_class(self.address)
        self.csXbar0 = csXbar0_class(self.address)
        self.csXbar1 = csXbar1_class(self.address)
        self.csXbar2 = csXbar2_class(self.address)
        self.csXbar3 = csXbar3_class(self.address)
        self.mcuDbgPinSel = mcuDbgPinSel_class(self.address)
        self.hsBusInt = hsBusInt_class(self.address)
        self.pmBusInt = pmBusInt_class(self.address)
        self.memoryIntMask = memoryIntMask_class(self.address)
        self.memoryInt = memoryInt_class(self.address)
        self.pwmGPIOcfg = pwmGPIOcfg_class(self.address)
        self.pwmGPIOdir = pwmGPIOdir_class(self.address)
        self.pwmGPIOdata = pwmGPIOdata_class(self.address)
        self.pwmStatusIn = pwmStatusIn_class(self.address)
        self.pwmGPIOmidDr = pwmGPIOmidDr_class(self.address)
        self.svi3Iout = svi3Iout_class(self.address)
        self.svi3Vout = svi3Vout_class(self.address)
        self.svi3Temp1 = svi3Temp1_class(self.address)
        self.svi3Temp2 = svi3Temp2_class(self.address)
        self.svi3Iin = svi3Iin_class(self.address)
        self.svi3Vin = svi3Vin_class(self.address)
        self.svi3OocLimit = svi3OocLimit_class(self.address)
        self.svi3OocWarnLimit = svi3OocWarnLimit_class(self.address)
        self.svi3FastDelay = svi3FastDelay_class(self.address)
        self.svi3Cfg = svi3Cfg_class(self.address)
        self.otpCtrl = otpCtrl_class(self.address)
        self.otpRemap = otpRemap_class(self.address)
        self.otpSpare = otpSpare_class(self.address)
        self.otpTest = otpTest_class(self.address)
        self.monPhStat = monPhStat_class(self.address)
        self.monPh = monPh_class(self.address)
        self.monLoop = monLoop_class(self.address)
        self.monLpStat = monLpStat_class(self.address)
        self.loopStatA = loopStatA_class(self.address)
        self.loopStatB = loopStatB_class(self.address)
        self.loopStatC = loopStatC_class(self.address)
        self.loopStatD = loopStatD_class(self.address)
        self.lmgrStatus = lmgrStatus_class(self.address)
        self.avsFallRate = avsFallRate_class(self.address)
        self.avsRiseRate = avsRiseRate_class(self.address)
        self.chPwrStatus = chPwrStatus_class(self.address)
        self.iSenAzData = iSenAzData_class(self.address)
        self.sysStatus = sysStatus_class(self.address)
        self.pinOpnInA = pinOpnInA_class(self.address)
        self.pinOpnInB = pinOpnInB_class(self.address)
        self.pinRead = pinRead_class(self.address)
        self.phStatus = phStatus_class(self.address)
        self.pwrStatusB = pwrStatusB_class(self.address)
        self.pwrStatus = pwrStatus_class(self.address)
        self.phPwrNeedDM = phPwrNeedDM_class(self.address)
        self.phPwrStatus = phPwrStatus_class(self.address)
        self.spsActDM = spsActDM_class(self.address)
        self.upTime0 = upTime0_class(self.address)
        self.upTime1 = upTime1_class(self.address)
        self.upTime2 = upTime2_class(self.address)
        self.revId = revId_class(self.address)
        self.pwmStatusEn = pwmStatusEn_class(self.address)
        self.pwmStatus = pwmStatus_class(self.address)
        self.ringCnt = ringCnt_class(self.address)
        self.clkEnable1 = clkEnable1_class(self.address)
        self.clkEnable2 = clkEnable2_class(self.address)
        self.svi3Status = svi3Status_class(self.address)
        self.otpStatus = otpStatus_class(self.address)
        self.avgVadc0 = avgVadc0_class(self.address)
        self.avgVadc1 = avgVadc1_class(self.address)
        self.avgVadc2 = avgVadc2_class(self.address)
        self.avgIout0 = avgIout0_class(self.address)
        self.avgIout1 = avgIout1_class(self.address)
        self.avgIout2 = avgIout2_class(self.address)
        self.avgPout0 = avgPout0_class(self.address)
        self.avgPout1 = avgPout1_class(self.address)
        self.avgPout2 = avgPout2_class(self.address)
        self.avgIph0 = avgIph0_class(self.address)
        self.avgIph1 = avgIph1_class(self.address)
        self.avgIph2 = avgIph2_class(self.address)
        self.avgIph3 = avgIph3_class(self.address)
        self.avgIph4 = avgIph4_class(self.address)
        self.avgIph5 = avgIph5_class(self.address)
        self.avgIph6 = avgIph6_class(self.address)
        self.avgIph7 = avgIph7_class(self.address)
        self.rawVinTel0 = rawVinTel0_class(self.address)
        self.rawIinTel0 = rawIinTel0_class(self.address)
        self.rawIntTempTel = rawIntTempTel_class(self.address)
        self.rawExtTempTel0 = rawExtTempTel0_class(self.address)
        self.rawExtTempTel1 = rawExtTempTel1_class(self.address)
        self.rawExtTempTel2 = rawExtTempTel2_class(self.address)
        self.rawVccTel = rawVccTel_class(self.address)
        self.rawConfigTel = rawConfigTel_class(self.address)
        self.rawVdd1p8Tel = rawVdd1p8Tel_class(self.address)
        self.avgVinTel0 = avgVinTel0_class(self.address)
        self.avgIinTel0 = avgIinTel0_class(self.address)
        self.avgVoutTel0 = avgVoutTel0_class(self.address)
        self.avgVoutTel1 = avgVoutTel1_class(self.address)
        self.avgVoutTel2 = avgVoutTel2_class(self.address)
        self.avgIntTempTel = avgIntTempTel_class(self.address)
        self.avgExtTempTel0 = avgExtTempTel0_class(self.address)
        self.avgExtTempTel1 = avgExtTempTel1_class(self.address)
        self.avgExtTempTel2 = avgExtTempTel2_class(self.address)
        self.avgAtbTel = avgAtbTel_class(self.address)
        self.avgVccTel = avgVccTel_class(self.address)
        self.avgVccsTel = avgVccsTel_class(self.address)
        self.avgVddioTel = avgVddioTel_class(self.address)
        self.avgAddressTel = avgAddressTel_class(self.address)
        self.avgConfigTel = avgConfigTel_class(self.address)
        self.avgVdd1p8Tel = avgVdd1p8Tel_class(self.address)
        self.avgAutoZeroTel = avgAutoZeroTel_class(self.address)
        self.avgAddrZeroTel = avgAddrZeroTel_class(self.address)
        self.avgConfigZeroTel = avgConfigZeroTel_class(self.address)
        self.avgPinViTel = avgPinViTel_class(self.address)
        self.avgVsysTel = avgVsysTel_class(self.address)
        self.avgIsysTel = avgIsysTel_class(self.address)
        self.avgPsysTel = avgPsysTel_class(self.address)
        self.avgHsVinTel = avgHsVinTel_class(self.address)
        self.avgHsAuxImonTel = avgHsAuxImonTel_class(self.address)
        self.nvmSvi3Reg20 = nvmSvi3Reg20_class(self.address)
        self.nvmSvi3Reg21 = nvmSvi3Reg21_class(self.address)
        self.nvmSvi3Reg22 = nvmSvi3Reg22_class(self.address)
        self.nvmSvi3Reg23 = nvmSvi3Reg23_class(self.address)
        self.nvmSvi3Reg24 = nvmSvi3Reg24_class(self.address)
        self.nvmSvi3Reg25 = nvmSvi3Reg25_class(self.address)
        self.nvmSvi3Reg2A = nvmSvi3Reg2A_class(self.address)
        self.nvmSvi3Reg2B = nvmSvi3Reg2B_class(self.address)
        self.nvmSvi3Reg2C = nvmSvi3Reg2C_class(self.address)
        self.nvmSvi3Reg2D = nvmSvi3Reg2D_class(self.address)
        self.snap0 = snap0_class(self.address)
        self.snap1 = snap1_class(self.address)
        self.snap2 = snap2_class(self.address)
        self.snap3 = snap3_class(self.address)
        self.snap4 = snap4_class(self.address)
        self.snap5 = snap5_class(self.address)
        self.snap6 = snap6_class(self.address)
        self.snap7 = snap7_class(self.address)
        self.snap8 = snap8_class(self.address)
        self.snap9 = snap9_class(self.address)
        self.snapA = snapA_class(self.address)
        self.snapB = snapB_class(self.address)
        self.snapC = snapC_class(self.address)
        self.snapD = snapD_class(self.address)
        self.snapE = snapE_class(self.address)
        self.snapF = snapF_class(self.address)
        self.snap10 = snap10_class(self.address)
        self.snap11 = snap11_class(self.address)
        self.snap12 = snap12_class(self.address)
        self.snap13 = snap13_class(self.address)
        self.snap14 = snap14_class(self.address)
        self.snap15 = snap15_class(self.address)
        self.snap16 = snap16_class(self.address)
        self.snap17 = snap17_class(self.address)
        self.snap18 = snap18_class(self.address)
        self.snap19 = snap19_class(self.address)
        self.snap1A = snap1A_class(self.address)
        self.snap1B = snap1B_class(self.address)
        self.snap1C = snap1C_class(self.address)
        self.snap1D = snap1D_class(self.address)
        self.snap1E = snap1E_class(self.address)
        self.snap1F = snap1F_class(self.address)
        self.snap20 = snap20_class(self.address)
        self.rPATCHVERSION = rPATCHVERSION_class(self.address)
        self.rFWSTATE = rFWSTATE_class(self.address)
        self.rFWSTATUS = rFWSTATUS_class(self.address)
        self.rFWCTRL = rFWCTRL_class(self.address)
        self.rPATCHEND = rPATCHEND_class(self.address)
        self.rOTPPATCHEND = rOTPPATCHEND_class(self.address)
        self.rOTPCFGEND = rOTPCFGEND_class(self.address)
        self.rCONFIG = rCONFIG_class(self.address)
        self.rCONFIGAVAILABLE = rCONFIGAVAILABLE_class(self.address)
        self.rCFGPROGCTRL = rCFGPROGCTRL_class(self.address)
        self.rCFGPROGSTAT = rCFGPROGSTAT_class(self.address)
        self.rCFGOTPBASEADDR = rCFGOTPBASEADDR_class(self.address)
        self.rCFGOTPINCADDR = rCFGOTPINCADDR_class(self.address)
        self.rCFGOTPADDR01 = rCFGOTPADDR01_class(self.address)
        self.rCFGOTPADDR23 = rCFGOTPADDR23_class(self.address)
        self.rCFGOTPADDR45 = rCFGOTPADDR45_class(self.address)
        self.rCFGOTPADDR67 = rCFGOTPADDR67_class(self.address)
        self.rCFGOTPADDR89 = rCFGOTPADDR89_class(self.address)
        self.rCFGOTPADDR1011 = rCFGOTPADDR1011_class(self.address)
        self.rCFGOTPADDR1213 = rCFGOTPADDR1213_class(self.address)
        self.rCFGOTPADDR1415 = rCFGOTPADDR1415_class(self.address)
        self.rCFGOTPADDR1617 = rCFGOTPADDR1617_class(self.address)
        self.rCFGOTPADDR1819 = rCFGOTPADDR1819_class(self.address)
        self.rCFGOTPADDR2021 = rCFGOTPADDR2021_class(self.address)
        self.rCFGOTPADDR2223 = rCFGOTPADDR2223_class(self.address)
        self.rCFGOTPADDR2425 = rCFGOTPADDR2425_class(self.address)
        self.rCFGOTPADDR2627 = rCFGOTPADDR2627_class(self.address)
        self.rCFGOTPADDR2829 = rCFGOTPADDR2829_class(self.address)
        self.rCFGOTPADDR3031 = rCFGOTPADDR3031_class(self.address)
        self.rPINOPNSTATUSA = rPINOPNSTATUSA_class(self.address)
        self.rPINOPNSTATUSB = rPINOPNSTATUSB_class(self.address)
        self.rBBADDR = rBBADDR_class(self.address)
        self.rSSADDR = rSSADDR_class(self.address)
        self.rPATCHCRC = rPATCHCRC_class(self.address)
        self.rPREMFRCRC = rPREMFRCRC_class(self.address)
        self.rMFRCRC = rMFRCRC_class(self.address)
        self.rPINSTRAPCONFIGSEL = rPINSTRAPCONFIGSEL_class(self.address)
        self.rMCUCMD0STATUS = rMCUCMD0STATUS_class(self.address)
        self.rRUNVECTTYPE = rRUNVECTTYPE_class(self.address)
        self.rRUNVECTOUT = rRUNVECTOUT_class(self.address)
        self.rRUNVECTIN1 = rRUNVECTIN1_class(self.address)
        self.rRUNVECTIN2 = rRUNVECTIN2_class(self.address)
        self.rRUNVECTIN3 = rRUNVECTIN3_class(self.address)
        self.rUTCADDRRD = rUTCADDRRD_class(self.address)
        self.rBOOTTEST = rBOOTTEST_class(self.address)
        self.rBOOTTEST0 = rBOOTTEST0_class(self.address)
        self.rBOOTTEST1 = rBOOTTEST1_class(self.address)
        self.rBOOTTEST2 = rBOOTTEST2_class(self.address)
        self.rBOOTTEST3 = rBOOTTEST3_class(self.address)
        self.rBOOTTESTEXP0 = rBOOTTESTEXP0_class(self.address)
        self.rBOOTTESTEXP1 = rBOOTTESTEXP1_class(self.address)
        self.rBOOTTESTEXP2 = rBOOTTESTEXP2_class(self.address)
        self.rBOOTTESTEXP3 = rBOOTTESTEXP3_class(self.address)
        self.rBOOTTESTVOUT = rBOOTTESTVOUT_class(self.address)
        self.rBOOTTESTSTEP = rBOOTTESTSTEP_class(self.address)
        self.rLOGGERADDR = rLOGGERADDR_class(self.address)
        self.rIMONCAL0A = rIMONCAL0A_class(self.address)
        self.rIMONCAL0B = rIMONCAL0B_class(self.address)
        self.rIMONCAL1A = rIMONCAL1A_class(self.address)
        self.rIMONCAL1B = rIMONCAL1B_class(self.address)
        self.rIMONCAL2A = rIMONCAL2A_class(self.address)
        self.rIMONCAL2B = rIMONCAL2B_class(self.address)
        self.rIMONCAL3A = rIMONCAL3A_class(self.address)
        self.rIMONCAL3B = rIMONCAL3B_class(self.address)
        self.rIMONCAL4A = rIMONCAL4A_class(self.address)
        self.rIMONCAL4B = rIMONCAL4B_class(self.address)
        self.rIMONCAL5A = rIMONCAL5A_class(self.address)
        self.rIMONCAL5B = rIMONCAL5B_class(self.address)
        self.rIMONCAL6A = rIMONCAL6A_class(self.address)
        self.rIMONCAL6B = rIMONCAL6B_class(self.address)
        self.rIMONCAL7A = rIMONCAL7A_class(self.address)
        self.rIMONCAL7B = rIMONCAL7B_class(self.address)
        self.rSDIFRETRIES0 = rSDIFRETRIES0_class(self.address)
        self.rSDIFRETRIES1 = rSDIFRETRIES1_class(self.address)
        self.rFWSDIFSTATUS = rFWSDIFSTATUS_class(self.address)
        self.rSDIFRDSON01 = rSDIFRDSON01_class(self.address)
        self.rSDIFRDSON23 = rSDIFRDSON23_class(self.address)
        self.rSDIFRDSON45 = rSDIFRDSON45_class(self.address)
        self.rSDIFRDSON67 = rSDIFRDSON67_class(self.address)
        self.rSDIFVCCRAW01 = rSDIFVCCRAW01_class(self.address)
        self.rSDIFVCCRAW23 = rSDIFVCCRAW23_class(self.address)
        self.rSDIFVCCRAW45 = rSDIFVCCRAW45_class(self.address)
        self.rSDIFVCCRAW67 = rSDIFVCCRAW67_class(self.address)
        self.rOWLPHFLTSTATA = rOWLPHFLTSTATA_class(self.address)
        self.rOWLPHFLTSTATB = rOWLPHFLTSTATB_class(self.address)
        self.rADDRPSTRAPTABLE0 = rADDRPSTRAPTABLE0_class(self.address)
        self.rADDRPSTRAPTABLE1 = rADDRPSTRAPTABLE1_class(self.address)
        self.rADDRPSTRAPTABLE2 = rADDRPSTRAPTABLE2_class(self.address)
        self.rADDRPSTRAPTABLE3 = rADDRPSTRAPTABLE3_class(self.address)
        self.rADDRPSTRAPTABLE4 = rADDRPSTRAPTABLE4_class(self.address)
        self.rADDRPSTRAPTABLE5 = rADDRPSTRAPTABLE5_class(self.address)
        self.rADDRPSTRAPTABLE6 = rADDRPSTRAPTABLE6_class(self.address)
        self.rADDRPSTRAPTABLE7 = rADDRPSTRAPTABLE7_class(self.address)
        self.rCFGPSTRAPTABLE0 = rCFGPSTRAPTABLE0_class(self.address)
        self.rCFGPSTRAPTABLE1 = rCFGPSTRAPTABLE1_class(self.address)
        self.rCFGPSTRAPTABLE2 = rCFGPSTRAPTABLE2_class(self.address)
        self.rCFGPSTRAPTABLE3 = rCFGPSTRAPTABLE3_class(self.address)
        self.rCFGPSTRAPTABLE4 = rCFGPSTRAPTABLE4_class(self.address)
        self.rCFGPSTRAPTABLE5 = rCFGPSTRAPTABLE5_class(self.address)
        self.rPATCHSVNREV = rPATCHSVNREV_class(self.address)
        self.rCONFIGID = rCONFIGID_class(self.address)
        self.rFILTERWAIT = rFILTERWAIT_class(self.address)
        self.rTC0A = rTC0A_class(self.address)
        self.rTC0B = rTC0B_class(self.address)
        self.rTC1A = rTC1A_class(self.address)
        self.rTC1B = rTC1B_class(self.address)
        self.rTC2A = rTC2A_class(self.address)
        self.rTC2B = rTC2B_class(self.address)
        self.rTCTHRESH = rTCTHRESH_class(self.address)
        self.rUSRSYSFULLPWR0 = rUSRSYSFULLPWR0_class(self.address)
        self.rGUI1 = rGUI1_class(self.address)
        self.rGUI2 = rGUI2_class(self.address)
        self.rGUI3 = rGUI3_class(self.address)
        self.rGUI4 = rGUI4_class(self.address)
        self.rGUI5 = rGUI5_class(self.address)
        self.rTEMPTELCFG = rTEMPTELCFG_class(self.address)
        self.rUSRCONFIG = rUSRCONFIG_class(self.address)
        self.rSDIFUSERCFG = rSDIFUSERCFG_class(self.address)
        self.rUTCPSSAUSER = rUTCPSSAUSER_class(self.address)
        self.rUTCPSSBUSER = rUTCPSSBUSER_class(self.address)
        self.rUTCASS1AUSER = rUTCASS1AUSER_class(self.address)
        self.rUTCASS1BUSER = rUTCASS1BUSER_class(self.address)
        self.rUTCASS2AUSER = rUTCASS2AUSER_class(self.address)
        self.rUTCASS2BUSER = rUTCASS2BUSER_class(self.address)
        self.rUTCESSUSER = rUTCESSUSER_class(self.address)
        self.rUTCPSSASLOW = rUTCPSSASLOW_class(self.address)
        self.rUTCPSSBSLOW = rUTCPSSBSLOW_class(self.address)
        self.rUTCASS1ASLOW = rUTCASS1ASLOW_class(self.address)
        self.rUTCASS1BSLOW = rUTCASS1BSLOW_class(self.address)
        self.rUTCASS2ASLOW = rUTCASS2ASLOW_class(self.address)
        self.rUTCASS2BSLOW = rUTCASS2BSLOW_class(self.address)
        self.rUTCESSSLOW = rUTCESSSLOW_class(self.address)
        self.rVIinSlotCfg = rVIinSlotCfg_class(self.address)
        self.rTemp01SlotCfg = rTemp01SlotCfg_class(self.address)
        self.rTemp2ISlotCfg = rTemp2ISlotCfg_class(self.address)
        self.rVintExtSlotCfg = rVintExtSlotCfg_class(self.address)
        self.rAzSlotCfg = rAzSlotCfg_class(self.address)
        self.rUSRCTRLFLTEN = rUSRCTRLFLTEN_class(self.address)
        self.rUSERPHGAIN01 = rUSERPHGAIN01_class(self.address)
        self.rUSERPHGAIN23 = rUSERPHGAIN23_class(self.address)
        self.rUSERPHGAIN45 = rUSERPHGAIN45_class(self.address)
        self.rUSERPHGAIN67 = rUSERPHGAIN67_class(self.address)
        self.rUSERPHOFFSET0123 = rUSERPHOFFSET0123_class(self.address)
        self.rUSERPHOFFSET47 = rUSERPHOFFSET47_class(self.address)
        self.rCURRBALPH03 = rCURRBALPH03_class(self.address)
        self.rCURRBALPH47 = rCURRBALPH47_class(self.address)
        self.rCFGPINTELFILTGAIN = rCFGPINTELFILTGAIN_class(self.address)
        self.rCFGMFP0 = rCFGMFP0_class(self.address)
        self.rCFGMFP1 = rCFGMFP1_class(self.address)
        self.rCFGMFP2 = rCFGMFP2_class(self.address)
        self.rCFGMFP3 = rCFGMFP3_class(self.address)
        self.rCFGMFP4 = rCFGMFP4_class(self.address)
        self.rUSERSPARE0 = rUSERSPARE0_class(self.address)
        self.rUSERSPARE1 = rUSERSPARE1_class(self.address)
        self.rUSERSPARE2 = rUSERSPARE2_class(self.address)
        self.rUSERSPARE3 = rUSERSPARE3_class(self.address)
        self.rUSERSPARE4 = rUSERSPARE4_class(self.address)
        self.rUSERSPARE5 = rUSERSPARE5_class(self.address)
        self.rPARTID = rPARTID_class(self.address)
        self.rISOURCETRIM = rISOURCETRIM_class(self.address)
        self.rINTTEMPTRIM = rINTTEMPTRIM_class(self.address)
        self.rVSENGAIN01 = rVSENGAIN01_class(self.address)
        self.rVSENCURVE = rVSENCURVE_class(self.address)
        self.rVSENRATIO0 = rVSENRATIO0_class(self.address)
        self.rVSENRATIO1 = rVSENRATIO1_class(self.address)
        self.rVSENRATIO2 = rVSENRATIO2_class(self.address)
        self.rVSENTEMPCO = rVSENTEMPCO_class(self.address)
        self.rTELADCCURVEGAIN = rTELADCCURVEGAIN_class(self.address)
        self.rTELADCRATIO = rTELADCRATIO_class(self.address)
        self.rTELADCTEMPCO = rTELADCTEMPCO_class(self.address)
        self.rVSENOFFSET01 = rVSENOFFSET01_class(self.address)
        self.rISENCURVE = rISENCURVE_class(self.address)
        self.rVCCGAINOFFSET = rVCCGAINOFFSET_class(self.address)
        self.rISENTEMPCO = rISENTEMPCO_class(self.address)
        self.rISENRATIO01 = rISENRATIO01_class(self.address)
        self.rISENRATIO23 = rISENRATIO23_class(self.address)
        self.rFACCONFIG0 = rFACCONFIG0_class(self.address)
        self.rFACCONFIG = rFACCONFIG_class(self.address)
        self.rFACVINTTEMPSLOTCFG = rFACVINTTEMPSLOTCFG_class(self.address)
        self.rFACAZEXTSLOTCFG = rFACAZEXTSLOTCFG_class(self.address)
        self.rCHXCTLFULLPWR = rCHXCTLFULLPWR_class(self.address)
        self.RTCINT = RTCINT_class(self.address)
        self.RTCINT2 = RTCINT2_class(self.address)
        self.RVSENDIGOFFSET = RVSENDIGOFFSET_class(self.address)
        self.rFACCONFIG1 = rFACCONFIG1_class(self.address)
        self.rPINRESFILTGAIN = rPINRESFILTGAIN_class(self.address)
        self.rSDIFFLTCFG = rSDIFFLTCFG_class(self.address)
        self.rSDIFFACCFG = rSDIFFACCFG_class(self.address)
        self.rFACDIOMAP0 = rFACDIOMAP0_class(self.address)
        self.rFACDIOMAP1 = rFACDIOMAP1_class(self.address)
        self.rISENGAINTRIM01 = rISENGAINTRIM01_class(self.address)
        self.rISENGAINTRIM23 = rISENGAINTRIM23_class(self.address)
        self.rPHADCOFFTRIM = rPHADCOFFTRIM_class(self.address)
        self.rFACSPARE0 = rFACSPARE0_class(self.address)


    #################################################
    ## Basic DMA functionality
    #################################################
    def dma(self, register, value = None):
        if (isinstance(register, str)):
            if register.upper() in getRegAddr:
                register = getRegAddr[register.upper()]
            
        Cmd1 = pmbusCommand.cPMBusIntCmd(0xC7)
        Cmd2 = pmbusCommand.cPMBusLongCmd(0xC6)
        
        Cmd1.Write(self.address, register)
        if (value == None):
            value = Cmd2.Read(self.address)
        else:
            Cmd2.Write(self.address, value)
            
        return(value)
